Found the following features in expression file:
left
base
right
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileDialog.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileDialog.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/DropListener.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/DropListener.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileEntryNotFoundException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileEntryNotFoundException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileIsBinaryException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileIsBinaryException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/JarEntryFilter.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/JarEntryFilter.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/Closer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/Closer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/Model.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/Model.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/ConfigSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/ConfigSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/Luyten.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/Luyten.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FindAllBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FindAllBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/TreeUtil.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/TreeUtil.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FindBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FindBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/MainMenuBar.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/MainMenuBar.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/TooLargeFileException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/TooLargeFileException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/FileSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/CellRenderer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/CellRenderer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/TreeNodeUserObject.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/TreeNodeUserObject.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/LuytenPreferences.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/LuytenPreferences.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/OpenFile.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/OpenFile.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/WindowPosition.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/WindowPosition.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/MainWindow.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/MainWindow.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/LuytenTypeLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/left/src/us/deathmarine/luyten/LuytenTypeLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileDialog.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileDialog.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/DropListener.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/DropListener.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileEntryNotFoundException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileEntryNotFoundException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileIsBinaryException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileIsBinaryException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/JarEntryFilter.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/JarEntryFilter.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/Closer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/Closer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/Model.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/Model.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/ConfigSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/ConfigSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/Luyten.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/Luyten.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/TreeUtil.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/TreeUtil.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FindBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FindBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/MainMenuBar.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/MainMenuBar.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/TooLargeFileException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/TooLargeFileException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/FileSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/CellRenderer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/CellRenderer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/TreeNodeUserObject.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/TreeNodeUserObject.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/LuytenPreferences.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/LuytenPreferences.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/OpenFile.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/OpenFile.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/WindowPosition.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/WindowPosition.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/MainWindow.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/MainWindow.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/LuytenTypeLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/base/src/com/modcrafting/luyten/LuytenTypeLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileDialog.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileDialog.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/DropListener.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/DropListener.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileEntryNotFoundException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileEntryNotFoundException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileIsBinaryException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileIsBinaryException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/JarEntryFilter.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/JarEntryFilter.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Closer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Closer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Model.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Model.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/ConfigSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/ConfigSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Luyten.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Luyten.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/LinkProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/LinkProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/TreeUtil.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/TreeUtil.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FindBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FindBox.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Selection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/Selection.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/MainMenuBar.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/MainMenuBar.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/TooLargeFileException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/TooLargeFileException.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/FileSaver.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/CellRenderer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/CellRenderer.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/TreeNodeUserObject.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/TreeNodeUserObject.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/LuytenPreferences.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/LuytenPreferences.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/OpenFile.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/OpenFile.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/DecompilerLinkProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/DecompilerLinkProvider.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/WindowPosition.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/WindowPosition.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/MainWindow.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/MainWindow.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/LuytenTypeLoader.java
processing: /home/ppp/Research_Projects/Merge_Conflicts/Resource/Paper/bowen-icsme-2023-data/ConflictBench/Resource/merge_scenarios/Luyten/f2153b295cf851a1b317c2a47f0852b13e55dff2/right/src/com/modcrafting/luyten/LuytenTypeLoader.java
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> us : Folder]
			[NT -> deathmarine : Folder]
				[NT -> luyten : Folder]
					[NT -> FileDialog.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> javax.swing.JFileChooser{ImportPackage} : ImportDeclaration "import javax.swing.JFileChooser;" compose:Replacement merge: Default]
							[T -> javax.swing.filechooser.FileFilter{ImportPackage} : ImportDeclaration "import javax.swing.filechooser.FileFilter;" compose:Replacement merge: Default]
							[NT -> FileDialog : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileDialog : Id "FileDialog" compose:Replacement merge: Default]
								[T -> configSaver : FieldDecl "private ConfigSaver configSaver;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> parent : FieldDecl "private Component parent;" compose:Replacement merge: SemanticConflict]
								[T -> fcOpen : FieldDecl "private JFileChooser fcOpen;" compose:Replacement merge: SemanticConflict]
								[T -> fcSave : FieldDecl "private JFileChooser fcSave;" compose:Replacement merge: SemanticConflict]
								[T -> fcSaveAll : FieldDecl "private JFileChooser fcSaveAll;" compose:Replacement merge: SemanticConflict]
								[T -> FileDialog(Component-Component) : ConstructorDecl "public FileDialog(Component parent) {   this.parent = parent;   configSaver = ConfigSaver.getLoadedInstance();   luytenPrefs = configSaver.getLuytenPreferences();    new Thread() {    public void run() {     initOpenDialog();     initSaveDialog();     initSaveAllDialog();    };   }.start();  }" compose:Replacement merge: LineBased]
								[T -> doOpenDialog({FormalParametersInternal}) : MethodDecl "public File doOpenDialog() {   File selectedFile = null;   initOpenDialog();    retrieveOpenDialogDir(fcOpen);   int returnVal = fcOpen.showOpenDialog(parent);   saveOpenDialogDir(fcOpen);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcOpen.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> doSaveDialog(String-String) : MethodDecl "public File doSaveDialog(String recommendedFileName) {   File selectedFile = null;   initSaveDialog();    retrieveSaveDialogDir(fcSave);   fcSave.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSave.showSaveDialog(parent);   saveSaveDialogDir(fcSave);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSave.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> doSaveAllDialog(String-String) : MethodDecl "public File doSaveAllDialog(String recommendedFileName) {   File selectedFile = null;   initSaveAllDialog();      retrieveSaveDialogDir(fcSaveAll);   fcSaveAll.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSaveAll.showSaveDialog(parent);   saveSaveDialogDir(fcSaveAll);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSaveAll.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> initOpenDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initOpenDialog() {   if (fcOpen == null) {    fcOpen = createFileChooser("*.jar", "*.zip", "*.class");    retrieveOpenDialogDir(fcOpen);   }  }" compose:Replacement merge: LineBased]
								[T -> initSaveDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initSaveDialog() {   if (fcSave == null) {    fcSave = createFileChooser("*.txt", "*.java");    retrieveSaveDialogDir(fcSave);   }  }" compose:Replacement merge: LineBased]
								[T -> initSaveAllDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initSaveAllDialog() {   if (fcSaveAll == null) {    fcSaveAll = createFileChooser("*.jar", "*.zip");    retrieveSaveDialogDir(fcSaveAll);   }  }" compose:Replacement merge: LineBased]
								[T -> createFileChooser(String-String) : MethodDecl "private JFileChooser createFileChooser(String... fileFilters) {   JFileChooser fc = new JFileChooser();   for (String fileFilter : fileFilters) {    fc.addChoosableFileFilter(new FileChooserFileFilter(fileFilter));   }   fc.setFileSelectionMode(JFileChooser.FILES_ONLY);   fc.setMultiSelectionEnabled(false);   return fc;  }" compose:Replacement merge: LineBased]
								[NT -> FileChooserFileFilter : InnerClassDecl]
									[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FileChooserFileFilter : Id "FileChooserFileFilter" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends FileFilter" compose:Replacement merge: Default]
									[T -> objType : FieldDecl "String objType;" compose:Replacement merge: SemanticConflict]
									[T -> FileChooserFileFilter(String-String) : ConstructorDecl "public FileChooserFileFilter(String string) {    objType = string;   }" compose:Replacement merge: LineBased]
									[T -> accept(File-File) : MethodDecl "@Override   public boolean accept(File f) {    if (f.isDirectory())     return false;    return f.getName().toLowerCase().endsWith(objType.substring(1));   }" compose:Replacement merge: LineBased]
									[T -> getDescription({FormalParametersInternal}) : MethodDecl "@Override   public String getDescription() {    return objType;   }" compose:Replacement merge: LineBased]
								[T -> retrieveOpenDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void retrieveOpenDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileOpenCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveOpenDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void saveOpenDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileOpenCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> retrieveSaveDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void retrieveSaveDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileSaveCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveSaveDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void saveSaveDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileSaveCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
					[NT -> DropListener.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.datatransfer.DataFlavor{ImportPackage} : ImportDeclaration "import java.awt.datatransfer.DataFlavor;" compose:Replacement merge: Default]
							[T -> java.awt.datatransfer.Transferable{ImportPackage} : ImportDeclaration "import java.awt.datatransfer.Transferable;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DnDConstants{ImportPackage} : ImportDeclaration "import java.awt.dnd.DnDConstants;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetDragEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetDragEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetDropEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetDropEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetListener{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetListener;" compose:Replacement merge: Default]
							[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.Reader{ImportPackage} : ImportDeclaration "import java.io.Reader;" compose:Replacement merge: Default]
							[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: Default]
							[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
							[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
							[NT -> DropListener : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> DropListener : Id "DropListener" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements DropTargetListener" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> DropListener(MainWindow-MainWindow) : ConstructorDecl "public DropListener(MainWindow mainWindow) {   this.mainWindow = mainWindow;  }" compose:Replacement merge: LineBased]
								[T -> drop(DropTargetDropEvent-DropTargetDropEvent) : MethodDecl "@SuppressWarnings("unchecked")  @Override  public void drop(DropTargetDropEvent event) {   event.acceptDrop(DnDConstants.ACTION_COPY);   Transferable transferable = event.getTransferable();   if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    for (DataFlavor flavor : flavors) {     try {      if (flavor.isFlavorJavaFileListType()) {       List<File> files = (List<File>) transferable         .getTransferData(flavor);       if (files.size() > 1) {        event.rejectDrop();        return;       }       if (files.size() == 1) {        mainWindow.onFileDropped(files.get(0));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }    event.dropComplete(true);   } else {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    boolean handled = false;    for (int zz = 0; zz < flavors.length; zz++) {     if (flavors[zz].isRepresentationClassReader()) {      try {       Reader reader = flavors[zz].getReaderForText(transferable);       BufferedReader br = new BufferedReader(reader);       List<File> list = new ArrayList<File>();       String line = null;       while ((line = br.readLine()) != null) {        try {         if (new String("" + (char) 0).equals(line))          continue;         File file = new File(new URI(line));         list.add(file);        } catch (Exception ex) {         ex.printStackTrace();        }       }       if (list.size() > 1) {        event.rejectDrop();        return;       }       if (list.size() == 1) {        mainWindow.onFileDropped(list.get(0));       }       event.getDropTargetContext().dropComplete(true);       handled = true;      } catch (Exception e) {       e.printStackTrace();      }      break;     }    }    if (!handled) {     event.rejectDrop();    }   }   }" compose:Replacement merge: LineBased]
								[T -> dragEnter(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dragEnter(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dragExit(DropTargetEvent-DropTargetEvent) : MethodDecl "@Override  public void dragExit(DropTargetEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dragOver(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dragOver(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dropActionChanged(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dropActionChanged(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
					[NT -> FileEntryNotFoundException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[NT -> FileEntryNotFoundException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileEntryNotFoundException : Id "FileEntryNotFoundException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
					[NT -> FileIsBinaryException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[NT -> FileIsBinaryException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileIsBinaryException : Id "FileIsBinaryException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
					[NT -> JarEntryFilter.java : Java-File]
					[NT -> Closer.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[NT -> Closer : ClassDeclaration]
								[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Closer : Id "Closer" compose:Replacement merge: Default]
								[T -> tryClose(AutoCloseable-AutoCloseable) : MethodDecl "public static void tryClose(final AutoCloseable c) {         if (c == null) {             return;         }         try {             c.close();         }         catch (Throwable ignored) {         }     }" compose:Replacement merge: LineBased]
								[T -> tryClose(AutoCloseable-AutoCloseable) : MethodDecl "public static void tryClose(final AutoCloseable... items) {         if (items == null) {             return;         }         for (AutoCloseable c : items) {             tryClose(c);         }     }" compose:Replacement merge: LineBased]
					[NT -> Model.java : Java-File]
					[NT -> ConfigSaver.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.lang.reflect.Field{ImportPackage} : ImportDeclaration "import java.lang.reflect.Field;" compose:Replacement merge: Default]
							[T -> java.lang.reflect.Modifier{ImportPackage} : ImportDeclaration "import java.lang.reflect.Modifier;" compose:Replacement merge: Default]
							[T -> java.util.prefs.Preferences{ImportPackage} : ImportDeclaration "import java.util.prefs.Preferences;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Language{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Language;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Languages{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Languages;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.java.JavaFormattingOptions{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.java.JavaFormattingOptions;" compose:Replacement merge: Default]
							[NT -> ConfigSaver : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> ConfigSaver : Id "ConfigSaver" compose:Replacement merge: Default]
								[T -> FLATTEN_SWITCH_BLOCKS_ID : FieldDecl "private static final String FLATTEN_SWITCH_BLOCKS_ID = "flattenSwitchBlocks";" compose:Replacement merge: SemanticConflict]
								[T -> FORCE_EXPLICIT_IMPORTS_ID : FieldDecl "private static final String FORCE_EXPLICIT_IMPORTS_ID = "forceExplicitImports";" compose:Replacement merge: SemanticConflict]
								[T -> SHOW_SYNTHETIC_MEMBERS_ID : FieldDecl "private static final String SHOW_SYNTHETIC_MEMBERS_ID = "showSyntheticMembers";" compose:Replacement merge: SemanticConflict]
								[T -> EXCLUDE_NESTED_TYPES_ID : FieldDecl "private static final String EXCLUDE_NESTED_TYPES_ID = "excludeNestedTypes";" compose:Replacement merge: SemanticConflict]
								[T -> FORCE_EXPLICIT_TYPE_ARGUMENTS_ID : FieldDecl "private static final String FORCE_EXPLICIT_TYPE_ARGUMENTS_ID = "forceExplicitTypeArguments";" compose:Replacement merge: SemanticConflict]
								[T -> RETAIN_REDUNDANT_CASTS_ID : FieldDecl "private static final String RETAIN_REDUNDANT_CASTS_ID = "retainRedundantCasts";" compose:Replacement merge: SemanticConflict]
								[T -> INCLUDE_ERROR_DIAGNOSTICS_ID : FieldDecl "private static final String INCLUDE_ERROR_DIAGNOSTICS_ID = "includeErrorDiagnostics";" compose:Replacement merge: SemanticConflict]
								[T -> UNICODE_REPLACE_ENABLED_ID : FieldDecl "private static final String UNICODE_REPLACE_ENABLED_ID = "unicodeReplaceEnabled";" compose:Replacement merge: SemanticConflict]
								[T -> LANGUAGE_NAME_ID : FieldDecl "private static final String LANGUAGE_NAME_ID = "languageName";" compose:Replacement merge: SemanticConflict]
								[T -> MAIN_WINDOW_ID_PREFIX : FieldDecl "private static final String MAIN_WINDOW_ID_PREFIX = "main";" compose:Replacement merge: SemanticConflict]
								[T -> FIND_WINDOW_ID_PREFIX : FieldDecl "private static final String FIND_WINDOW_ID_PREFIX = "find";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_IS_FULL_SCREEN_ID : FieldDecl "private static final String WINDOW_IS_FULL_SCREEN_ID = "WindowIsFullScreen";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_WIDTH_ID : FieldDecl "private static final String WINDOW_WIDTH_ID = "WindowWidth";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_HEIGHT_ID : FieldDecl "private static final String WINDOW_HEIGHT_ID = "WindowHeight";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_X_ID : FieldDecl "private static final String WINDOW_X_ID = "WindowX";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_Y_ID : FieldDecl "private static final String WINDOW_Y_ID = "WindowY";" compose:Replacement merge: SemanticConflict]
								[T -> decompilerSettings : FieldDecl "private DecompilerSettings decompilerSettings;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindowPosition : FieldDecl "private WindowPosition mainWindowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> findWindowPosition : FieldDecl "private WindowPosition findWindowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPreferences : FieldDecl "private LuytenPreferences luytenPreferences;" compose:Replacement merge: SemanticConflict]
								[T -> isUnicodeReplaceEnabled : FieldDecl "private boolean isUnicodeReplaceEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> theLoadedInstance : FieldDecl "private static ConfigSaver theLoadedInstance;" compose:Replacement merge: SemanticConflict]
								[T -> ConfigSaver({FormalParametersInternal}) : ConstructorDecl "private ConfigSaver() {}" compose:Replacement merge: LineBased]
								[T -> getLoadedInstance({FormalParametersInternal}) : MethodDecl "public static ConfigSaver getLoadedInstance() {   if (theLoadedInstance == null) {    synchronized (ConfigSaver.class) {     if (theLoadedInstance == null) {      theLoadedInstance = new ConfigSaver();      theLoadedInstance.loadConfig();     }    }   }   return theLoadedInstance;  }" compose:Replacement merge: LineBased]
								[T -> loadConfig({FormalParametersInternal}) : MethodDecl "private void loadConfig() {   decompilerSettings = new DecompilerSettings();   if (decompilerSettings.getFormattingOptions() == null) {    decompilerSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   luytenPreferences = new LuytenPreferences();   mainWindowPosition = new WindowPosition();   findWindowPosition = new WindowPosition();   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);    if(!prefs.get(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName()).equals(      decompilerSettings.getLanguage().getName()))     prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     decompilerSettings.setFlattenSwitchBlocks(prefs.getBoolean(FLATTEN_SWITCH_BLOCKS_ID,      decompilerSettings.getFlattenSwitchBlocks()));    decompilerSettings.setForceExplicitImports(prefs.getBoolean(FORCE_EXPLICIT_IMPORTS_ID,      decompilerSettings.getForceExplicitImports()));    decompilerSettings.setShowSyntheticMembers(prefs.getBoolean(SHOW_SYNTHETIC_MEMBERS_ID,      decompilerSettings.getShowSyntheticMembers()));    decompilerSettings.setExcludeNestedTypes(prefs.getBoolean(EXCLUDE_NESTED_TYPES_ID,      decompilerSettings.getExcludeNestedTypes()));    decompilerSettings.setForceExplicitTypeArguments(prefs.getBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID,      decompilerSettings.getForceExplicitTypeArguments()));    decompilerSettings.setRetainRedundantCasts(prefs.getBoolean(RETAIN_REDUNDANT_CASTS_ID,      decompilerSettings.getRetainRedundantCasts()));    decompilerSettings.setIncludeErrorDiagnostics(prefs.getBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID,      decompilerSettings.getIncludeErrorDiagnostics()));    decompilerSettings.setLanguage(findLanguageByName(prefs.get(LANGUAGE_NAME_ID,      decompilerSettings.getLanguage().getName())));    isUnicodeReplaceEnabled = prefs.getBoolean(UNICODE_REPLACE_ENABLED_ID, false);     mainWindowPosition = loadWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX);    findWindowPosition = loadWindowPosition(prefs, FIND_WINDOW_ID_PREFIX);    luytenPreferences = loadLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> loadWindowPosition(Preferences-Preferences-String-String) : MethodDecl "private WindowPosition loadWindowPosition(Preferences prefs, String windowIdPrefix) {   WindowPosition windowPosition = new WindowPosition();   windowPosition.setFullScreen(prefs.getBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, false));   windowPosition.setWindowWidth(prefs.getInt(windowIdPrefix + WINDOW_WIDTH_ID, 0));   windowPosition.setWindowHeight(prefs.getInt(windowIdPrefix + WINDOW_HEIGHT_ID, 0));   windowPosition.setWindowX(prefs.getInt(windowIdPrefix + WINDOW_X_ID, 0));   windowPosition.setWindowY(prefs.getInt(windowIdPrefix + WINDOW_Y_ID, 0));   return windowPosition;  }" compose:Replacement merge: LineBased]
								[T -> loadLuytenPreferences(Preferences-Preferences) : MethodDecl "private LuytenPreferences loadLuytenPreferences(Preferences prefs) throws Exception {   LuytenPreferences newLuytenPrefs = new LuytenPreferences();   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object defaultVal = field.get(newLuytenPrefs);     if (field.getType() == String.class) {     String defaultStr = (String) (defaultVal == null ? "" : defaultVal);     field.set(newLuytenPrefs, prefs.get(prefId, defaultStr));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     Boolean defaultBool = (Boolean) (defaultVal == null ? new Boolean(false) : defaultVal);     field.setBoolean(newLuytenPrefs, prefs.getBoolean(prefId, defaultBool));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     Integer defaultInt = (Integer) (defaultVal == null ? new Integer(0) : defaultVal);     field.setInt(newLuytenPrefs, prefs.getInt(prefId, defaultInt));    }   }   return newLuytenPrefs;  }" compose:Replacement merge: LineBased]
								[T -> saveConfig({FormalParametersInternal}) : MethodDecl "public void saveConfig() {   // Registry path on Windows Xp:   // HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\modcrafting\luyten   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     prefs.putBoolean(FLATTEN_SWITCH_BLOCKS_ID, decompilerSettings.getFlattenSwitchBlocks());    prefs.putBoolean(FORCE_EXPLICIT_IMPORTS_ID, decompilerSettings.getForceExplicitImports());    prefs.putBoolean(SHOW_SYNTHETIC_MEMBERS_ID, decompilerSettings.getShowSyntheticMembers());    prefs.putBoolean(EXCLUDE_NESTED_TYPES_ID, decompilerSettings.getExcludeNestedTypes());    prefs.putBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID, decompilerSettings.getForceExplicitTypeArguments());    prefs.putBoolean(RETAIN_REDUNDANT_CASTS_ID, decompilerSettings.getRetainRedundantCasts());    prefs.putBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID, decompilerSettings.getIncludeErrorDiagnostics());    prefs.putBoolean(UNICODE_REPLACE_ENABLED_ID, isUnicodeReplaceEnabled);    prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     saveWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX, mainWindowPosition);    saveWindowPosition(prefs, FIND_WINDOW_ID_PREFIX, findWindowPosition);    saveLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveWindowPosition(Preferences-Preferences-String-String-WindowPosition-WindowPosition) : MethodDecl "private void saveWindowPosition(Preferences prefs, String windowIdPrefix, WindowPosition windowPosition) {   prefs.putBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, windowPosition.isFullScreen());   prefs.putInt(windowIdPrefix + WINDOW_WIDTH_ID, windowPosition.getWindowWidth());   prefs.putInt(windowIdPrefix + WINDOW_HEIGHT_ID, windowPosition.getWindowHeight());   prefs.putInt(windowIdPrefix + WINDOW_X_ID, windowPosition.getWindowX());   prefs.putInt(windowIdPrefix + WINDOW_Y_ID, windowPosition.getWindowY());  }" compose:Replacement merge: LineBased]
								[T -> saveLuytenPreferences(Preferences-Preferences) : MethodDecl "private void saveLuytenPreferences(Preferences prefs) throws Exception {   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object value = field.get(luytenPreferences);     if (field.getType() == String.class) {     prefs.put(prefId, (String) (value == null ? "" : value));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     prefs.putBoolean(prefId, (Boolean) (value == null ? new Boolean(false) : value));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     prefs.putInt(prefId, (Integer) (value == null ? new Integer(0) : value));    }   }  }" compose:Replacement merge: LineBased]
								[T -> findLanguageByName(String-String) : MethodDecl "private Language findLanguageByName(String languageName) {   if (languageName != null) {     if (languageName.equals(Languages.java().getName())) {     return Languages.java();    } else if (languageName.equals(Languages.bytecode().getName())) {     return Languages.bytecode();    } else if (languageName.equals(Languages.bytecodeAst().getName())) {     return Languages.bytecodeAst();    }     for (Language language : Languages.debug()) {     if (languageName.equals(language.getName())) {      return language;     }    }   }   return Languages.java();  }" compose:Replacement merge: LineBased]
								[T -> getDecompilerSettings({FormalParametersInternal}) : MethodDecl "public DecompilerSettings getDecompilerSettings() {   return decompilerSettings;  }" compose:Replacement merge: LineBased]
								[T -> isUnicodeReplaceEnabled({FormalParametersInternal}) : MethodDecl "public boolean isUnicodeReplaceEnabled(){   return isUnicodeReplaceEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setUnicodeReplaceEnabled(boolean-boolean) : MethodDecl "public void setUnicodeReplaceEnabled(boolean value){   isUnicodeReplaceEnabled = value;  }" compose:Replacement merge: LineBased]
								[T -> getMainWindowPosition({FormalParametersInternal}) : MethodDecl "public WindowPosition getMainWindowPosition() {   return mainWindowPosition;  }" compose:Replacement merge: LineBased]
								[T -> getFindWindowPosition({FormalParametersInternal}) : MethodDecl "public WindowPosition getFindWindowPosition() {   return findWindowPosition;  }" compose:Replacement merge: LineBased]
								[T -> getLuytenPreferences({FormalParametersInternal}) : MethodDecl "public LuytenPreferences getLuytenPreferences() {   return luytenPreferences;  }" compose:Replacement merge: LineBased]
					[NT -> Luyten.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> javax.swing.SwingUtilities{ImportPackage} : ImportDeclaration "import javax.swing.SwingUtilities;" compose:Replacement merge: Default]
							[T -> javax.swing.UIManager{ImportPackage} : ImportDeclaration "import javax.swing.UIManager;" compose:Replacement merge: Default]
							[NT -> Luyten : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Luyten : Id "Luyten" compose:Replacement merge: Default]
								[T -> main(String[]-String[]) : MethodDecl "public static void main(String[] args) {   try {    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());   } catch (Exception e) {    e.printStackTrace();   }    // for TotalCommander External Viewer setting:   // javaw -jar "c:\Program Files\Luyten\luyten.jar"   // (TC will not complain about temporary file when opening .class from .zip or .jar)   final File fileFromCommandLine = getFileFromCommandLine(args);    SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     MainWindow mainWindow = new MainWindow(fileFromCommandLine);     mainWindow.setVisible(true);    }   });  }" compose:Replacement merge: LineBased]
								[T -> getFileFromCommandLine(String[]-String[]) : MethodDecl "public static File getFileFromCommandLine(String[] args) {   File fileFromCommandLine = null;   try {    if (args.length > 0) {     String realFileName = new File(args[0]).getCanonicalPath();     fileFromCommandLine = new File(realFileName);    }   } catch (Exception e) {    e.printStackTrace();   }   return fileFromCommandLine;  }" compose:Replacement merge: LineBased]
					[NT -> FindAllBox.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.TypeDefinition{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.TypeDefinition;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.TypeReference{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.TypeReference;" compose:Replacement merge: Default]
							[T -> com.strobel.core.StringUtilities{ImportPackage} : ImportDeclaration "import com.strobel.core.StringUtilities;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilationOptions{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilationOptions;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.PlainTextOutput{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.PlainTextOutput;" compose:Replacement merge: Default]
							[T -> us.deathmarine.luyten.ConfigSaver{ImportPackage} : ImportDeclaration "import us.deathmarine.luyten.ConfigSaver;" compose:Replacement merge: Default]
							[T -> us.deathmarine.luyten.MainWindow{ImportPackage} : ImportDeclaration "import us.deathmarine.luyten.MainWindow;" compose:Replacement merge: Default]
							[T -> us.deathmarine.luyten.Model{ImportPackage} : ImportDeclaration "import us.deathmarine.luyten.Model;" compose:Replacement merge: Default]
							[T -> java.awt.* : ImportDeclaration "import java.awt.*;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionListener{ImportPackage} : ImportDeclaration "import java.awt.event.ActionListener;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
							[T -> java.io.StringWriter{ImportPackage} : ImportDeclaration "import java.io.StringWriter;" compose:Replacement merge: Default]
							[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
							[T -> java.util.Enumeration{ImportPackage} : ImportDeclaration "import java.util.Enumeration;" compose:Replacement merge: Default]
							[T -> java.util.jar.JarEntry{ImportPackage} : ImportDeclaration "import java.util.jar.JarEntry;" compose:Replacement merge: Default]
							[T -> java.util.jar.JarFile{ImportPackage} : ImportDeclaration "import java.util.jar.JarFile;" compose:Replacement merge: Default]
							[T -> javax.swing.* : ImportDeclaration "import javax.swing.*;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout.Alignment{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout.Alignment;" compose:Replacement merge: Default]
							[NT -> FindAllBox : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FindAllBox : Id "FindAllBox" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JDialog" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -4125409760166690462L;" compose:Replacement merge: SemanticConflict]
								[T -> cancel : FieldDecl "private boolean cancel;" compose:Replacement merge: SemanticConflict]
								[T -> searching : FieldDecl "private boolean searching;" compose:Replacement merge: SemanticConflict]
								[T -> findButton : FieldDecl "private JButton findButton;" compose:Replacement merge: SemanticConflict]
								[T -> textField : FieldDecl "private JTextField textField;" compose:Replacement merge: SemanticConflict]
								[T -> progressBar : FieldDecl "JProgressBar progressBar;" compose:Replacement merge: SemanticConflict]
								[T -> classesList : FieldDecl "private DefaultListModel<String> classesList = new DefaultListModel<String>();" compose:Replacement merge: SemanticConflict]
								[T -> statusLabel : FieldDecl "private JLabel statusLabel = new JLabel("");" compose:Replacement merge: SemanticConflict]
								[T -> FindAllBox({FormalParametersInternal}) : ConstructorDecl "public FindAllBox() {   progressBar = new JProgressBar(0, 100);   JLabel label = new JLabel("Find What:");   textField = new JTextField();   findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    JList<String> list = new JList<String>(classesList);   list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);   list.setLayoutOrientation(JList.VERTICAL_WRAP);   list.setVisibleRowCount(-1);   JScrollPane listScroller = new JScrollPane(list);    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     500);   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    JButton cancelButton = new JButton("Cancel");   cancelButton.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     if (isSearching())      setCancel(true);    }   });    layout.setHorizontalGroup(layout     .createSequentialGroup()     .addComponent(label)     .addGroup(       layout.createParallelGroup(Alignment.LEADING)         .addComponent(statusLabel)         .addComponent(textField)         .addGroup(           layout.createSequentialGroup()             .addGroup(               layout.createParallelGroup(                 Alignment.LEADING)                 .addComponent(                   listScroller)                 .addComponent(                   progressBar))))     .addGroup(       layout.createParallelGroup(Alignment.LEADING)         .addComponent(findButton)         .addComponent(cancelButton))    );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout     .createSequentialGroup()     .addGroup(       layout.createParallelGroup(Alignment.BASELINE)         .addComponent(label).addComponent(textField)         .addComponent(findButton))     .addGroup(       layout.createParallelGroup(Alignment.LEADING).addGroup(         layout.createSequentialGroup().addGroup(           layout.createParallelGroup(             Alignment.BASELINE)             .addComponent(listScroller)             .addComponent(cancelButton))))     .addGroup(layout.createParallelGroup(Alignment.LEADING))     .addComponent(statusLabel).addComponent(progressBar));   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();   this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();   this.setModalityType(Dialog.ModalityType.APPLICATION_MODAL);    this.setName("Find All");   this.setTitle("Find All");  }" compose:Replacement merge: LineBased]
								[NT -> FindButton : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FindButton : Id "FindButton" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 75954129199541874L;" compose:Replacement merge: SemanticConflict]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent event) {    Thread tmp_thread = new Thread() {     public void run() {      setSearching(true);      classesList.clear();      ConfigSaver configSaver = ConfigSaver.getLoadedInstance();      DecompilerSettings settings = configSaver        .getDecompilerSettings();      File inFile = MainWindow.model.getOpenedFile();      try {       JarFile jfile = new JarFile(inFile);       Enumeration<JarEntry> entLength = jfile.entries();       initProgressBar(Collections.list(entLength).size());       Enumeration<JarEntry> ent = jfile.entries();       while (ent.hasMoreElements() && !isCancel()) {        JarEntry entry = ent.nextElement();        setStatus(entry.getName());        if (entry.getName().endsWith(".class")) {         synchronized (settings) {          String internalName = StringUtilities            .removeRight(entry.getName(),              ".class");          TypeReference type = Model.metadataSystem            .lookupType(internalName);          TypeDefinition resolvedType = null;          if (type == null            || ((resolvedType = type.resolve()) == null)) {           throw new Exception(             "Unable to resolve type.");          }          StringWriter stringwriter = new StringWriter();          DecompilationOptions decompilationOptions;          decompilationOptions = new DecompilationOptions();          decompilationOptions.setSettings(settings);          decompilationOptions            .setFullDecompilation(true);          settings.getLanguage().decompileType(            resolvedType,            new PlainTextOutput(stringwriter),            decompilationOptions);          String decompiledSource = stringwriter            .toString().toLowerCase();          if (decompiledSource.contains(textField            .getText().toLowerCase())) {           addClassName(entry.getName());          }         }        }       }       setSearching(false);       if (isCancel()) {        setCancel(false);        setStatus("Cancelled.");       } else {        setStatus("Done.");       }       jfile.close();      } catch (IOException e1) {       e1.printStackTrace();      } catch (Exception e1) {       e1.printStackTrace();      }     }    };    tmp_thread.start();    }" compose:Replacement merge: LineBased]
								[T -> setHideOnEscapeButton({FormalParametersInternal}) : MethodDecl "private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindAllBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,     0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)     .put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance()     .getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(),      windowPosition.getWindowY());   }  }" compose:Replacement merge: LineBased]
								[T -> setSaveWindowPositionOnClosing({FormalParametersInternal}) : MethodDecl "private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance()       .getFindWindowPosition();     windowPosition.readPositionFromDialog(FindAllBox.this);     if (isSearching())      setCancel(true);    }   });  }" compose:Replacement merge: LineBased]
								[T -> showFindBox({FormalParametersInternal}) : MethodDecl "public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();  }" compose:Replacement merge: LineBased]
								[T -> hideFindBox({FormalParametersInternal}) : MethodDecl "public void hideFindBox() {   this.setVisible(false);  }" compose:Replacement merge: LineBased]
								[T -> setStatus(String-String) : MethodDecl "public void setStatus(String text) {   if (text.length() > 25) {    this.statusLabel.setText("Searching in file: ..."      + text.substring(text.length() - 25));   } else {    this.statusLabel.setText("Searching in file: " + text);   }    progressBar.setValue(progressBar.getValue() + 1);  }" compose:Replacement merge: LineBased]
								[T -> addClassName(String-String) : MethodDecl "public void addClassName(String className) {   this.classesList.addElement(className);  }" compose:Replacement merge: LineBased]
								[T -> initProgressBar(Integer-Integer) : MethodDecl "public void initProgressBar(Integer length) {   progressBar.setMaximum(length);   progressBar.setValue(0);   progressBar.setStringPainted(true);  }" compose:Replacement merge: LineBased]
								[T -> isCancel({FormalParametersInternal}) : MethodDecl "public boolean isCancel() {   return cancel;  }" compose:Replacement merge: LineBased]
								[T -> setCancel(boolean-boolean) : MethodDecl "public void setCancel(boolean cancel) {   this.cancel = cancel;  }" compose:Replacement merge: LineBased]
								[T -> isSearching({FormalParametersInternal}) : MethodDecl "public boolean isSearching() {   return searching;  }" compose:Replacement merge: LineBased]
								[T -> setSearching(boolean-boolean) : MethodDecl "public void setSearching(boolean searching) {   this.searching = searching;  }" compose:Replacement merge: LineBased]
					[NT -> TreeUtil.java : Java-File]
					[NT -> FindBox.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.Action{ImportPackage} : ImportDeclaration "import javax.swing.Action;" compose:Replacement merge: Default]
							[T -> javax.swing.BorderFactory{ImportPackage} : ImportDeclaration "import javax.swing.BorderFactory;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout.Alignment{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout.Alignment;" compose:Replacement merge: Default]
							[T -> javax.swing.JButton{ImportPackage} : ImportDeclaration "import javax.swing.JButton;" compose:Replacement merge: Default]
							[T -> javax.swing.JCheckBox{ImportPackage} : ImportDeclaration "import javax.swing.JCheckBox;" compose:Replacement merge: Default]
							[T -> javax.swing.JComponent{ImportPackage} : ImportDeclaration "import javax.swing.JComponent;" compose:Replacement merge: Default]
							[T -> javax.swing.JDialog{ImportPackage} : ImportDeclaration "import javax.swing.JDialog;" compose:Replacement merge: Default]
							[T -> javax.swing.JLabel{ImportPackage} : ImportDeclaration "import javax.swing.JLabel;" compose:Replacement merge: Default]
							[T -> javax.swing.JTextField{ImportPackage} : ImportDeclaration "import javax.swing.JTextField;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.SwingConstants{ImportPackage} : ImportDeclaration "import javax.swing.SwingConstants;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rsyntaxtextarea.RSyntaxTextArea{ImportPackage} : ImportDeclaration "import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rtextarea.SearchContext{ImportPackage} : ImportDeclaration "import org.fife.ui.rtextarea.SearchContext;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rtextarea.SearchEngine{ImportPackage} : ImportDeclaration "import org.fife.ui.rtextarea.SearchEngine;" compose:Replacement merge: Default]
							[NT -> FindBox : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FindBox : Id "FindBox" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JDialog" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -4125409760166690462L;" compose:Replacement merge: SemanticConflict]
								[T -> mcase : FieldDecl "private JCheckBox mcase;" compose:Replacement merge: SemanticConflict]
								[T -> regex : FieldDecl "private JCheckBox regex;" compose:Replacement merge: SemanticConflict]
								[T -> wholew : FieldDecl "private JCheckBox wholew;" compose:Replacement merge: SemanticConflict]
								[T -> reverse : FieldDecl "private JCheckBox reverse;" compose:Replacement merge: SemanticConflict]
								[T -> findButton : FieldDecl "private JButton findButton;" compose:Replacement merge: SemanticConflict]
								[T -> textField : FieldDecl "private JTextField textField;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> showFindBox({FormalParametersInternal}) : MethodDecl "public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();  }" compose:Replacement merge: LineBased]
								[T -> hideFindBox({FormalParametersInternal}) : MethodDecl "public void hideFindBox() {   this.setVisible(false);  }" compose:Replacement merge: LineBased]
								[T -> FindBox(MainWindow-MainWindow) : ConstructorDecl "public FindBox(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();    JLabel label = new JLabel("Find What:");   textField = new JTextField();    RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();   if (pane != null) {    textField.setText(pane.getSelectedText());   }   mcase = new JCheckBox("Match Case");   regex = new JCheckBox("Regex");   wholew = new JCheckBox("Whole Words");   reverse = new JCheckBox("Search Backwards");    findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    mcase.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   regex.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   wholew.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   reverse.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     Math.min((int) (screenSize.height * 0.20), 200));   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    layout.setHorizontalGroup(layout.createSequentialGroup()     .addComponent(label)     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(textField)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(mcase)           .addComponent(wholew))         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(regex)           .addComponent(reverse))))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(findButton))     );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(Alignment.BASELINE)       .addComponent(label)       .addComponent(textField)       .addComponent(findButton))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(mcase)           .addComponent(regex))         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(wholew)           .addComponent(reverse))))     );    this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();    this.setName("Find");   this.setTitle("Find");   this.setVisible(true);  }" compose:Replacement merge: LineBased]
								[NT -> FindButton : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FindButton : Id "FindButton" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 75954129199541874L;" compose:Replacement merge: SemanticConflict]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent event) {    if (textField.getText().length() == 0)     return;     RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();    if (pane == null)     return;     SearchContext context = new SearchContext();    context.setSearchFor(textField.getText());    context.setMatchCase(mcase.isSelected());    context.setRegularExpression(regex.isSelected());    context.setSearchForward(!reverse.isSelected());    context.setWholeWord(wholew.isSelected());     if (!SearchEngine.find(pane, context).wasFound()) {     pane.setSelectionStart(0);     pane.setSelectionEnd(0);    }   }" compose:Replacement merge: LineBased]
								[T -> setHideOnEscapeButton({FormalParametersInternal}) : MethodDecl "private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(), windowPosition.getWindowY());   }  }" compose:Replacement merge: LineBased]
								[T -> setSaveWindowPositionOnClosing({FormalParametersInternal}) : MethodDecl "private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();     windowPosition.readPositionFromDialog(FindBox.this);    }   });  }" compose:Replacement merge: LineBased]
					[NT -> MainMenuBar.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionListener{ImportPackage} : ImportDeclaration "import java.awt.event.ActionListener;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
							[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
							[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractButton{ImportPackage} : ImportDeclaration "import javax.swing.AbstractButton;" compose:Replacement merge: Default]
							[T -> javax.swing.ButtonGroup{ImportPackage} : ImportDeclaration "import javax.swing.ButtonGroup;" compose:Replacement merge: Default]
							[T -> javax.swing.ButtonModel{ImportPackage} : ImportDeclaration "import javax.swing.ButtonModel;" compose:Replacement merge: Default]
							[T -> javax.swing.JCheckBox{ImportPackage} : ImportDeclaration "import javax.swing.JCheckBox;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenu{ImportPackage} : ImportDeclaration "import javax.swing.JMenu;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenuBar{ImportPackage} : ImportDeclaration "import javax.swing.JMenuBar;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenuItem{ImportPackage} : ImportDeclaration "import javax.swing.JMenuItem;" compose:Replacement merge: Default]
							[T -> javax.swing.JOptionPane{ImportPackage} : ImportDeclaration "import javax.swing.JOptionPane;" compose:Replacement merge: Default]
							[T -> javax.swing.JRadioButtonMenuItem{ImportPackage} : ImportDeclaration "import javax.swing.JRadioButtonMenuItem;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.text.DefaultEditorKit{ImportPackage} : ImportDeclaration "import javax.swing.text.DefaultEditorKit;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Language{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Language;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Languages{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Languages;" compose:Replacement merge: Default]
							[NT -> MainMenuBar : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> MainMenuBar : Id "MainMenuBar" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JMenuBar" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private final MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> languageLookup : FieldDecl "private final Map<String, Language> languageLookup = new HashMap<String, Language>();" compose:Replacement merge: SemanticConflict]
								[T -> flattenSwitchBlocks : FieldDecl "private JCheckBox flattenSwitchBlocks;" compose:Replacement merge: SemanticConflict]
								[T -> forceExplicitImports : FieldDecl "private JCheckBox forceExplicitImports;" compose:Replacement merge: SemanticConflict]
								[T -> forceExplicitTypes : FieldDecl "private JCheckBox forceExplicitTypes;" compose:Replacement merge: SemanticConflict]
								[T -> showSyntheticMembers : FieldDecl "private JCheckBox showSyntheticMembers;" compose:Replacement merge: SemanticConflict]
								[T -> excludeNestedTypes : FieldDecl "private JCheckBox excludeNestedTypes;" compose:Replacement merge: SemanticConflict]
								[T -> retainRedundantCasts : FieldDecl "private JCheckBox retainRedundantCasts;" compose:Replacement merge: SemanticConflict]
								[T -> unicodeReplacement : FieldDecl "private JCheckBox unicodeReplacement;" compose:Replacement merge: SemanticConflict]
								[T -> showDebugInfo : FieldDecl "private JCheckBox showDebugInfo;" compose:Replacement merge: SemanticConflict]
								[T -> java : FieldDecl "private JRadioButtonMenuItem java;" compose:Replacement merge: SemanticConflict]
								[T -> bytecode : FieldDecl "private JRadioButtonMenuItem bytecode;" compose:Replacement merge: SemanticConflict]
								[T -> bytecodeAST : FieldDecl "private JRadioButtonMenuItem bytecodeAST;" compose:Replacement merge: SemanticConflict]
								[T -> languagesGroup : FieldDecl "private ButtonGroup languagesGroup;" compose:Replacement merge: SemanticConflict]
								[T -> themesGroup : FieldDecl "private ButtonGroup themesGroup;" compose:Replacement merge: SemanticConflict]
								[T -> packageExplorerStyle : FieldDecl "private JCheckBox packageExplorerStyle;" compose:Replacement merge: SemanticConflict]
								[T -> filterOutInnerClassEntries : FieldDecl "private JCheckBox filterOutInnerClassEntries;" compose:Replacement merge: SemanticConflict]
								[T -> singleClickOpenEnabled : FieldDecl "private JCheckBox singleClickOpenEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> exitByEscEnabled : FieldDecl "private JCheckBox exitByEscEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> settings : FieldDecl "private DecompilerSettings settings;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> MainMenuBar(MainWindow-MainWindow) : ConstructorDecl "public MainMenuBar(MainWindow mainWnd) {   this.mainWindow = mainWnd;   final ConfigSaver configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    final JMenu fileMenu = new JMenu("File");   fileMenu.add(new JMenuItem("..."));   this.add(fileMenu);   final JMenu editMenu = new JMenu("Edit");   editMenu.add(new JMenuItem("..."));   this.add(editMenu);   final JMenu themesMenu = new JMenu("Themes");   themesMenu.add(new JMenuItem("..."));   this.add(themesMenu);   final JMenu operationMenu = new JMenu("Operation");   operationMenu.add(new JMenuItem("..."));   this.add(operationMenu);   final JMenu settingsMenu = new JMenu("Settings");   settingsMenu.add(new JMenuItem("..."));   this.add(settingsMenu);   final JMenu helpMenu = new JMenu("Help");   helpMenu.add(new JMenuItem("..."));   this.add(helpMenu);    // start quicker   new Thread() {    public void run() {     try {      // build menu later      buildFileMenu(fileMenu);      refreshMenuPopup(fileMenu);       buildEditMenu(editMenu);      refreshMenuPopup(editMenu);       buildThemesMenu(themesMenu);      refreshMenuPopup(themesMenu);       buildOperationMenu(operationMenu);      refreshMenuPopup(operationMenu);       buildSettingsMenu(settingsMenu, configSaver);      refreshMenuPopup(settingsMenu);       buildHelpMenu(helpMenu);      refreshMenuPopup(helpMenu);     } catch (Exception e) {      e.printStackTrace();     }    }     // refresh currently opened menu     // (if user selected a menu before it was ready)    private void refreshMenuPopup(JMenu menu) {     try {      if (menu.isPopupMenuVisible()) {       menu.getPopupMenu().setVisible(false);       menu.getPopupMenu().setVisible(true);      }     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }" compose:Replacement merge: LineBased]
								[T -> buildFileMenu(JMenu-JMenu) : MethodDecl "private void buildFileMenu(final JMenu fileMenu) {   fileMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Open File...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onOpenFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Close");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onCloseFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Save As...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAsMenu();    }   });   fileMenu.add(menuItem);    menuItem = new JMenuItem("Save All...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAllMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Recent Files");   menuItem.setEnabled(false);   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Exit");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onExitMenu();    }   });   fileMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> buildEditMenu(JMenu-JMenu) : MethodDecl "private void buildEditMenu(JMenu editMenu) {   editMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Cut");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    menuItem = new JMenuItem("Copy");   menuItem.addActionListener(new DefaultEditorKit.CopyAction());   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));   editMenu.add(menuItem);    menuItem = new JMenuItem("Paste");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    editMenu.addSeparator();    menuItem = new JMenuItem("Select All");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSelectAllMenu();    }   });   editMenu.add(menuItem);   editMenu.addSeparator();    menuItem = new JMenuItem("Find...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onFindMenu();    }   });   editMenu.add(menuItem);          menuItem = new JMenuItem("Find All");         menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, ActionEvent.CTRL_MASK));         menuItem.addActionListener(new ActionListener() {             @Override             public void actionPerformed(ActionEvent e) {                 mainWindow.onFindAllMenu();              }         });         editMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> buildThemesMenu(JMenu-JMenu) : MethodDecl "private void buildThemesMenu(JMenu themesMenu) {   themesMenu.removeAll();   themesGroup = new ButtonGroup();   JRadioButtonMenuItem a = new JRadioButtonMenuItem(new ThemeAction("Default", "default.xml"));   a.setSelected("default.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Dark", "dark.xml"));   a.setSelected("dark.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Eclipse", "eclipse.xml"));   a.setSelected("eclipse.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Visual Studio", "vs.xml"));   a.setSelected("vs.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);  }" compose:Replacement merge: LineBased]
								[T -> buildOperationMenu(JMenu-JMenu) : MethodDecl "private void buildOperationMenu(JMenu operationMenu) {   operationMenu.removeAll();   packageExplorerStyle = new JCheckBox("    Package Explorer Style");   packageExplorerStyle.setSelected(luytenPrefs.isPackageExplorerStyle());   packageExplorerStyle.setContentAreaFilled(false);   packageExplorerStyle.setFocusable(false);   packageExplorerStyle.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setPackageExplorerStyle(packageExplorerStyle.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(packageExplorerStyle);      filterOutInnerClassEntries = new JCheckBox("    Filter Out Inner Class Entries");   filterOutInnerClassEntries.setSelected(luytenPrefs.isFilterOutInnerClassEntries());   filterOutInnerClassEntries.setContentAreaFilled(false);   filterOutInnerClassEntries.setFocusable(false);   filterOutInnerClassEntries.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setFilterOutInnerClassEntries(filterOutInnerClassEntries.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(filterOutInnerClassEntries);    singleClickOpenEnabled = new JCheckBox("    Single Click Open");   singleClickOpenEnabled.setSelected(luytenPrefs.isSingleClickOpenEnabled());   singleClickOpenEnabled.setContentAreaFilled(false);   singleClickOpenEnabled.setFocusable(false);   singleClickOpenEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setSingleClickOpenEnabled(singleClickOpenEnabled.isSelected());    }   });   operationMenu.add(singleClickOpenEnabled);    exitByEscEnabled = new JCheckBox("    Exit By Esc");   exitByEscEnabled.setSelected(luytenPrefs.isExitByEscEnabled());   exitByEscEnabled.setContentAreaFilled(false);   exitByEscEnabled.setFocusable(false);   exitByEscEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setExitByEscEnabled(exitByEscEnabled.isSelected());    }   });   operationMenu.add(exitByEscEnabled);  }" compose:Replacement merge: LineBased]
								[T -> buildSettingsMenu(JMenu-JMenu-ConfigSaver-ConfigSaver) : MethodDecl "private void buildSettingsMenu(JMenu settingsMenu, ConfigSaver configSaver) {   settingsMenu.removeAll();   ActionListener settingsChanged = new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     new Thread() {      @Override      public void run() {       populateSettingsFromSettingsMenu();       mainWindow.onSettingsChanged();      }     }.start();    }   };   flattenSwitchBlocks = new JCheckBox("    Flatten Switch Blocks");   flattenSwitchBlocks.setSelected(settings.getFlattenSwitchBlocks());   flattenSwitchBlocks.setContentAreaFilled(false);   flattenSwitchBlocks.setFocusable(false);   flattenSwitchBlocks.addActionListener(settingsChanged);   settingsMenu.add(flattenSwitchBlocks);    forceExplicitImports = new JCheckBox("    Force Explicit Imports");   forceExplicitImports.setSelected(settings.getForceExplicitImports());   forceExplicitImports.setContentAreaFilled(false);   forceExplicitImports.setFocusable(false);   forceExplicitImports.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitImports);    forceExplicitTypes = new JCheckBox("    Force Explicit Types");   forceExplicitTypes.setSelected(settings.getForceExplicitTypeArguments());   forceExplicitTypes.setContentAreaFilled(false);   forceExplicitTypes.setFocusable(false);   forceExplicitTypes.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitTypes);    showSyntheticMembers = new JCheckBox("    Show Synthetic Members");   showSyntheticMembers.setSelected(settings.getShowSyntheticMembers());   showSyntheticMembers.setContentAreaFilled(false);   showSyntheticMembers.setFocusable(false);   showSyntheticMembers.addActionListener(settingsChanged);   settingsMenu.add(showSyntheticMembers);    excludeNestedTypes = new JCheckBox("    Exclude Nested Types");   excludeNestedTypes.setSelected(settings.getExcludeNestedTypes());   excludeNestedTypes.setContentAreaFilled(false);   excludeNestedTypes.setFocusable(false);   excludeNestedTypes.addActionListener(settingsChanged);   settingsMenu.add(excludeNestedTypes);    retainRedundantCasts = new JCheckBox("    Retain Redundant Casts");   retainRedundantCasts.setSelected(settings.getRetainRedundantCasts());   retainRedundantCasts.setContentAreaFilled(false);   retainRedundantCasts.setFocusable(false);   retainRedundantCasts.addActionListener(settingsChanged);   settingsMenu.add(retainRedundantCasts);    unicodeReplacement = new JCheckBox("    Enable Unicode Replacement");   unicodeReplacement.setSelected(configSaver.isUnicodeReplaceEnabled());   unicodeReplacement.setContentAreaFilled(false);   unicodeReplacement.setFocusable(false);   unicodeReplacement.addActionListener(settingsChanged);   settingsMenu.add(unicodeReplacement);    JMenu debugSettingsMenu = new JMenu("Debug Settings");   showDebugInfo = new JCheckBox("    Include Error Diagnostics");   showDebugInfo.setSelected(settings.getIncludeErrorDiagnostics());   showDebugInfo.setContentAreaFilled(false);   showDebugInfo.setFocusable(false);   showDebugInfo.addActionListener(settingsChanged);    debugSettingsMenu.add(showDebugInfo);   settingsMenu.add(debugSettingsMenu);   settingsMenu.addSeparator();    languageLookup.put(Languages.java().getName(), Languages.java());   languageLookup.put(Languages.bytecode().getName(), Languages.bytecode());   languageLookup.put(Languages.bytecodeAst().getName(), Languages.bytecodeAst());    languagesGroup = new ButtonGroup();   java = new JRadioButtonMenuItem(Languages.java().getName());   java.getModel().setActionCommand(Languages.java().getName());   java.setSelected(Languages.java().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(java);   settingsMenu.add(java);   bytecode = new JRadioButtonMenuItem(Languages.bytecode().getName());   bytecode.getModel().setActionCommand(Languages.bytecode().getName());   bytecode.setSelected(Languages.bytecode().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecode);   settingsMenu.add(bytecode);   bytecodeAST = new JRadioButtonMenuItem(Languages.bytecodeAst().getName());   bytecodeAST.getModel().setActionCommand(Languages.bytecodeAst().getName());   bytecodeAST.setSelected(Languages.bytecodeAst().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecodeAST);   settingsMenu.add(bytecodeAST);    JMenu debugLanguagesMenu = new JMenu("Debug Languages");   for (final Language language : Languages.debug()) {    final JRadioButtonMenuItem m = new JRadioButtonMenuItem(language.getName());    m.getModel().setActionCommand(language.getName());    m.setSelected(language.getName().equals(settings.getLanguage().getName()));    languagesGroup.add(m);    debugLanguagesMenu.add(m);    languageLookup.put(language.getName(), language);   }   for (AbstractButton button : Collections.list(languagesGroup.getElements())) {    button.addActionListener(settingsChanged);   }   settingsMenu.add(debugLanguagesMenu);  }" compose:Replacement merge: LineBased]
								[T -> buildHelpMenu(JMenu-JMenu) : MethodDecl "private void buildHelpMenu(JMenu helpMenu) {   helpMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Legal");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onLegalMenu();    }   });   helpMenu.add(menuItem);   menuItem = new JMenuItem("About");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent event) {     JOptionPane.showMessageDialog(null,       "Luyten Gui \n" +         "by Deathmarine, Zerdei\n\n" +         "Powered By\nProcyon\n" +         "(c) 2013 Mike Strobel\n\n" +         "RSyntaxTextArea\n" +         "(c) 2012 Robert Futrell\n" +         "All rights reserved.");    }   });   helpMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> populateSettingsFromSettingsMenu({FormalParametersInternal}) : MethodDecl "private void populateSettingsFromSettingsMenu() {   // synchronized: do not disturb decompiler at work (synchronize every time before run decompiler)   synchronized (settings) {    settings.setFlattenSwitchBlocks(flattenSwitchBlocks.isSelected());    settings.setForceExplicitImports(forceExplicitImports.isSelected());    settings.setShowSyntheticMembers(showSyntheticMembers.isSelected());    settings.setExcludeNestedTypes(excludeNestedTypes.isSelected());    settings.setForceExplicitTypeArguments(forceExplicitTypes.isSelected());    settings.setRetainRedundantCasts(retainRedundantCasts.isSelected());    settings.setIncludeErrorDiagnostics(showDebugInfo.isSelected());    ConfigSaver.getLoadedInstance().setUnicodeReplaceEnabled(unicodeReplacement.isSelected());    //    // Note: You shouldn't ever need to set this.  It's only for languages that support catch    //       blocks without an exception variable.  Java doesn't allow this.  I think Scala does.    //    // settings.setAlwaysGenerateExceptionVariableForCatchBlocks(true);    //     final ButtonModel selectedLanguage = languagesGroup.getSelection();    if (selectedLanguage != null) {     final Language language = languageLookup.get(selectedLanguage.getActionCommand());      if (language != null)      settings.setLanguage(language);    }     if (java.isSelected()) {     settings.setLanguage(Languages.java());    } else if (bytecode.isSelected()) {     settings.setLanguage(Languages.bytecode());    } else if (bytecodeAST.isSelected()) {     settings.setLanguage(Languages.bytecodeAst());    }   }  }" compose:Replacement merge: LineBased]
								[NT -> ThemeAction : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> ThemeAction : Id "ThemeAction" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -6618680171943723199L;" compose:Replacement merge: SemanticConflict]
									[T -> xml : FieldDecl "private String xml;" compose:Replacement merge: SemanticConflict]
									[T -> ThemeAction(String-String-String-String) : ConstructorDecl "public ThemeAction(String name, String xml) {    putValue(NAME, name);    this.xml = xml;   }" compose:Replacement merge: LineBased]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent e) {    luytenPrefs.setThemeXml(xml);    mainWindow.onThemesChanged();   }" compose:Replacement merge: LineBased]
					[NT -> TooLargeFileException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.text.DecimalFormat{ImportPackage} : ImportDeclaration "import java.text.DecimalFormat;" compose:Replacement merge: Default]
							[NT -> TooLargeFileException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> TooLargeFileException : Id "TooLargeFileException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> size : FieldDecl "private long size;" compose:Replacement merge: SemanticConflict]
								[T -> TooLargeFileException(long-long) : ConstructorDecl "public TooLargeFileException(long size) {   this.size = size;  }" compose:Replacement merge: LineBased]
								[T -> getReadableFileSize({FormalParametersInternal}) : MethodDecl "public String getReadableFileSize() {   if (size <= 0)    return "0";   final String[] units = new String[] {"B", "KB", "MB", "GB", "TB"};   int digitGroups = (int) (Math.log10(size) / Math.log10(1024));   return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];  }" compose:Replacement merge: LineBased]
					[NT -> FileSaver.java : Java-File]
					[NT -> CellRenderer.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> javax.swing.Icon{ImportPackage} : ImportDeclaration "import javax.swing.Icon;" compose:Replacement merge: Default]
							[T -> javax.swing.ImageIcon{ImportPackage} : ImportDeclaration "import javax.swing.ImageIcon;" compose:Replacement merge: Default]
							[T -> javax.swing.JTree{ImportPackage} : ImportDeclaration "import javax.swing.JTree;" compose:Replacement merge: Default]
							[T -> javax.swing.tree.DefaultMutableTreeNode{ImportPackage} : ImportDeclaration "import javax.swing.tree.DefaultMutableTreeNode;" compose:Replacement merge: Default]
							[T -> javax.swing.tree.DefaultTreeCellRenderer{ImportPackage} : ImportDeclaration "import javax.swing.tree.DefaultTreeCellRenderer;" compose:Replacement merge: Default]
							[NT -> CellRenderer : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> CellRenderer : Id "CellRenderer" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends DefaultTreeCellRenderer" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -5691181006363313993L;" compose:Replacement merge: SemanticConflict]
								[T -> pack : FieldDecl "Icon pack;" compose:Replacement merge: SemanticConflict]
								[T -> java_image : FieldDecl "Icon java_image;" compose:Replacement merge: SemanticConflict]
								[T -> file_image : FieldDecl "Icon file_image;" compose:Replacement merge: SemanticConflict]
								[T -> CellRenderer({FormalParametersInternal}) : ConstructorDecl "public CellRenderer(){   this.pack = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/package_obj.png")));   this.java_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/java.png")));   this.file_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/file.png")));  }" compose:Replacement merge: LineBased]
								[T -> getTreeCellRendererComponent(JTree-JTree-Object-Object-boolean-boolean-boolean-boolean-boolean-boolean-int-int-boolean-boolean) : MethodDecl "@Override  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);         DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;   if(node.getChildCount() > 0){    setIcon(this.pack);   }else if(getFileName(node).endsWith(".class") || getFileName(node).endsWith(".java")){    setIcon(this.java_image);   }else{    setIcon(this.file_image);   }      return this;  }" compose:Replacement merge: LineBased]
								[T -> getFileName(DefaultMutableTreeNode-DefaultMutableTreeNode) : MethodDecl "public String getFileName(DefaultMutableTreeNode node){         return ((TreeNodeUserObject) node.getUserObject()).getOriginalName();  }" compose:Replacement merge: LineBased]
					[NT -> TreeNodeUserObject.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[NT -> TreeNodeUserObject : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> TreeNodeUserObject : Id "TreeNodeUserObject" compose:Replacement merge: Default]
								[T -> originalName : FieldDecl "private String originalName;" compose:Replacement merge: SemanticConflict]
								[T -> displayName : FieldDecl "private String displayName;" compose:Replacement merge: SemanticConflict]
								[T -> TreeNodeUserObject(String-String) : ConstructorDecl "public TreeNodeUserObject(String name) {   this(name, name);  }" compose:Replacement merge: LineBased]
								[T -> TreeNodeUserObject(String-String-String-String) : ConstructorDecl "public TreeNodeUserObject(String originalName, String displayName) {   this.originalName = originalName;   this.displayName = displayName;  }" compose:Replacement merge: LineBased]
								[T -> getOriginalName({FormalParametersInternal}) : MethodDecl "public String getOriginalName() {   return originalName;  }" compose:Replacement merge: LineBased]
								[T -> setOriginalName(String-String) : MethodDecl "public void setOriginalName(String originalName) {   this.originalName = originalName;  }" compose:Replacement merge: LineBased]
								[T -> getDisplayName({FormalParametersInternal}) : MethodDecl "public String getDisplayName() {   return displayName;  }" compose:Replacement merge: LineBased]
								[T -> setDisplayName(String-String) : MethodDecl "public void setDisplayName(String displayName) {   this.displayName = displayName;  }" compose:Replacement merge: LineBased]
								[T -> toString({FormalParametersInternal}) : MethodDecl "@Override  public String toString() {   return displayName;  }" compose:Replacement merge: LineBased]
					[NT -> LuytenPreferences.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[NT -> LuytenPreferences : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> LuytenPreferences : Id "LuytenPreferences" compose:Replacement merge: Default]
								[T -> THEME_XML_PATH : FieldDecl "public static final String THEME_XML_PATH = "/themes/";" compose:Replacement merge: SemanticConflict]
								[T -> DEFAULT_THEME_XML : FieldDecl "public static final String DEFAULT_THEME_XML = "eclipse.xml";" compose:Replacement merge: SemanticConflict]
								[T -> themeXml : FieldDecl "private String themeXml = DEFAULT_THEME_XML;" compose:Replacement merge: SemanticConflict]
								[T -> fileOpenCurrentDirectory : FieldDecl "private String fileOpenCurrentDirectory = "";" compose:Replacement merge: SemanticConflict]
								[T -> fileSaveCurrentDirectory : FieldDecl "private String fileSaveCurrentDirectory = "";" compose:Replacement merge: SemanticConflict]
								[T -> isPackageExplorerStyle : FieldDecl "private boolean isPackageExplorerStyle = true;" compose:Replacement merge: SemanticConflict]
								[T -> isFilterOutInnerClassEntries : FieldDecl "private boolean isFilterOutInnerClassEntries = true;" compose:Replacement merge: SemanticConflict]
								[T -> isSingleClickOpenEnabled : FieldDecl "private boolean isSingleClickOpenEnabled = true;" compose:Replacement merge: SemanticConflict]
								[T -> isExitByEscEnabled : FieldDecl "private boolean isExitByEscEnabled = false;" compose:Replacement merge: SemanticConflict]
								[T -> getThemeXml({FormalParametersInternal}) : MethodDecl "public String getThemeXml() {   return themeXml;  }" compose:Replacement merge: LineBased]
								[T -> setThemeXml(String-String) : MethodDecl "public void setThemeXml(String themeXml) {   this.themeXml = themeXml;  }" compose:Replacement merge: LineBased]
								[T -> getFileOpenCurrentDirectory({FormalParametersInternal}) : MethodDecl "public String getFileOpenCurrentDirectory() {   return fileOpenCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> setFileOpenCurrentDirectory(String-String) : MethodDecl "public void setFileOpenCurrentDirectory(String fileOpenCurrentDirectory) {   this.fileOpenCurrentDirectory = fileOpenCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> getFileSaveCurrentDirectory({FormalParametersInternal}) : MethodDecl "public String getFileSaveCurrentDirectory() {   return fileSaveCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> setFileSaveCurrentDirectory(String-String) : MethodDecl "public void setFileSaveCurrentDirectory(String fileSaveCurrentDirectory) {   this.fileSaveCurrentDirectory = fileSaveCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> isPackageExplorerStyle({FormalParametersInternal}) : MethodDecl "public boolean isPackageExplorerStyle() {   return isPackageExplorerStyle;  }" compose:Replacement merge: LineBased]
								[T -> setPackageExplorerStyle(boolean-boolean) : MethodDecl "public void setPackageExplorerStyle(boolean isPackageExplorerStyle) {   this.isPackageExplorerStyle = isPackageExplorerStyle;  }" compose:Replacement merge: LineBased]
								[T -> isFilterOutInnerClassEntries({FormalParametersInternal}) : MethodDecl "public boolean isFilterOutInnerClassEntries() {   return isFilterOutInnerClassEntries;  }" compose:Replacement merge: LineBased]
								[T -> setFilterOutInnerClassEntries(boolean-boolean) : MethodDecl "public void setFilterOutInnerClassEntries(boolean isFilterOutInnerClassEntries) {   this.isFilterOutInnerClassEntries = isFilterOutInnerClassEntries;  }" compose:Replacement merge: LineBased]
								[T -> isSingleClickOpenEnabled({FormalParametersInternal}) : MethodDecl "public boolean isSingleClickOpenEnabled() {   return isSingleClickOpenEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setSingleClickOpenEnabled(boolean-boolean) : MethodDecl "public void setSingleClickOpenEnabled(boolean isSingleClickOpenEnabled) {   this.isSingleClickOpenEnabled = isSingleClickOpenEnabled;  }" compose:Replacement merge: LineBased]
								[T -> isExitByEscEnabled({FormalParametersInternal}) : MethodDecl "public boolean isExitByEscEnabled() {   return isExitByEscEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setExitByEscEnabled(boolean-boolean) : MethodDecl "public void setExitByEscEnabled(boolean isExitByEscEnabled) {   this.isExitByEscEnabled = isExitByEscEnabled;  }" compose:Replacement merge: LineBased]
					[NT -> OpenFile.java : Java-File]
					[NT -> WindowPosition.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> javax.swing.JDialog{ImportPackage} : ImportDeclaration "import javax.swing.JDialog;" compose:Replacement merge: Default]
							[T -> javax.swing.JFrame{ImportPackage} : ImportDeclaration "import javax.swing.JFrame;" compose:Replacement merge: Default]
							[NT -> WindowPosition : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> WindowPosition : Id "WindowPosition" compose:Replacement merge: Default]
								[T -> isFullScreen : FieldDecl "private boolean isFullScreen;" compose:Replacement merge: SemanticConflict]
								[T -> windowWidth : FieldDecl "private int windowWidth;" compose:Replacement merge: SemanticConflict]
								[T -> windowHeight : FieldDecl "private int windowHeight;" compose:Replacement merge: SemanticConflict]
								[T -> windowX : FieldDecl "private int windowX;" compose:Replacement merge: SemanticConflict]
								[T -> windowY : FieldDecl "private int windowY;" compose:Replacement merge: SemanticConflict]
								[T -> readPositionFromWindow(JFrame-JFrame) : MethodDecl "public void readPositionFromWindow(JFrame window) {   isFullScreen = (window.getExtendedState() == JFrame.MAXIMIZED_BOTH);   if (!isFullScreen) {    this.readPositionFromComponent(window);   }  }" compose:Replacement merge: LineBased]
								[T -> readPositionFromDialog(JDialog-JDialog) : MethodDecl "public void readPositionFromDialog(JDialog dialog) {   this.readPositionFromComponent(dialog);  }" compose:Replacement merge: LineBased]
								[T -> readPositionFromComponent(Component-Component) : MethodDecl "private void readPositionFromComponent(Component component) {   isFullScreen = false;   windowWidth = component.getWidth();   windowHeight = component.getHeight();   windowX = component.getX();   windowY = component.getY();  }" compose:Replacement merge: LineBased]
								[T -> isSavedWindowPositionValid({FormalParametersInternal}) : MethodDecl "public boolean isSavedWindowPositionValid() {   if (isFullScreen) {    return true;   }   if (windowWidth < 100 || windowHeight < 100) {    return false;   }   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (windowWidth > screenSize.width + 50 || windowHeight > screenSize.height + 50) {    return false;   }   if (windowY < -20 || windowY > screenSize.height - 50 ||     windowX < 50 - windowWidth || windowX > screenSize.width - 50) {    return false;   }   return true;  }" compose:Replacement merge: LineBased]
								[T -> isFullScreen({FormalParametersInternal}) : MethodDecl "public boolean isFullScreen() {   return isFullScreen;  }" compose:Replacement merge: LineBased]
								[T -> setFullScreen(boolean-boolean) : MethodDecl "public void setFullScreen(boolean isFullScreen) {   this.isFullScreen = isFullScreen;  }" compose:Replacement merge: LineBased]
								[T -> getWindowWidth({FormalParametersInternal}) : MethodDecl "public int getWindowWidth() {   return windowWidth;  }" compose:Replacement merge: LineBased]
								[T -> setWindowWidth(int-int) : MethodDecl "public void setWindowWidth(int windowWidth) {   this.windowWidth = windowWidth;  }" compose:Replacement merge: LineBased]
								[T -> getWindowHeight({FormalParametersInternal}) : MethodDecl "public int getWindowHeight() {   return windowHeight;  }" compose:Replacement merge: LineBased]
								[T -> setWindowHeight(int-int) : MethodDecl "public void setWindowHeight(int windowHeight) {   this.windowHeight = windowHeight;  }" compose:Replacement merge: LineBased]
								[T -> getWindowX({FormalParametersInternal}) : MethodDecl "public int getWindowX() {   return windowX;  }" compose:Replacement merge: LineBased]
								[T -> setWindowX(int-int) : MethodDecl "public void setWindowX(int windowX) {   this.windowX = windowX;  }" compose:Replacement merge: LineBased]
								[T -> getWindowY({FormalParametersInternal}) : MethodDecl "public int getWindowY() {   return windowY;  }" compose:Replacement merge: LineBased]
								[T -> setWindowY(int-int) : MethodDecl "public void setWindowY(int windowY) {   this.windowY = windowY;  }" compose:Replacement merge: LineBased]
					[NT -> MainWindow.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.BorderLayout{ImportPackage} : ImportDeclaration "import java.awt.BorderLayout;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.FlowLayout{ImportPackage} : ImportDeclaration "import java.awt.FlowLayout;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTarget{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTarget;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ComponentAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.ComponentAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.ComponentEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ComponentEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
							[T -> java.io.InputStreamReader{ImportPackage} : ImportDeclaration "import java.io.InputStreamReader;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.Action{ImportPackage} : ImportDeclaration "import javax.swing.Action;" compose:Replacement merge: Default]
							[T -> javax.swing.ImageIcon{ImportPackage} : ImportDeclaration "import javax.swing.ImageIcon;" compose:Replacement merge: Default]
							[T -> javax.swing.JComponent{ImportPackage} : ImportDeclaration "import javax.swing.JComponent;" compose:Replacement merge: Default]
							[T -> javax.swing.JFrame{ImportPackage} : ImportDeclaration "import javax.swing.JFrame;" compose:Replacement merge: Default]
							[T -> javax.swing.JLabel{ImportPackage} : ImportDeclaration "import javax.swing.JLabel;" compose:Replacement merge: Default]
							[T -> javax.swing.JPanel{ImportPackage} : ImportDeclaration "import javax.swing.JPanel;" compose:Replacement merge: Default]
							[T -> javax.swing.JProgressBar{ImportPackage} : ImportDeclaration "import javax.swing.JProgressBar;" compose:Replacement merge: Default]
							[T -> javax.swing.JSplitPane{ImportPackage} : ImportDeclaration "import javax.swing.JSplitPane;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.border.BevelBorder{ImportPackage} : ImportDeclaration "import javax.swing.border.BevelBorder;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rsyntaxtextarea.RSyntaxTextArea{ImportPackage} : ImportDeclaration "import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;" compose:Replacement merge: Default]
							[NT -> MainWindow : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> MainWindow : Id "MainWindow" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JFrame" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> TITLE : FieldDecl "private static final String TITLE = "Luyten";" compose:Replacement merge: SemanticConflict]
								[T -> model : FieldDecl "public static Model model;" compose:Replacement merge: SemanticConflict]
								[T -> bar : FieldDecl "private JProgressBar bar;" compose:Replacement merge: SemanticConflict]
								[T -> label : FieldDecl "private JLabel label;" compose:Replacement merge: SemanticConflict]
								[T -> findBox : FieldDecl "private FindBox findBox;" compose:Replacement merge: SemanticConflict]
								[T -> findAllBox : FieldDecl "private FindAllBox findAllBox;" compose:Replacement merge: SemanticConflict]
								[T -> configSaver : FieldDecl "private ConfigSaver configSaver;" compose:Replacement merge: SemanticConflict]
								[T -> windowPosition : FieldDecl "private WindowPosition windowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> fileDialog : FieldDecl "private FileDialog fileDialog;" compose:Replacement merge: SemanticConflict]
								[T -> fileSaver : FieldDecl "private FileSaver fileSaver;" compose:Replacement merge: SemanticConflict]
								[T -> MainWindow(File-File) : ConstructorDecl "public MainWindow(File fileFromCommandLine) {   configSaver = ConfigSaver.getLoadedInstance();   windowPosition = configSaver.getMainWindowPosition();   luytenPrefs = configSaver.getLuytenPreferences();    MainMenuBar mainMenuBar = new MainMenuBar(this);   this.setJMenuBar(mainMenuBar);    this.adjustWindowPositionBySavedState();   this.setHideFindBoxOnMainWindowFocus();   this.setShowFindAllBoxOnMainWindowFocus();   this.setQuitOnWindowClosing();   this.setTitle(TITLE);         this.setIconImage(new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/Luyten.png"))).getImage());    // JPanel pane = new JPanel();   JPanel panel1 = new JPanel(new FlowLayout(FlowLayout.LEFT));   label = new JLabel();   label.setHorizontalAlignment(JLabel.LEFT);   // panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setBorder(new BevelBorder(BevelBorder.LOWERED));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(label);   // pane.add(panel1);    JPanel panel2 = new JPanel(new FlowLayout(FlowLayout.RIGHT));   bar = new JProgressBar();   // bar.setIndeterminate(true);    bar.setStringPainted(true);   bar.setOpaque(false);   bar.setVisible(false);   // panel2.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel2.setPreferredSize(new Dimension(this.getWidth() / 3, 20));   panel2.add(bar);   // pane.add(panel1);    model = new Model(this);   this.getContentPane().add(model);    JSplitPane spt = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panel1,     panel2) {    private static final long serialVersionUID = 2189946972124687305L;    private final int location = 400;    {     setDividerLocation(location);    }     @Override    public int getDividerLocation() {     return location;    }     @Override    public int getLastDividerLocation() {     return location;    }   };   spt.setBorder(new BevelBorder(BevelBorder.LOWERED));   spt.setPreferredSize(new Dimension(this.getWidth(), 24));    // spt.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));   this.add(spt, BorderLayout.SOUTH);    if (fileFromCommandLine != null) {    model.loadFile(fileFromCommandLine);   }    try {    DropTarget dt = new DropTarget();    dt.addDropTargetListener(new DropListener(this));    this.setDropTarget(dt);   } catch (Exception e) {    e.printStackTrace();   }    fileDialog = new FileDialog(this);   fileSaver = new FileSaver(bar, label);    this.setExitOnEscWhenEnabled(model);    if (fileFromCommandLine == null     || fileFromCommandLine.getName().toLowerCase().endsWith(".jar")     || fileFromCommandLine.getName().toLowerCase().endsWith(".zip")) {    model.startWarmUpThread();   }  }" compose:Replacement merge: LineBased]
								[T -> onOpenFileMenu({FormalParametersInternal}) : MethodDecl "public void onOpenFileMenu() {   File selectedFile = fileDialog.doOpenDialog();   if (selectedFile != null) {    this.getModel().loadFile(selectedFile);   }  }" compose:Replacement merge: LineBased]
								[T -> onCloseFileMenu({FormalParametersInternal}) : MethodDecl "public void onCloseFileMenu() {   this.getModel().closeFile();  }" compose:Replacement merge: LineBased]
								[T -> onSaveAsMenu({FormalParametersInternal}) : MethodDecl "public void onSaveAsMenu() {   RSyntaxTextArea pane = this.getModel().getCurrentTextArea();   if (pane == null)    return;   String tabTitle = this.getModel().getCurrentTabTitle();   if (tabTitle == null)    return;    String recommendedFileName = tabTitle.replace(".class", ".java");   File selectedFile = fileDialog.doSaveDialog(recommendedFileName);   if (selectedFile != null) {    fileSaver.saveText(pane.getText(), selectedFile);   }  }" compose:Replacement merge: LineBased]
								[T -> onSaveAllMenu({FormalParametersInternal}) : MethodDecl "public void onSaveAllMenu() {   File openedFile = this.getModel().getOpenedFile();   if (openedFile == null)    return;    String fileName = openedFile.getName();   if (fileName.endsWith(".class")) {    fileName = fileName.replace(".class", ".java");   } else if (fileName.toLowerCase().endsWith(".jar")) {    fileName = "decompiled-"      + fileName.replaceAll("\\.[jJ][aA][rR]", ".zip");   } else {    fileName = "saved-" + fileName;   }    File selectedFileToSave = fileDialog.doSaveAllDialog(fileName);   if (selectedFileToSave != null) {    fileSaver.saveAllDecompiled(openedFile, selectedFileToSave);   }  }" compose:Replacement merge: LineBased]
								[T -> onExitMenu({FormalParametersInternal}) : MethodDecl "public void onExitMenu() {   quit();  }" compose:Replacement merge: LineBased]
								[T -> onSelectAllMenu({FormalParametersInternal}) : MethodDecl "public void onSelectAllMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     pane.requestFocusInWindow();     pane.setSelectionStart(0);     pane.setSelectionEnd(pane.getText().length());    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onFindMenu({FormalParametersInternal}) : MethodDecl "public void onFindMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     if (findBox == null)      findBox = new FindBox(this);     findBox.showFindBox();    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onFindAllMenu({FormalParametersInternal}) : MethodDecl "public void onFindAllMenu() {   try {    if (findAllBox == null)     findAllBox = new FindAllBox();    findAllBox.showFindBox();    } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onLegalMenu({FormalParametersInternal}) : MethodDecl "public void onLegalMenu() {   new Thread() {    public void run() {     try {      bar.setVisible(true);      bar.setIndeterminate(true);      String legalStr = getLegalStr();      MainWindow.this.getModel().showLegal(legalStr);     } finally {      bar.setIndeterminate(false);      bar.setVisible(false);     }    }   }.start();  }" compose:Replacement merge: LineBased]
								[T -> getLegalStr({FormalParametersInternal}) : MethodDecl "private String getLegalStr() {   StringBuilder sb = new StringBuilder();   try {    BufferedReader reader = new BufferedReader(new InputStreamReader(      getClass().getResourceAsStream(        "/distfiles/Procyon.License.txt")));    String line;    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");    sb.append("\n\n\n\n\n");    reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream(        "/distfiles/RSyntaxTextArea.License.txt")));    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");   } catch (IOException e) {    e.printStackTrace();   }   return sb.toString();  }" compose:Replacement merge: LineBased]
								[T -> onThemesChanged({FormalParametersInternal}) : MethodDecl "public void onThemesChanged() {   this.getModel().changeTheme(luytenPrefs.getThemeXml());  }" compose:Replacement merge: LineBased]
								[T -> onSettingsChanged({FormalParametersInternal}) : MethodDecl "public void onSettingsChanged() {   this.getModel().updateOpenClasses();  }" compose:Replacement merge: LineBased]
								[T -> onTreeSettingsChanged({FormalParametersInternal}) : MethodDecl "public void onTreeSettingsChanged() {   this.getModel().updateTree();  }" compose:Replacement merge: LineBased]
								[T -> onFileDropped(File-File) : MethodDecl "public void onFileDropped(File file) {   if (file != null) {    this.getModel().loadFile(file);   }  }" compose:Replacement merge: LineBased]
								[T -> onFileLoadEnded(File-File-boolean-boolean) : MethodDecl "public void onFileLoadEnded(File file, boolean isSuccess) {   try {    if (file != null && isSuccess) {     this.setTitle(TITLE + " - " + file.getName());    } else {     this.setTitle(TITLE);    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (!windowPosition.isSavedWindowPositionValid()) {    final Dimension center = new Dimension(      (int) (screenSize.width * 0.75),      (int) (screenSize.height * 0.75));    final int x = (int) (center.width * 0.2);    final int y = (int) (center.height * 0.2);    this.setBounds(x, y, center.width, center.height);    } else if (windowPosition.isFullScreen()) {    int heightMinusTray = screenSize.height;    if (screenSize.height > 30)     heightMinusTray -= 30;    this.setBounds(0, 0, screenSize.width, heightMinusTray);    this.setExtendedState(JFrame.MAXIMIZED_BOTH);     this.addComponentListener(new ComponentAdapter() {     @Override     public void componentResized(ComponentEvent e) {      if (MainWindow.this.getExtendedState() != JFrame.MAXIMIZED_BOTH) {       windowPosition.setFullScreen(false);       if (windowPosition.isSavedWindowPositionValid()) {        MainWindow.this.setBounds(          windowPosition.getWindowX(),          windowPosition.getWindowY(),          windowPosition.getWindowWidth(),          windowPosition.getWindowHeight());       }       MainWindow.this.removeComponentListener(this);      }     }    });    } else {    this.setBounds(windowPosition.getWindowX(),      windowPosition.getWindowY(),      windowPosition.getWindowWidth(),      windowPosition.getWindowHeight());   }  }" compose:Replacement merge: LineBased]
								[T -> setHideFindBoxOnMainWindowFocus({FormalParametersInternal}) : MethodDecl "private void setHideFindBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findBox != null && findBox.isVisible()) {      findBox.setVisible(false);     }    }   });  }" compose:Replacement merge: LineBased]
								[T -> setShowFindAllBoxOnMainWindowFocus({FormalParametersInternal}) : MethodDecl "private void setShowFindAllBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findAllBox != null && findAllBox.isVisible()) {      findAllBox.requestFocus();     }    }   });  }" compose:Replacement merge: LineBased]
								[T -> setQuitOnWindowClosing({FormalParametersInternal}) : MethodDecl "private void setQuitOnWindowClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowClosing(WindowEvent e) {     quit();    }   });  }" compose:Replacement merge: LineBased]
								[T -> quit({FormalParametersInternal}) : MethodDecl "private void quit() {   try {    windowPosition.readPositionFromWindow(this);    configSaver.saveConfig();   } catch (Exception exc) {    exc.printStackTrace();   } finally {    try {     this.dispose();    } finally {     System.exit(0);    }   }  }" compose:Replacement merge: LineBased]
								[T -> setExitOnEscWhenEnabled(JComponent-JComponent) : MethodDecl "private void setExitOnEscWhenEnabled(JComponent mainComponent) {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     if (luytenPrefs.isExitByEscEnabled()) {      quit();     }    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,     0, false);   mainComponent     .getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT)     .put(escapeKeyStroke, "ESCAPE");   mainComponent.getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> getModel({FormalParametersInternal}) : MethodDecl "public Model getModel() {   return model;  }" compose:Replacement merge: LineBased]
								[T -> getBar({FormalParametersInternal}) : MethodDecl "public JProgressBar getBar() {   return bar;  }" compose:Replacement merge: LineBased]
								[T -> getLabel({FormalParametersInternal}) : MethodDecl "public JLabel getLabel() {   return label;  }" compose:Replacement merge: LineBased]
					[NT -> LuytenTypeLoader.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package us.deathmarine.luyten;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.InputTypeLoader{ImportPackage} : ImportDeclaration "import com.strobel.assembler.InputTypeLoader;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.Buffer{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.Buffer;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.ITypeLoader{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.ITypeLoader;" compose:Replacement merge: Default]
							[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
							[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
							[NT -> LuytenTypeLoader : ClassDeclaration]
								[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> LuytenTypeLoader : Id "LuytenTypeLoader" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements ITypeLoader" compose:Replacement merge: SemanticConflict]
								[T -> _typeLoaders : FieldDecl "private final List<ITypeLoader> _typeLoaders;" compose:Replacement merge: SemanticConflict]
								[T -> LuytenTypeLoader({FormalParametersInternal}) : ConstructorDecl "public LuytenTypeLoader() {         _typeLoaders = new ArrayList<ITypeLoader>();         _typeLoaders.add(new InputTypeLoader());     }" compose:Replacement merge: LineBased]
								[T -> getTypeLoaders({FormalParametersInternal}) : MethodDecl "public final List<ITypeLoader> getTypeLoaders() {         return _typeLoaders;     }" compose:Replacement merge: LineBased]
								[T -> tryLoadType(String-String-Buffer-Buffer) : MethodDecl "@Override     public boolean tryLoadType(final String internalName, final Buffer buffer) {         for (final ITypeLoader typeLoader : _typeLoaders) {             if (typeLoader.tryLoadType(internalName, buffer)) {                 return true;             }              buffer.reset();         }          return false;     }" compose:Replacement merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> com : Folder]
			[NT -> modcrafting : Folder]
				[NT -> luyten : Folder]
					[NT -> FileDialog.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> javax.swing.JFileChooser{ImportPackage} : ImportDeclaration "import javax.swing.JFileChooser;" compose:Replacement merge: Default]
							[T -> javax.swing.filechooser.FileFilter{ImportPackage} : ImportDeclaration "import javax.swing.filechooser.FileFilter;" compose:Replacement merge: Default]
							[NT -> FileDialog : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileDialog : Id "FileDialog" compose:Replacement merge: Default]
								[T -> configSaver : FieldDecl "private ConfigSaver configSaver;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> parent : FieldDecl "private Component parent;" compose:Replacement merge: SemanticConflict]
								[T -> fcOpen : FieldDecl "private JFileChooser fcOpen;" compose:Replacement merge: SemanticConflict]
								[T -> fcSave : FieldDecl "private JFileChooser fcSave;" compose:Replacement merge: SemanticConflict]
								[T -> fcSaveAll : FieldDecl "private JFileChooser fcSaveAll;" compose:Replacement merge: SemanticConflict]
								[T -> FileDialog(Component-Component) : ConstructorDecl "public FileDialog(Component parent) {   this.parent = parent;   configSaver = ConfigSaver.getLoadedInstance();   luytenPrefs = configSaver.getLuytenPreferences();    new Thread() {    public void run() {     initOpenDialog();     initSaveDialog();     initSaveAllDialog();    };   }.start();  }" compose:Replacement merge: LineBased]
								[T -> doOpenDialog({FormalParametersInternal}) : MethodDecl "public File doOpenDialog() {   File selectedFile = null;   initOpenDialog();    retrieveOpenDialogDir(fcOpen);   int returnVal = fcOpen.showOpenDialog(parent);   saveOpenDialogDir(fcOpen);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcOpen.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> doSaveDialog(String-String) : MethodDecl "public File doSaveDialog(String recommendedFileName) {   File selectedFile = null;   initSaveDialog();    retrieveSaveDialogDir(fcSave);   fcSave.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSave.showSaveDialog(parent);   saveSaveDialogDir(fcSave);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSave.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> doSaveAllDialog(String-String) : MethodDecl "public File doSaveAllDialog(String recommendedFileName) {   File selectedFile = null;   initSaveAllDialog();      retrieveSaveDialogDir(fcSaveAll);   fcSaveAll.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSaveAll.showSaveDialog(parent);   saveSaveDialogDir(fcSaveAll);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSaveAll.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> initOpenDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initOpenDialog() {   if (fcOpen == null) {    fcOpen = createFileChooser("*.jar", "*.zip", "*.class");    retrieveOpenDialogDir(fcOpen);   }  }" compose:Replacement merge: LineBased]
								[T -> initSaveDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initSaveDialog() {   if (fcSave == null) {    fcSave = createFileChooser("*.txt", "*.java");    retrieveSaveDialogDir(fcSave);   }  }" compose:Replacement merge: LineBased]
								[T -> initSaveAllDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initSaveAllDialog() {   if (fcSaveAll == null) {    fcSaveAll = createFileChooser("*.jar", "*.zip");    retrieveSaveDialogDir(fcSaveAll);   }  }" compose:Replacement merge: LineBased]
								[T -> createFileChooser(String-String) : MethodDecl "private JFileChooser createFileChooser(String... fileFilters) {   JFileChooser fc = new JFileChooser();   for (String fileFilter : fileFilters) {    fc.addChoosableFileFilter(new FileChooserFileFilter(fileFilter));   }   fc.setFileSelectionMode(JFileChooser.FILES_ONLY);   fc.setMultiSelectionEnabled(false);   return fc;  }" compose:Replacement merge: LineBased]
								[NT -> FileChooserFileFilter : InnerClassDecl]
									[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FileChooserFileFilter : Id "FileChooserFileFilter" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends FileFilter" compose:Replacement merge: Default]
									[T -> objType : FieldDecl "String objType;" compose:Replacement merge: SemanticConflict]
									[T -> FileChooserFileFilter(String-String) : ConstructorDecl "public FileChooserFileFilter(String string) {    objType = string;   }" compose:Replacement merge: LineBased]
									[T -> accept(File-File) : MethodDecl "@Override   public boolean accept(File f) {    if (f.isDirectory())     return false;    return f.getName().toLowerCase().endsWith(objType.substring(1));   }" compose:Replacement merge: LineBased]
									[T -> getDescription({FormalParametersInternal}) : MethodDecl "@Override   public String getDescription() {    return objType;   }" compose:Replacement merge: LineBased]
								[T -> retrieveOpenDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void retrieveOpenDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileOpenCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveOpenDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void saveOpenDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileOpenCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> retrieveSaveDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void retrieveSaveDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileSaveCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveSaveDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void saveSaveDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileSaveCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
					[NT -> DropListener.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.datatransfer.DataFlavor{ImportPackage} : ImportDeclaration "import java.awt.datatransfer.DataFlavor;" compose:Replacement merge: Default]
							[T -> java.awt.datatransfer.Transferable{ImportPackage} : ImportDeclaration "import java.awt.datatransfer.Transferable;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DnDConstants{ImportPackage} : ImportDeclaration "import java.awt.dnd.DnDConstants;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetDragEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetDragEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetDropEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetDropEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetListener{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetListener;" compose:Replacement merge: Default]
							[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.Reader{ImportPackage} : ImportDeclaration "import java.io.Reader;" compose:Replacement merge: Default]
							[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: Default]
							[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
							[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
							[NT -> DropListener : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> DropListener : Id "DropListener" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements DropTargetListener" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> DropListener(MainWindow-MainWindow) : ConstructorDecl "public DropListener(MainWindow mainWindow) {   this.mainWindow = mainWindow;  }" compose:Replacement merge: LineBased]
								[T -> drop(DropTargetDropEvent-DropTargetDropEvent) : MethodDecl "@SuppressWarnings("unchecked")  @Override  public void drop(DropTargetDropEvent event) {   event.acceptDrop(DnDConstants.ACTION_COPY);   Transferable transferable = event.getTransferable();   if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    for (DataFlavor flavor : flavors) {     try {      if (flavor.isFlavorJavaFileListType()) {       List<File> files = (List<File>) transferable         .getTransferData(flavor);       if (files.size() > 1) {        event.rejectDrop();        return;       }       if (files.size() == 1) {        mainWindow.onFileDropped(files.get(0));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }    event.dropComplete(true);   } else {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    boolean handled = false;    for (int zz = 0; zz < flavors.length; zz++) {     if (flavors[zz].isRepresentationClassReader()) {      try {       Reader reader = flavors[zz].getReaderForText(transferable);       BufferedReader br = new BufferedReader(reader);       List<File> list = new ArrayList<File>();       String line = null;       while ((line = br.readLine()) != null) {        try {         if (new String("" + (char) 0).equals(line))          continue;         File file = new File(new URI(line));         list.add(file);        } catch (Exception ex) {         ex.printStackTrace();        }       }       if (list.size() > 1) {        event.rejectDrop();        return;       }       if (list.size() == 1) {        mainWindow.onFileDropped(list.get(0));       }       event.getDropTargetContext().dropComplete(true);       handled = true;      } catch (Exception e) {       e.printStackTrace();      }      break;     }    }    if (!handled) {     event.rejectDrop();    }   }   }" compose:Replacement merge: LineBased]
								[T -> dragEnter(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dragEnter(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dragExit(DropTargetEvent-DropTargetEvent) : MethodDecl "@Override  public void dragExit(DropTargetEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dragOver(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dragOver(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dropActionChanged(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dropActionChanged(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
					[NT -> FileEntryNotFoundException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> FileEntryNotFoundException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileEntryNotFoundException : Id "FileEntryNotFoundException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
					[NT -> FileIsBinaryException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> FileIsBinaryException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileIsBinaryException : Id "FileIsBinaryException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
					[NT -> JarEntryFilter.java : Java-File]
					[NT -> Closer.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> Closer : ClassDeclaration]
								[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Closer : Id "Closer" compose:Replacement merge: Default]
								[T -> tryClose(AutoCloseable-AutoCloseable) : MethodDecl "public static void tryClose(final AutoCloseable c) {         if (c == null) {             return;         }         try {             c.close();         }         catch (Throwable ignored) {         }     }" compose:Replacement merge: LineBased]
								[T -> tryClose(AutoCloseable-AutoCloseable) : MethodDecl "public static void tryClose(final AutoCloseable... items) {         if (items == null) {             return;         }         for (AutoCloseable c : items) {             tryClose(c);         }     }" compose:Replacement merge: LineBased]
					[NT -> Model.java : Java-File]
					[NT -> ConfigSaver.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.lang.reflect.Field{ImportPackage} : ImportDeclaration "import java.lang.reflect.Field;" compose:Replacement merge: Default]
							[T -> java.lang.reflect.Modifier{ImportPackage} : ImportDeclaration "import java.lang.reflect.Modifier;" compose:Replacement merge: Default]
							[T -> java.util.prefs.Preferences{ImportPackage} : ImportDeclaration "import java.util.prefs.Preferences;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Language{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Language;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Languages{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Languages;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.java.JavaFormattingOptions{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.java.JavaFormattingOptions;" compose:Replacement merge: Default]
							[NT -> ConfigSaver : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> ConfigSaver : Id "ConfigSaver" compose:Replacement merge: Default]
								[T -> FLATTEN_SWITCH_BLOCKS_ID : FieldDecl "private static final String FLATTEN_SWITCH_BLOCKS_ID = "flattenSwitchBlocks";" compose:Replacement merge: SemanticConflict]
								[T -> FORCE_EXPLICIT_IMPORTS_ID : FieldDecl "private static final String FORCE_EXPLICIT_IMPORTS_ID = "forceExplicitImports";" compose:Replacement merge: SemanticConflict]
								[T -> SHOW_SYNTHETIC_MEMBERS_ID : FieldDecl "private static final String SHOW_SYNTHETIC_MEMBERS_ID = "showSyntheticMembers";" compose:Replacement merge: SemanticConflict]
								[T -> EXCLUDE_NESTED_TYPES_ID : FieldDecl "private static final String EXCLUDE_NESTED_TYPES_ID = "excludeNestedTypes";" compose:Replacement merge: SemanticConflict]
								[T -> FORCE_EXPLICIT_TYPE_ARGUMENTS_ID : FieldDecl "private static final String FORCE_EXPLICIT_TYPE_ARGUMENTS_ID = "forceExplicitTypeArguments";" compose:Replacement merge: SemanticConflict]
								[T -> RETAIN_REDUNDANT_CASTS_ID : FieldDecl "private static final String RETAIN_REDUNDANT_CASTS_ID = "retainRedundantCasts";" compose:Replacement merge: SemanticConflict]
								[T -> INCLUDE_ERROR_DIAGNOSTICS_ID : FieldDecl "private static final String INCLUDE_ERROR_DIAGNOSTICS_ID = "includeErrorDiagnostics";" compose:Replacement merge: SemanticConflict]
								[T -> LANGUAGE_NAME_ID : FieldDecl "private static final String LANGUAGE_NAME_ID = "languageName";" compose:Replacement merge: SemanticConflict]
								[T -> MAIN_WINDOW_ID_PREFIX : FieldDecl "private static final String MAIN_WINDOW_ID_PREFIX = "main";" compose:Replacement merge: SemanticConflict]
								[T -> FIND_WINDOW_ID_PREFIX : FieldDecl "private static final String FIND_WINDOW_ID_PREFIX = "find";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_IS_FULL_SCREEN_ID : FieldDecl "private static final String WINDOW_IS_FULL_SCREEN_ID = "WindowIsFullScreen";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_WIDTH_ID : FieldDecl "private static final String WINDOW_WIDTH_ID = "WindowWidth";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_HEIGHT_ID : FieldDecl "private static final String WINDOW_HEIGHT_ID = "WindowHeight";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_X_ID : FieldDecl "private static final String WINDOW_X_ID = "WindowX";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_Y_ID : FieldDecl "private static final String WINDOW_Y_ID = "WindowY";" compose:Replacement merge: SemanticConflict]
								[T -> decompilerSettings : FieldDecl "private DecompilerSettings decompilerSettings;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindowPosition : FieldDecl "private WindowPosition mainWindowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> findWindowPosition : FieldDecl "private WindowPosition findWindowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPreferences : FieldDecl "private LuytenPreferences luytenPreferences;" compose:Replacement merge: SemanticConflict]
								[T -> theLoadedInstance : FieldDecl "private static ConfigSaver theLoadedInstance;" compose:Replacement merge: SemanticConflict]
								[T -> ConfigSaver({FormalParametersInternal}) : ConstructorDecl "private ConfigSaver() {}" compose:Replacement merge: LineBased]
								[T -> getLoadedInstance({FormalParametersInternal}) : MethodDecl "public static ConfigSaver getLoadedInstance() {   if (theLoadedInstance == null) {    synchronized (ConfigSaver.class) {     if (theLoadedInstance == null) {      theLoadedInstance = new ConfigSaver();      theLoadedInstance.loadConfig();     }    }   }   return theLoadedInstance;  }" compose:Replacement merge: LineBased]
								[T -> loadConfig({FormalParametersInternal}) : MethodDecl "private void loadConfig() {   decompilerSettings = new DecompilerSettings();   if (decompilerSettings.getFormattingOptions() == null) {    decompilerSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   luytenPreferences = new LuytenPreferences();   mainWindowPosition = new WindowPosition();   findWindowPosition = new WindowPosition();   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     decompilerSettings.setFlattenSwitchBlocks(prefs.getBoolean(FLATTEN_SWITCH_BLOCKS_ID,      decompilerSettings.getFlattenSwitchBlocks()));    decompilerSettings.setForceExplicitImports(prefs.getBoolean(FORCE_EXPLICIT_IMPORTS_ID,      decompilerSettings.getForceExplicitImports()));    decompilerSettings.setShowSyntheticMembers(prefs.getBoolean(SHOW_SYNTHETIC_MEMBERS_ID,      decompilerSettings.getShowSyntheticMembers()));    decompilerSettings.setExcludeNestedTypes(prefs.getBoolean(EXCLUDE_NESTED_TYPES_ID,      decompilerSettings.getExcludeNestedTypes()));    decompilerSettings.setForceExplicitTypeArguments(prefs.getBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID,      decompilerSettings.getForceExplicitTypeArguments()));    decompilerSettings.setRetainRedundantCasts(prefs.getBoolean(RETAIN_REDUNDANT_CASTS_ID,      decompilerSettings.getRetainRedundantCasts()));    decompilerSettings.setIncludeErrorDiagnostics(prefs.getBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID,      decompilerSettings.getIncludeErrorDiagnostics()));    decompilerSettings.setLanguage(findLanguageByName(prefs.get(LANGUAGE_NAME_ID,      decompilerSettings.getLanguage().getName())));     mainWindowPosition = loadWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX);    findWindowPosition = loadWindowPosition(prefs, FIND_WINDOW_ID_PREFIX);    luytenPreferences = loadLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> loadWindowPosition(Preferences-Preferences-String-String) : MethodDecl "private WindowPosition loadWindowPosition(Preferences prefs, String windowIdPrefix) {   WindowPosition windowPosition = new WindowPosition();   windowPosition.setFullScreen(prefs.getBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, false));   windowPosition.setWindowWidth(prefs.getInt(windowIdPrefix + WINDOW_WIDTH_ID, 0));   windowPosition.setWindowHeight(prefs.getInt(windowIdPrefix + WINDOW_HEIGHT_ID, 0));   windowPosition.setWindowX(prefs.getInt(windowIdPrefix + WINDOW_X_ID, 0));   windowPosition.setWindowY(prefs.getInt(windowIdPrefix + WINDOW_Y_ID, 0));   return windowPosition;  }" compose:Replacement merge: LineBased]
								[T -> loadLuytenPreferences(Preferences-Preferences) : MethodDecl "private LuytenPreferences loadLuytenPreferences(Preferences prefs) throws Exception {   LuytenPreferences newLuytenPrefs = new LuytenPreferences();   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object defaultVal = field.get(newLuytenPrefs);     if (field.getType() == String.class) {     String defaultStr = (String) (defaultVal == null ? "" : defaultVal);     field.set(newLuytenPrefs, prefs.get(prefId, defaultStr));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     Boolean defaultBool = (Boolean) (defaultVal == null ? new Boolean(false) : defaultVal);     field.setBoolean(newLuytenPrefs, prefs.getBoolean(prefId, defaultBool));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     Integer defaultInt = (Integer) (defaultVal == null ? new Integer(0) : defaultVal);     field.setInt(newLuytenPrefs, prefs.getInt(prefId, defaultInt));    }   }   return newLuytenPrefs;  }" compose:Replacement merge: LineBased]
								[T -> saveConfig({FormalParametersInternal}) : MethodDecl "public void saveConfig() {   // Registry path on Windows Xp:   // HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\modcrafting\luyten   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     prefs.putBoolean(FLATTEN_SWITCH_BLOCKS_ID, decompilerSettings.getFlattenSwitchBlocks());    prefs.putBoolean(FORCE_EXPLICIT_IMPORTS_ID, decompilerSettings.getForceExplicitImports());    prefs.putBoolean(SHOW_SYNTHETIC_MEMBERS_ID, decompilerSettings.getShowSyntheticMembers());    prefs.putBoolean(EXCLUDE_NESTED_TYPES_ID, decompilerSettings.getExcludeNestedTypes());    prefs.putBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID, decompilerSettings.getForceExplicitTypeArguments());    prefs.putBoolean(RETAIN_REDUNDANT_CASTS_ID, decompilerSettings.getRetainRedundantCasts());    prefs.putBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID, decompilerSettings.getIncludeErrorDiagnostics());    prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     saveWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX, mainWindowPosition);    saveWindowPosition(prefs, FIND_WINDOW_ID_PREFIX, findWindowPosition);    saveLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveWindowPosition(Preferences-Preferences-String-String-WindowPosition-WindowPosition) : MethodDecl "private void saveWindowPosition(Preferences prefs, String windowIdPrefix, WindowPosition windowPosition) {   prefs.putBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, windowPosition.isFullScreen());   prefs.putInt(windowIdPrefix + WINDOW_WIDTH_ID, windowPosition.getWindowWidth());   prefs.putInt(windowIdPrefix + WINDOW_HEIGHT_ID, windowPosition.getWindowHeight());   prefs.putInt(windowIdPrefix + WINDOW_X_ID, windowPosition.getWindowX());   prefs.putInt(windowIdPrefix + WINDOW_Y_ID, windowPosition.getWindowY());  }" compose:Replacement merge: LineBased]
								[T -> saveLuytenPreferences(Preferences-Preferences) : MethodDecl "private void saveLuytenPreferences(Preferences prefs) throws Exception {   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object value = field.get(luytenPreferences);     if (field.getType() == String.class) {     prefs.put(prefId, (String) (value == null ? "" : value));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     prefs.putBoolean(prefId, (Boolean) (value == null ? new Boolean(false) : value));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     prefs.putInt(prefId, (Integer) (value == null ? new Integer(0) : value));    }   }  }" compose:Replacement merge: LineBased]
								[T -> findLanguageByName(String-String) : MethodDecl "private Language findLanguageByName(String languageName) {   if (languageName != null) {     if (languageName.equals(Languages.java().getName())) {     return Languages.java();    } else if (languageName.equals(Languages.bytecode().getName())) {     return Languages.bytecode();    } else if (languageName.equals(Languages.bytecodeAst().getName())) {     return Languages.bytecodeAst();    }     for (Language language : Languages.debug()) {     if (languageName.equals(language.getName())) {      return language;     }    }   }   return Languages.java();  }" compose:Replacement merge: LineBased]
								[T -> getDecompilerSettings({FormalParametersInternal}) : MethodDecl "public DecompilerSettings getDecompilerSettings() {   return decompilerSettings;  }" compose:Replacement merge: LineBased]
								[T -> getMainWindowPosition({FormalParametersInternal}) : MethodDecl "public WindowPosition getMainWindowPosition() {   return mainWindowPosition;  }" compose:Replacement merge: LineBased]
								[T -> getFindWindowPosition({FormalParametersInternal}) : MethodDecl "public WindowPosition getFindWindowPosition() {   return findWindowPosition;  }" compose:Replacement merge: LineBased]
								[T -> getLuytenPreferences({FormalParametersInternal}) : MethodDecl "public LuytenPreferences getLuytenPreferences() {   return luytenPreferences;  }" compose:Replacement merge: LineBased]
					[NT -> Luyten.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> javax.swing.SwingUtilities{ImportPackage} : ImportDeclaration "import javax.swing.SwingUtilities;" compose:Replacement merge: Default]
							[T -> javax.swing.UIManager{ImportPackage} : ImportDeclaration "import javax.swing.UIManager;" compose:Replacement merge: Default]
							[NT -> Luyten : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Luyten : Id "Luyten" compose:Replacement merge: Default]
								[T -> main(String[]-String[]) : MethodDecl "public static void main(String[] args) {   try {    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());   } catch (Exception e) {    e.printStackTrace();   }    // for TotalCommander External Viewer setting:   // javaw -jar "c:\Program Files\Luyten\luyten.jar"   // (TC will not complain about temporary file when opening .class from .zip or .jar)   final File fileFromCommandLine = getFileFromCommandLine(args);    SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     MainWindow mainWindow = new MainWindow(fileFromCommandLine);     mainWindow.setVisible(true);    }   });  }" compose:Replacement merge: LineBased]
								[T -> getFileFromCommandLine(String[]-String[]) : MethodDecl "public static File getFileFromCommandLine(String[] args) {   File fileFromCommandLine = null;   try {    if (args.length > 0) {     String realFileName = new File(args[0]).getCanonicalPath();     fileFromCommandLine = new File(realFileName);    }   } catch (Exception e) {    e.printStackTrace();   }   return fileFromCommandLine;  }" compose:Replacement merge: LineBased]
					[NT -> TreeUtil.java : Java-File]
					[NT -> FindBox.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.Action{ImportPackage} : ImportDeclaration "import javax.swing.Action;" compose:Replacement merge: Default]
							[T -> javax.swing.BorderFactory{ImportPackage} : ImportDeclaration "import javax.swing.BorderFactory;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout.Alignment{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout.Alignment;" compose:Replacement merge: Default]
							[T -> javax.swing.JButton{ImportPackage} : ImportDeclaration "import javax.swing.JButton;" compose:Replacement merge: Default]
							[T -> javax.swing.JCheckBox{ImportPackage} : ImportDeclaration "import javax.swing.JCheckBox;" compose:Replacement merge: Default]
							[T -> javax.swing.JComponent{ImportPackage} : ImportDeclaration "import javax.swing.JComponent;" compose:Replacement merge: Default]
							[T -> javax.swing.JDialog{ImportPackage} : ImportDeclaration "import javax.swing.JDialog;" compose:Replacement merge: Default]
							[T -> javax.swing.JLabel{ImportPackage} : ImportDeclaration "import javax.swing.JLabel;" compose:Replacement merge: Default]
							[T -> javax.swing.JTextField{ImportPackage} : ImportDeclaration "import javax.swing.JTextField;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.SwingConstants{ImportPackage} : ImportDeclaration "import javax.swing.SwingConstants;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rsyntaxtextarea.RSyntaxTextArea{ImportPackage} : ImportDeclaration "import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rtextarea.SearchContext{ImportPackage} : ImportDeclaration "import org.fife.ui.rtextarea.SearchContext;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rtextarea.SearchEngine{ImportPackage} : ImportDeclaration "import org.fife.ui.rtextarea.SearchEngine;" compose:Replacement merge: Default]
							[NT -> FindBox : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FindBox : Id "FindBox" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JDialog" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -4125409760166690462L;" compose:Replacement merge: SemanticConflict]
								[T -> mcase : FieldDecl "private JCheckBox mcase;" compose:Replacement merge: SemanticConflict]
								[T -> regex : FieldDecl "private JCheckBox regex;" compose:Replacement merge: SemanticConflict]
								[T -> wholew : FieldDecl "private JCheckBox wholew;" compose:Replacement merge: SemanticConflict]
								[T -> reverse : FieldDecl "private JCheckBox reverse;" compose:Replacement merge: SemanticConflict]
								[T -> findButton : FieldDecl "private JButton findButton;" compose:Replacement merge: SemanticConflict]
								[T -> textField : FieldDecl "private JTextField textField;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> showFindBox({FormalParametersInternal}) : MethodDecl "public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();  }" compose:Replacement merge: LineBased]
								[T -> hideFindBox({FormalParametersInternal}) : MethodDecl "public void hideFindBox() {   this.setVisible(false);  }" compose:Replacement merge: LineBased]
								[T -> FindBox(MainWindow-MainWindow) : ConstructorDecl "public FindBox(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();    JLabel label = new JLabel("Find What:");   textField = new JTextField();    RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();   if (pane != null) {    textField.setText(pane.getSelectedText());   }   mcase = new JCheckBox("Match Case");   regex = new JCheckBox("Regex");   wholew = new JCheckBox("Whole Words");   reverse = new JCheckBox("Search Backwards");    findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    mcase.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   regex.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   wholew.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   reverse.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     Math.min((int) (screenSize.height * 0.20), 200));   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    layout.setHorizontalGroup(layout.createSequentialGroup()     .addComponent(label)     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(textField)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(mcase)           .addComponent(wholew))         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(regex)           .addComponent(reverse))))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(findButton))     );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(Alignment.BASELINE)       .addComponent(label)       .addComponent(textField)       .addComponent(findButton))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(mcase)           .addComponent(regex))         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(wholew)           .addComponent(reverse))))     );    this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();    this.setName("Find");   this.setTitle("Find");   this.setVisible(true);  }" compose:Replacement merge: LineBased]
								[NT -> FindButton : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FindButton : Id "FindButton" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 75954129199541874L;" compose:Replacement merge: SemanticConflict]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent event) {    if (textField.getText().length() == 0)     return;     RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();    if (pane == null)     return;     SearchContext context = new SearchContext();    context.setSearchFor(textField.getText());    context.setMatchCase(mcase.isSelected());    context.setRegularExpression(regex.isSelected());    context.setSearchForward(!reverse.isSelected());    context.setWholeWord(wholew.isSelected());     if (!SearchEngine.find(pane, context)) {     pane.setSelectionStart(0);     pane.setSelectionEnd(0);    }   }" compose:Replacement merge: LineBased]
								[T -> setHideOnEscapeButton({FormalParametersInternal}) : MethodDecl "private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(), windowPosition.getWindowY());   }  }" compose:Replacement merge: LineBased]
								[T -> setSaveWindowPositionOnClosing({FormalParametersInternal}) : MethodDecl "private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();     windowPosition.readPositionFromDialog(FindBox.this);    }   });  }" compose:Replacement merge: LineBased]
					[NT -> MainMenuBar.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionListener{ImportPackage} : ImportDeclaration "import java.awt.event.ActionListener;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
							[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
							[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractButton{ImportPackage} : ImportDeclaration "import javax.swing.AbstractButton;" compose:Replacement merge: Default]
							[T -> javax.swing.ButtonGroup{ImportPackage} : ImportDeclaration "import javax.swing.ButtonGroup;" compose:Replacement merge: Default]
							[T -> javax.swing.ButtonModel{ImportPackage} : ImportDeclaration "import javax.swing.ButtonModel;" compose:Replacement merge: Default]
							[T -> javax.swing.JCheckBox{ImportPackage} : ImportDeclaration "import javax.swing.JCheckBox;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenu{ImportPackage} : ImportDeclaration "import javax.swing.JMenu;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenuBar{ImportPackage} : ImportDeclaration "import javax.swing.JMenuBar;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenuItem{ImportPackage} : ImportDeclaration "import javax.swing.JMenuItem;" compose:Replacement merge: Default]
							[T -> javax.swing.JOptionPane{ImportPackage} : ImportDeclaration "import javax.swing.JOptionPane;" compose:Replacement merge: Default]
							[T -> javax.swing.JRadioButtonMenuItem{ImportPackage} : ImportDeclaration "import javax.swing.JRadioButtonMenuItem;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.text.DefaultEditorKit{ImportPackage} : ImportDeclaration "import javax.swing.text.DefaultEditorKit;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Language{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Language;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Languages{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Languages;" compose:Replacement merge: Default]
							[NT -> MainMenuBar : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> MainMenuBar : Id "MainMenuBar" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JMenuBar" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private final MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> languageLookup : FieldDecl "private final Map<String, Language> languageLookup = new HashMap<String, Language>();" compose:Replacement merge: SemanticConflict]
								[T -> flattenSwitchBlocks : FieldDecl "private JCheckBox flattenSwitchBlocks;" compose:Replacement merge: SemanticConflict]
								[T -> forceExplicitImports : FieldDecl "private JCheckBox forceExplicitImports;" compose:Replacement merge: SemanticConflict]
								[T -> forceExplicitTypes : FieldDecl "private JCheckBox forceExplicitTypes;" compose:Replacement merge: SemanticConflict]
								[T -> showSyntheticMembers : FieldDecl "private JCheckBox showSyntheticMembers;" compose:Replacement merge: SemanticConflict]
								[T -> excludeNestedTypes : FieldDecl "private JCheckBox excludeNestedTypes;" compose:Replacement merge: SemanticConflict]
								[T -> retainRedundantCasts : FieldDecl "private JCheckBox retainRedundantCasts;" compose:Replacement merge: SemanticConflict]
								[T -> showDebugInfo : FieldDecl "private JCheckBox showDebugInfo;" compose:Replacement merge: SemanticConflict]
								[T -> java : FieldDecl "private JRadioButtonMenuItem java;" compose:Replacement merge: SemanticConflict]
								[T -> bytecode : FieldDecl "private JRadioButtonMenuItem bytecode;" compose:Replacement merge: SemanticConflict]
								[T -> bytecodeAST : FieldDecl "private JRadioButtonMenuItem bytecodeAST;" compose:Replacement merge: SemanticConflict]
								[T -> languagesGroup : FieldDecl "private ButtonGroup languagesGroup;" compose:Replacement merge: SemanticConflict]
								[T -> themesGroup : FieldDecl "private ButtonGroup themesGroup;" compose:Replacement merge: SemanticConflict]
								[T -> packageExplorerStyle : FieldDecl "private JCheckBox packageExplorerStyle;" compose:Replacement merge: SemanticConflict]
								[T -> filterOutInnerClassEntries : FieldDecl "private JCheckBox filterOutInnerClassEntries;" compose:Replacement merge: SemanticConflict]
								[T -> singleClickOpenEnabled : FieldDecl "private JCheckBox singleClickOpenEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> exitByEscEnabled : FieldDecl "private JCheckBox exitByEscEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> settings : FieldDecl "private DecompilerSettings settings;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> MainMenuBar(MainWindow-MainWindow) : ConstructorDecl "public MainMenuBar(MainWindow mainWnd) {   this.mainWindow = mainWnd;   ConfigSaver configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    final JMenu fileMenu = new JMenu("File");   fileMenu.add(new JMenuItem("..."));   this.add(fileMenu);   final JMenu editMenu = new JMenu("Edit");   editMenu.add(new JMenuItem("..."));   this.add(editMenu);   final JMenu themesMenu = new JMenu("Themes");   themesMenu.add(new JMenuItem("..."));   this.add(themesMenu);   final JMenu operationMenu = new JMenu("Operation");   operationMenu.add(new JMenuItem("..."));   this.add(operationMenu);   final JMenu settingsMenu = new JMenu("Settings");   settingsMenu.add(new JMenuItem("..."));   this.add(settingsMenu);   final JMenu helpMenu = new JMenu("Help");   helpMenu.add(new JMenuItem("..."));   this.add(helpMenu);    // start quicker   new Thread() {    public void run() {     try {      // build menu later      buildFileMenu(fileMenu);      refreshMenuPopup(fileMenu);       buildEditMenu(editMenu);      refreshMenuPopup(editMenu);       buildThemesMenu(themesMenu);      refreshMenuPopup(themesMenu);       buildOperationMenu(operationMenu);      refreshMenuPopup(operationMenu);       buildSettingsMenu(settingsMenu);      refreshMenuPopup(settingsMenu);       buildHelpMenu(helpMenu);      refreshMenuPopup(helpMenu);     } catch (Exception e) {      e.printStackTrace();     }    }     // refresh currently opened menu     // (if user selected a menu before it was ready)    private void refreshMenuPopup(JMenu menu) {     try {      if (menu.isPopupMenuVisible()) {       menu.getPopupMenu().setVisible(false);       menu.getPopupMenu().setVisible(true);      }     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }" compose:Replacement merge: LineBased]
								[T -> buildFileMenu(JMenu-JMenu) : MethodDecl "private void buildFileMenu(final JMenu fileMenu) {   fileMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Open File...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onOpenFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Close");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onCloseFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Save As...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAsMenu();    }   });   fileMenu.add(menuItem);    menuItem = new JMenuItem("Save All...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAllMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Recent Files");   menuItem.setEnabled(false);   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Exit");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onExitMenu();    }   });   fileMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> buildEditMenu(JMenu-JMenu) : MethodDecl "private void buildEditMenu(JMenu editMenu) {   editMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Cut");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    menuItem = new JMenuItem("Copy");   menuItem.addActionListener(new DefaultEditorKit.CopyAction());   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));   editMenu.add(menuItem);    menuItem = new JMenuItem("Paste");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    editMenu.addSeparator();    menuItem = new JMenuItem("Select All");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSelectAllMenu();    }   });   editMenu.add(menuItem);   editMenu.addSeparator();    menuItem = new JMenuItem("Find...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onFindMenu();    }   });   editMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> buildThemesMenu(JMenu-JMenu) : MethodDecl "private void buildThemesMenu(JMenu themesMenu) {   themesMenu.removeAll();   themesGroup = new ButtonGroup();   JRadioButtonMenuItem a = new JRadioButtonMenuItem(new ThemeAction("Default", "default.xml"));   a.setSelected("default.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Dark", "dark.xml"));   a.setSelected("dark.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Eclipse", "eclipse.xml"));   a.setSelected("eclipse.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Visual Studio", "vs.xml"));   a.setSelected("vs.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);  }" compose:Replacement merge: LineBased]
								[T -> buildOperationMenu(JMenu-JMenu) : MethodDecl "private void buildOperationMenu(JMenu operationMenu) {   operationMenu.removeAll();   packageExplorerStyle = new JCheckBox("Package Explorer Style");   packageExplorerStyle.setSelected(luytenPrefs.isPackageExplorerStyle());   packageExplorerStyle.setContentAreaFilled(false);   packageExplorerStyle.setFocusable(false);   packageExplorerStyle.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setPackageExplorerStyle(packageExplorerStyle.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(packageExplorerStyle);      filterOutInnerClassEntries = new JCheckBox("Filter Out Inner Class Entries");   filterOutInnerClassEntries.setSelected(luytenPrefs.isFilterOutInnerClassEntries());   filterOutInnerClassEntries.setContentAreaFilled(false);   filterOutInnerClassEntries.setFocusable(false);   filterOutInnerClassEntries.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setFilterOutInnerClassEntries(filterOutInnerClassEntries.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(filterOutInnerClassEntries);    singleClickOpenEnabled = new JCheckBox("Single Click Open");   singleClickOpenEnabled.setSelected(luytenPrefs.isSingleClickOpenEnabled());   singleClickOpenEnabled.setContentAreaFilled(false);   singleClickOpenEnabled.setFocusable(false);   singleClickOpenEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setSingleClickOpenEnabled(singleClickOpenEnabled.isSelected());    }   });   operationMenu.add(singleClickOpenEnabled);    exitByEscEnabled = new JCheckBox("Exit By Esc");   exitByEscEnabled.setSelected(luytenPrefs.isExitByEscEnabled());   exitByEscEnabled.setContentAreaFilled(false);   exitByEscEnabled.setFocusable(false);   exitByEscEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setExitByEscEnabled(exitByEscEnabled.isSelected());    }   });   operationMenu.add(exitByEscEnabled);  }" compose:Replacement merge: LineBased]
								[T -> buildSettingsMenu(JMenu-JMenu) : MethodDecl "private void buildSettingsMenu(JMenu settingsMenu) {   settingsMenu.removeAll();   ActionListener settingsChanged = new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     new Thread() {      @Override      public void run() {       populateSettingsFromSettingsMenu();       mainWindow.onSettingsChanged();      }     }.start();    }   };   flattenSwitchBlocks = new JCheckBox("Flatten Switch Blocks");   flattenSwitchBlocks.setSelected(settings.getFlattenSwitchBlocks());   flattenSwitchBlocks.setContentAreaFilled(false);   flattenSwitchBlocks.setFocusable(false);   flattenSwitchBlocks.addActionListener(settingsChanged);   settingsMenu.add(flattenSwitchBlocks);    forceExplicitImports = new JCheckBox("Force Explicit Imports");   forceExplicitImports.setSelected(settings.getForceExplicitImports());   forceExplicitImports.setContentAreaFilled(false);   forceExplicitImports.setFocusable(false);   forceExplicitImports.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitImports);    forceExplicitTypes = new JCheckBox("Force Explicit Types");   forceExplicitTypes.setSelected(settings.getForceExplicitTypeArguments());   forceExplicitTypes.setContentAreaFilled(false);   forceExplicitTypes.setFocusable(false);   forceExplicitTypes.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitTypes);    showSyntheticMembers = new JCheckBox("Show Synthetic Members");   showSyntheticMembers.setSelected(settings.getShowSyntheticMembers());   showSyntheticMembers.setContentAreaFilled(false);   showSyntheticMembers.setFocusable(false);   showSyntheticMembers.addActionListener(settingsChanged);   settingsMenu.add(showSyntheticMembers);    excludeNestedTypes = new JCheckBox("Exclude Nested Types");   excludeNestedTypes.setSelected(settings.getExcludeNestedTypes());   excludeNestedTypes.setContentAreaFilled(false);   excludeNestedTypes.setFocusable(false);   excludeNestedTypes.addActionListener(settingsChanged);   settingsMenu.add(excludeNestedTypes);    retainRedundantCasts = new JCheckBox("Retain Redundant Casts");   retainRedundantCasts.setSelected(settings.getRetainRedundantCasts());   retainRedundantCasts.setContentAreaFilled(false);   retainRedundantCasts.setFocusable(false);   retainRedundantCasts.addActionListener(settingsChanged);   settingsMenu.add(retainRedundantCasts);    JMenu debugSettingsMenu = new JMenu("Debug Settings");   showDebugInfo = new JCheckBox("Include Error Diagnostics");   showDebugInfo.setSelected(settings.getIncludeErrorDiagnostics());   showDebugInfo.setContentAreaFilled(false);   showDebugInfo.setFocusable(false);   showDebugInfo.addActionListener(settingsChanged);    debugSettingsMenu.add(showDebugInfo);   settingsMenu.add(debugSettingsMenu);   settingsMenu.addSeparator();    languageLookup.put(Languages.java().getName(), Languages.java());   languageLookup.put(Languages.bytecode().getName(), Languages.bytecode());   languageLookup.put(Languages.bytecodeAst().getName(), Languages.bytecodeAst());    languagesGroup = new ButtonGroup();   java = new JRadioButtonMenuItem(Languages.java().getName());   java.getModel().setActionCommand(Languages.java().getName());   java.setSelected(Languages.java().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(java);   settingsMenu.add(java);   bytecode = new JRadioButtonMenuItem(Languages.bytecode().getName());   bytecode.getModel().setActionCommand(Languages.bytecode().getName());   bytecode.setSelected(Languages.bytecode().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecode);   settingsMenu.add(bytecode);   bytecodeAST = new JRadioButtonMenuItem(Languages.bytecodeAst().getName());   bytecodeAST.getModel().setActionCommand(Languages.bytecodeAst().getName());   bytecodeAST.setSelected(Languages.bytecodeAst().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecodeAST);   settingsMenu.add(bytecodeAST);    JMenu debugLanguagesMenu = new JMenu("Debug Languages");   for (final Language language : Languages.debug()) {    final JRadioButtonMenuItem m = new JRadioButtonMenuItem(language.getName());    m.getModel().setActionCommand(language.getName());    m.setSelected(language.getName().equals(settings.getLanguage().getName()));    languagesGroup.add(m);    debugLanguagesMenu.add(m);    languageLookup.put(language.getName(), language);   }   for (AbstractButton button : Collections.list(languagesGroup.getElements())) {    button.addActionListener(settingsChanged);   }   settingsMenu.add(debugLanguagesMenu);  }" compose:Replacement merge: LineBased]
								[T -> buildHelpMenu(JMenu-JMenu) : MethodDecl "private void buildHelpMenu(JMenu helpMenu) {   helpMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Legal");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onLegalMenu();    }   });   helpMenu.add(menuItem);   menuItem = new JMenuItem("About");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent event) {     JOptionPane.showMessageDialog(null,       "Luyten Gui \n" +         "by Deathmarine\n\n" +         "Powered By\nProcyon\n" +         "(c) 2013 Mike Strobel\n\n" +         "RSyntaxTextArea\n" +         "(c) 2012 Robert Futrell\n" +         "All rights reserved.");    }   });   helpMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> populateSettingsFromSettingsMenu({FormalParametersInternal}) : MethodDecl "private void populateSettingsFromSettingsMenu() {   // synchronized: do not disturb decompiler at work (synchronize every time before run decompiler)   synchronized (settings) {    settings.setFlattenSwitchBlocks(flattenSwitchBlocks.isSelected());    settings.setForceExplicitImports(forceExplicitImports.isSelected());    settings.setShowSyntheticMembers(showSyntheticMembers.isSelected());    settings.setExcludeNestedTypes(excludeNestedTypes.isSelected());    settings.setForceExplicitTypeArguments(forceExplicitTypes.isSelected());    settings.setRetainRedundantCasts(retainRedundantCasts.isSelected());    settings.setIncludeErrorDiagnostics(showDebugInfo.isSelected());    //    // Note: You shouldn't ever need to set this.  It's only for languages that support catch    //       blocks without an exception variable.  Java doesn't allow this.  I think Scala does.    //    // settings.setAlwaysGenerateExceptionVariableForCatchBlocks(true);    //     final ButtonModel selectedLanguage = languagesGroup.getSelection();    if (selectedLanguage != null) {     final Language language = languageLookup.get(selectedLanguage.getActionCommand());      if (language != null)      settings.setLanguage(language);    }     if (java.isSelected()) {     settings.setLanguage(Languages.java());    } else if (bytecode.isSelected()) {     settings.setLanguage(Languages.bytecode());    } else if (bytecodeAST.isSelected()) {     settings.setLanguage(Languages.bytecodeAst());    }   }  }" compose:Replacement merge: LineBased]
								[NT -> ThemeAction : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> ThemeAction : Id "ThemeAction" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -6618680171943723199L;" compose:Replacement merge: SemanticConflict]
									[T -> xml : FieldDecl "private String xml;" compose:Replacement merge: SemanticConflict]
									[T -> ThemeAction(String-String-String-String) : ConstructorDecl "public ThemeAction(String name, String xml) {    putValue(NAME, name);    this.xml = xml;   }" compose:Replacement merge: LineBased]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent e) {    luytenPrefs.setThemeXml(xml);    mainWindow.onThemesChanged();   }" compose:Replacement merge: LineBased]
					[NT -> TooLargeFileException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.text.DecimalFormat{ImportPackage} : ImportDeclaration "import java.text.DecimalFormat;" compose:Replacement merge: Default]
							[NT -> TooLargeFileException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> TooLargeFileException : Id "TooLargeFileException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> size : FieldDecl "private long size;" compose:Replacement merge: SemanticConflict]
								[T -> TooLargeFileException(long-long) : ConstructorDecl "public TooLargeFileException(long size) {   this.size = size;  }" compose:Replacement merge: LineBased]
								[T -> getReadableFileSize({FormalParametersInternal}) : MethodDecl "public String getReadableFileSize() {   if (size <= 0)    return "0";   final String[] units = new String[] {"B", "KB", "MB", "GB", "TB"};   int digitGroups = (int) (Math.log10(size) / Math.log10(1024));   return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];  }" compose:Replacement merge: LineBased]
					[NT -> FileSaver.java : Java-File]
					[NT -> CellRenderer.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> javax.swing.Icon{ImportPackage} : ImportDeclaration "import javax.swing.Icon;" compose:Replacement merge: Default]
							[T -> javax.swing.ImageIcon{ImportPackage} : ImportDeclaration "import javax.swing.ImageIcon;" compose:Replacement merge: Default]
							[T -> javax.swing.JTree{ImportPackage} : ImportDeclaration "import javax.swing.JTree;" compose:Replacement merge: Default]
							[T -> javax.swing.tree.DefaultMutableTreeNode{ImportPackage} : ImportDeclaration "import javax.swing.tree.DefaultMutableTreeNode;" compose:Replacement merge: Default]
							[T -> javax.swing.tree.DefaultTreeCellRenderer{ImportPackage} : ImportDeclaration "import javax.swing.tree.DefaultTreeCellRenderer;" compose:Replacement merge: Default]
							[NT -> CellRenderer : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> CellRenderer : Id "CellRenderer" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends DefaultTreeCellRenderer" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -5691181006363313993L;" compose:Replacement merge: SemanticConflict]
								[T -> pack : FieldDecl "Icon pack;" compose:Replacement merge: SemanticConflict]
								[T -> java_image : FieldDecl "Icon java_image;" compose:Replacement merge: SemanticConflict]
								[T -> file_image : FieldDecl "Icon file_image;" compose:Replacement merge: SemanticConflict]
								[T -> CellRenderer({FormalParametersInternal}) : ConstructorDecl "public CellRenderer(){   this.pack = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/package_obj.png")));   this.java_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/java.png")));   this.file_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/file.png")));  }" compose:Replacement merge: LineBased]
								[T -> getTreeCellRendererComponent(JTree-JTree-Object-Object-boolean-boolean-boolean-boolean-boolean-boolean-int-int-boolean-boolean) : MethodDecl "@Override  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);         DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;   if(node.getChildCount() > 0){    setIcon(this.pack);   }else if(getFileName(node).endsWith(".class") || getFileName(node).endsWith(".java")){    setIcon(this.java_image);   }else{    setIcon(this.file_image);   }      return this;  }" compose:Replacement merge: LineBased]
								[T -> getFileName(DefaultMutableTreeNode-DefaultMutableTreeNode) : MethodDecl "public String getFileName(DefaultMutableTreeNode node){         return ((TreeNodeUserObject) node.getUserObject()).getOriginalName();  }" compose:Replacement merge: LineBased]
					[NT -> TreeNodeUserObject.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> TreeNodeUserObject : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> TreeNodeUserObject : Id "TreeNodeUserObject" compose:Replacement merge: Default]
								[T -> originalName : FieldDecl "private String originalName;" compose:Replacement merge: SemanticConflict]
								[T -> displayName : FieldDecl "private String displayName;" compose:Replacement merge: SemanticConflict]
								[T -> TreeNodeUserObject(String-String) : ConstructorDecl "public TreeNodeUserObject(String name) {   this(name, name);  }" compose:Replacement merge: LineBased]
								[T -> TreeNodeUserObject(String-String-String-String) : ConstructorDecl "public TreeNodeUserObject(String originalName, String displayName) {   this.originalName = originalName;   this.displayName = displayName;  }" compose:Replacement merge: LineBased]
								[T -> getOriginalName({FormalParametersInternal}) : MethodDecl "public String getOriginalName() {   return originalName;  }" compose:Replacement merge: LineBased]
								[T -> setOriginalName(String-String) : MethodDecl "public void setOriginalName(String originalName) {   this.originalName = originalName;  }" compose:Replacement merge: LineBased]
								[T -> getDisplayName({FormalParametersInternal}) : MethodDecl "public String getDisplayName() {   return displayName;  }" compose:Replacement merge: LineBased]
								[T -> setDisplayName(String-String) : MethodDecl "public void setDisplayName(String displayName) {   this.displayName = displayName;  }" compose:Replacement merge: LineBased]
								[T -> toString({FormalParametersInternal}) : MethodDecl "@Override  public String toString() {   return displayName;  }" compose:Replacement merge: LineBased]
					[NT -> LuytenPreferences.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> LuytenPreferences : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> LuytenPreferences : Id "LuytenPreferences" compose:Replacement merge: Default]
								[T -> THEME_XML_PATH : FieldDecl "public static final String THEME_XML_PATH = "/themes/";" compose:Replacement merge: SemanticConflict]
								[T -> DEFAULT_THEME_XML : FieldDecl "public static final String DEFAULT_THEME_XML = "eclipse.xml";" compose:Replacement merge: SemanticConflict]
								[T -> themeXml : FieldDecl "private String themeXml = DEFAULT_THEME_XML;" compose:Replacement merge: SemanticConflict]
								[T -> fileOpenCurrentDirectory : FieldDecl "private String fileOpenCurrentDirectory = "";" compose:Replacement merge: SemanticConflict]
								[T -> fileSaveCurrentDirectory : FieldDecl "private String fileSaveCurrentDirectory = "";" compose:Replacement merge: SemanticConflict]
								[T -> isPackageExplorerStyle : FieldDecl "private boolean isPackageExplorerStyle = true;" compose:Replacement merge: SemanticConflict]
								[T -> isFilterOutInnerClassEntries : FieldDecl "private boolean isFilterOutInnerClassEntries = true;" compose:Replacement merge: SemanticConflict]
								[T -> isSingleClickOpenEnabled : FieldDecl "private boolean isSingleClickOpenEnabled = true;" compose:Replacement merge: SemanticConflict]
								[T -> isExitByEscEnabled : FieldDecl "private boolean isExitByEscEnabled = false;" compose:Replacement merge: SemanticConflict]
								[T -> getThemeXml({FormalParametersInternal}) : MethodDecl "public String getThemeXml() {   return themeXml;  }" compose:Replacement merge: LineBased]
								[T -> setThemeXml(String-String) : MethodDecl "public void setThemeXml(String themeXml) {   this.themeXml = themeXml;  }" compose:Replacement merge: LineBased]
								[T -> getFileOpenCurrentDirectory({FormalParametersInternal}) : MethodDecl "public String getFileOpenCurrentDirectory() {   return fileOpenCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> setFileOpenCurrentDirectory(String-String) : MethodDecl "public void setFileOpenCurrentDirectory(String fileOpenCurrentDirectory) {   this.fileOpenCurrentDirectory = fileOpenCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> getFileSaveCurrentDirectory({FormalParametersInternal}) : MethodDecl "public String getFileSaveCurrentDirectory() {   return fileSaveCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> setFileSaveCurrentDirectory(String-String) : MethodDecl "public void setFileSaveCurrentDirectory(String fileSaveCurrentDirectory) {   this.fileSaveCurrentDirectory = fileSaveCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> isPackageExplorerStyle({FormalParametersInternal}) : MethodDecl "public boolean isPackageExplorerStyle() {   return isPackageExplorerStyle;  }" compose:Replacement merge: LineBased]
								[T -> setPackageExplorerStyle(boolean-boolean) : MethodDecl "public void setPackageExplorerStyle(boolean isPackageExplorerStyle) {   this.isPackageExplorerStyle = isPackageExplorerStyle;  }" compose:Replacement merge: LineBased]
								[T -> isFilterOutInnerClassEntries({FormalParametersInternal}) : MethodDecl "public boolean isFilterOutInnerClassEntries() {   return isFilterOutInnerClassEntries;  }" compose:Replacement merge: LineBased]
								[T -> setFilterOutInnerClassEntries(boolean-boolean) : MethodDecl "public void setFilterOutInnerClassEntries(boolean isFilterOutInnerClassEntries) {   this.isFilterOutInnerClassEntries = isFilterOutInnerClassEntries;  }" compose:Replacement merge: LineBased]
								[T -> isSingleClickOpenEnabled({FormalParametersInternal}) : MethodDecl "public boolean isSingleClickOpenEnabled() {   return isSingleClickOpenEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setSingleClickOpenEnabled(boolean-boolean) : MethodDecl "public void setSingleClickOpenEnabled(boolean isSingleClickOpenEnabled) {   this.isSingleClickOpenEnabled = isSingleClickOpenEnabled;  }" compose:Replacement merge: LineBased]
								[T -> isExitByEscEnabled({FormalParametersInternal}) : MethodDecl "public boolean isExitByEscEnabled() {   return isExitByEscEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setExitByEscEnabled(boolean-boolean) : MethodDecl "public void setExitByEscEnabled(boolean isExitByEscEnabled) {   this.isExitByEscEnabled = isExitByEscEnabled;  }" compose:Replacement merge: LineBased]
					[NT -> OpenFile.java : Java-File]
					[NT -> WindowPosition.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> javax.swing.JDialog{ImportPackage} : ImportDeclaration "import javax.swing.JDialog;" compose:Replacement merge: Default]
							[T -> javax.swing.JFrame{ImportPackage} : ImportDeclaration "import javax.swing.JFrame;" compose:Replacement merge: Default]
							[NT -> WindowPosition : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> WindowPosition : Id "WindowPosition" compose:Replacement merge: Default]
								[T -> isFullScreen : FieldDecl "private boolean isFullScreen;" compose:Replacement merge: SemanticConflict]
								[T -> windowWidth : FieldDecl "private int windowWidth;" compose:Replacement merge: SemanticConflict]
								[T -> windowHeight : FieldDecl "private int windowHeight;" compose:Replacement merge: SemanticConflict]
								[T -> windowX : FieldDecl "private int windowX;" compose:Replacement merge: SemanticConflict]
								[T -> windowY : FieldDecl "private int windowY;" compose:Replacement merge: SemanticConflict]
								[T -> readPositionFromWindow(JFrame-JFrame) : MethodDecl "public void readPositionFromWindow(JFrame window) {   isFullScreen = (window.getExtendedState() == JFrame.MAXIMIZED_BOTH);   if (!isFullScreen) {    this.readPositionFromComponent(window);   }  }" compose:Replacement merge: LineBased]
								[T -> readPositionFromDialog(JDialog-JDialog) : MethodDecl "public void readPositionFromDialog(JDialog dialog) {   this.readPositionFromComponent(dialog);  }" compose:Replacement merge: LineBased]
								[T -> readPositionFromComponent(Component-Component) : MethodDecl "private void readPositionFromComponent(Component component) {   isFullScreen = false;   windowWidth = component.getWidth();   windowHeight = component.getHeight();   windowX = component.getX();   windowY = component.getY();  }" compose:Replacement merge: LineBased]
								[T -> isSavedWindowPositionValid({FormalParametersInternal}) : MethodDecl "public boolean isSavedWindowPositionValid() {   if (isFullScreen) {    return true;   }   if (windowWidth < 100 || windowHeight < 100) {    return false;   }   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (windowWidth > screenSize.width + 50 || windowHeight > screenSize.height + 50) {    return false;   }   if (windowY < -20 || windowY > screenSize.height - 50 ||     windowX < 50 - windowWidth || windowX > screenSize.width - 50) {    return false;   }   return true;  }" compose:Replacement merge: LineBased]
								[T -> isFullScreen({FormalParametersInternal}) : MethodDecl "public boolean isFullScreen() {   return isFullScreen;  }" compose:Replacement merge: LineBased]
								[T -> setFullScreen(boolean-boolean) : MethodDecl "public void setFullScreen(boolean isFullScreen) {   this.isFullScreen = isFullScreen;  }" compose:Replacement merge: LineBased]
								[T -> getWindowWidth({FormalParametersInternal}) : MethodDecl "public int getWindowWidth() {   return windowWidth;  }" compose:Replacement merge: LineBased]
								[T -> setWindowWidth(int-int) : MethodDecl "public void setWindowWidth(int windowWidth) {   this.windowWidth = windowWidth;  }" compose:Replacement merge: LineBased]
								[T -> getWindowHeight({FormalParametersInternal}) : MethodDecl "public int getWindowHeight() {   return windowHeight;  }" compose:Replacement merge: LineBased]
								[T -> setWindowHeight(int-int) : MethodDecl "public void setWindowHeight(int windowHeight) {   this.windowHeight = windowHeight;  }" compose:Replacement merge: LineBased]
								[T -> getWindowX({FormalParametersInternal}) : MethodDecl "public int getWindowX() {   return windowX;  }" compose:Replacement merge: LineBased]
								[T -> setWindowX(int-int) : MethodDecl "public void setWindowX(int windowX) {   this.windowX = windowX;  }" compose:Replacement merge: LineBased]
								[T -> getWindowY({FormalParametersInternal}) : MethodDecl "public int getWindowY() {   return windowY;  }" compose:Replacement merge: LineBased]
								[T -> setWindowY(int-int) : MethodDecl "public void setWindowY(int windowY) {   this.windowY = windowY;  }" compose:Replacement merge: LineBased]
					[NT -> MainWindow.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.BorderLayout{ImportPackage} : ImportDeclaration "import java.awt.BorderLayout;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTarget{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTarget;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ComponentAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.ComponentAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.ComponentEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ComponentEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
							[T -> java.io.InputStreamReader{ImportPackage} : ImportDeclaration "import java.io.InputStreamReader;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.Action{ImportPackage} : ImportDeclaration "import javax.swing.Action;" compose:Replacement merge: Default]
							[T -> javax.swing.BoxLayout{ImportPackage} : ImportDeclaration "import javax.swing.BoxLayout;" compose:Replacement merge: Default]
							[T -> javax.swing.JComponent{ImportPackage} : ImportDeclaration "import javax.swing.JComponent;" compose:Replacement merge: Default]
							[T -> javax.swing.JFrame{ImportPackage} : ImportDeclaration "import javax.swing.JFrame;" compose:Replacement merge: Default]
							[T -> javax.swing.JLabel{ImportPackage} : ImportDeclaration "import javax.swing.JLabel;" compose:Replacement merge: Default]
							[T -> javax.swing.JPanel{ImportPackage} : ImportDeclaration "import javax.swing.JPanel;" compose:Replacement merge: Default]
							[T -> javax.swing.JProgressBar{ImportPackage} : ImportDeclaration "import javax.swing.JProgressBar;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.border.BevelBorder{ImportPackage} : ImportDeclaration "import javax.swing.border.BevelBorder;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rsyntaxtextarea.RSyntaxTextArea{ImportPackage} : ImportDeclaration "import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;" compose:Replacement merge: Default]
							[NT -> MainWindow : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> MainWindow : Id "MainWindow" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JFrame" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> TITLE : FieldDecl "private static final String TITLE = "Luyten";" compose:Replacement merge: SemanticConflict]
								[T -> model : FieldDecl "private Model model;" compose:Replacement merge: SemanticConflict]
								[T -> bar : FieldDecl "private JProgressBar bar;" compose:Replacement merge: SemanticConflict]
								[T -> label : FieldDecl "private JLabel label;" compose:Replacement merge: SemanticConflict]
								[T -> findBox : FieldDecl "private FindBox findBox;" compose:Replacement merge: SemanticConflict]
								[T -> configSaver : FieldDecl "private ConfigSaver configSaver;" compose:Replacement merge: SemanticConflict]
								[T -> windowPosition : FieldDecl "private WindowPosition windowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> fileDialog : FieldDecl "private FileDialog fileDialog;" compose:Replacement merge: SemanticConflict]
								[T -> fileSaver : FieldDecl "private FileSaver fileSaver;" compose:Replacement merge: SemanticConflict]
								[T -> MainWindow(File-File) : ConstructorDecl "public MainWindow(File fileFromCommandLine) {   configSaver = ConfigSaver.getLoadedInstance();   windowPosition = configSaver.getMainWindowPosition();   luytenPrefs = configSaver.getLuytenPreferences();    MainMenuBar mainMenuBar = new MainMenuBar(this);   this.setJMenuBar(mainMenuBar);    this.adjustWindowPositionBySavedState();   this.setHideFindBoxOnMainWindowFocus();   this.setQuitOnWindowClosing();   this.setTitle(TITLE);    JPanel pane = new JPanel();   pane.setBorder(new BevelBorder(BevelBorder.LOWERED));   pane.setPreferredSize(new Dimension(this.getWidth(), 24));   pane.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));    JPanel panel1 = new JPanel();   label = new JLabel(" ");   label.setHorizontalAlignment(JLabel.LEFT);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setBorder(new BevelBorder(BevelBorder.LOWERED));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(label);   pane.add(panel1);    panel1 = new JPanel();   bar = new JProgressBar();   bar.setIndeterminate(true);   bar.setOpaque(false);   bar.setVisible(false);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(bar);   pane.add(panel1);    model = new Model(this);   this.getContentPane().add(model);   this.add(pane, BorderLayout.SOUTH);    if (fileFromCommandLine != null) {    model.loadFile(fileFromCommandLine);   }    try {    DropTarget dt = new DropTarget();    dt.addDropTargetListener(new DropListener(this));    this.setDropTarget(dt);   } catch (Exception e) {    e.printStackTrace();   }    fileDialog = new FileDialog(this);   fileSaver = new FileSaver(bar, label);    this.setExitOnEscWhenEnabled(model);    if (fileFromCommandLine == null || fileFromCommandLine.getName().toLowerCase().endsWith(".jar") ||     fileFromCommandLine.getName().toLowerCase().endsWith(".zip")) {    model.startWarmUpThread();   }  }" compose:Replacement merge: LineBased]
								[T -> onOpenFileMenu({FormalParametersInternal}) : MethodDecl "public void onOpenFileMenu() {   File selectedFile = fileDialog.doOpenDialog();   if (selectedFile != null) {    this.getModel().loadFile(selectedFile);   }  }" compose:Replacement merge: LineBased]
								[T -> onCloseFileMenu({FormalParametersInternal}) : MethodDecl "public void onCloseFileMenu() {   this.getModel().closeFile();  }" compose:Replacement merge: LineBased]
								[T -> onSaveAsMenu({FormalParametersInternal}) : MethodDecl "public void onSaveAsMenu() {   RSyntaxTextArea pane = this.getModel().getCurrentTextArea();   if (pane == null)    return;   String tabTitle = this.getModel().getCurrentTabTitle();   if (tabTitle == null)    return;    String recommendedFileName = tabTitle.replace(".class", ".java");   File selectedFile = fileDialog.doSaveDialog(recommendedFileName);   if (selectedFile != null) {    fileSaver.saveText(pane.getText(), selectedFile);   }  }" compose:Replacement merge: LineBased]
								[T -> onSaveAllMenu({FormalParametersInternal}) : MethodDecl "public void onSaveAllMenu() {   File openedFile = this.getModel().getOpenedFile();   if (openedFile == null)    return;    String fileName = openedFile.getName();   if (fileName.endsWith(".class")) {    fileName = fileName.replace(".class", ".java");   } else if (fileName.toLowerCase().endsWith(".jar")) {    fileName = "decompiled-" + fileName.replaceAll("\\.[jJ][aA][rR]", ".zip");   } else {    fileName = "saved-" + fileName;   }    File selectedFileToSave = fileDialog.doSaveAllDialog(fileName);   if (selectedFileToSave != null) {    fileSaver.saveAllDecompiled(openedFile, selectedFileToSave);   }  }" compose:Replacement merge: LineBased]
								[T -> onExitMenu({FormalParametersInternal}) : MethodDecl "public void onExitMenu() {   quit();  }" compose:Replacement merge: LineBased]
								[T -> onSelectAllMenu({FormalParametersInternal}) : MethodDecl "public void onSelectAllMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     pane.requestFocusInWindow();     pane.setSelectionStart(0);     pane.setSelectionEnd(pane.getText().length());    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onFindMenu({FormalParametersInternal}) : MethodDecl "public void onFindMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     if (findBox == null)      findBox = new FindBox(this);     findBox.showFindBox();    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onLegalMenu({FormalParametersInternal}) : MethodDecl "public void onLegalMenu() {   new Thread() {    public void run() {     try {      bar.setVisible(true);      String legalStr = getLegalStr();      MainWindow.this.getModel().showLegal(legalStr);     } finally {      bar.setVisible(false);     }    }   }.start();  }" compose:Replacement merge: LineBased]
								[T -> getLegalStr({FormalParametersInternal}) : MethodDecl "private String getLegalStr() {   StringBuilder sb = new StringBuilder();   try {    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/Procyon.License.txt")));    String line;    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");    sb.append("\n\n\n\n\n");    reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/RSyntaxTextArea.License.txt")));    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");   } catch (IOException e) {    e.printStackTrace();   }   return sb.toString();  }" compose:Replacement merge: LineBased]
								[T -> onThemesChanged({FormalParametersInternal}) : MethodDecl "public void onThemesChanged() {   this.getModel().changeTheme(luytenPrefs.getThemeXml());  }" compose:Replacement merge: LineBased]
								[T -> onSettingsChanged({FormalParametersInternal}) : MethodDecl "public void onSettingsChanged() {   this.getModel().updateOpenClasses();  }" compose:Replacement merge: LineBased]
								[T -> onTreeSettingsChanged({FormalParametersInternal}) : MethodDecl "public void onTreeSettingsChanged() {   this.getModel().updateTree();  }" compose:Replacement merge: LineBased]
								[T -> onFileDropped(File-File) : MethodDecl "public void onFileDropped(File file) {   if (file != null) {    this.getModel().loadFile(file);   }  }" compose:Replacement merge: LineBased]
								[T -> onFileLoadEnded(File-File-boolean-boolean) : MethodDecl "public void onFileLoadEnded(File file, boolean isSuccess) {   try {    if (file != null && isSuccess) {     this.setTitle(TITLE + " - " + file.getName());    } else {     this.setTitle(TITLE);    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (!windowPosition.isSavedWindowPositionValid()) {    final Dimension center = new Dimension((int) (screenSize.width * 0.75), (int) (screenSize.height * 0.75));    final int x = (int) (center.width * 0.2);    final int y = (int) (center.height * 0.2);    this.setBounds(x, y, center.width, center.height);    } else if (windowPosition.isFullScreen()) {    int heightMinusTray = screenSize.height;    if (screenSize.height > 30)     heightMinusTray -= 30;    this.setBounds(0, 0, screenSize.width, heightMinusTray);    this.setExtendedState(JFrame.MAXIMIZED_BOTH);     this.addComponentListener(new ComponentAdapter() {     @Override     public void componentResized(ComponentEvent e) {      if (MainWindow.this.getExtendedState() != JFrame.MAXIMIZED_BOTH) {       windowPosition.setFullScreen(false);       if (windowPosition.isSavedWindowPositionValid()) {        MainWindow.this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),          windowPosition.getWindowWidth(), windowPosition.getWindowHeight());       }       MainWindow.this.removeComponentListener(this);      }     }    });    } else {    this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),      windowPosition.getWindowWidth(), windowPosition.getWindowHeight());   }  }" compose:Replacement merge: LineBased]
								[T -> setHideFindBoxOnMainWindowFocus({FormalParametersInternal}) : MethodDecl "private void setHideFindBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findBox != null && findBox.isVisible()) {      findBox.setVisible(false);     }    }   });  }" compose:Replacement merge: LineBased]
								[T -> setQuitOnWindowClosing({FormalParametersInternal}) : MethodDecl "private void setQuitOnWindowClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowClosing(WindowEvent e) {     quit();    }   });  }" compose:Replacement merge: LineBased]
								[T -> quit({FormalParametersInternal}) : MethodDecl "private void quit() {   try {    windowPosition.readPositionFromWindow(this);    configSaver.saveConfig();   } catch (Exception exc) {    exc.printStackTrace();   } finally {    try {     this.dispose();    } finally {     System.exit(0);    }   }  }" compose:Replacement merge: LineBased]
								[T -> setExitOnEscWhenEnabled(JComponent-JComponent) : MethodDecl "private void setExitOnEscWhenEnabled(JComponent mainComponent) {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     if (luytenPrefs.isExitByEscEnabled()) {      quit();     }    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   mainComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(escapeKeyStroke, "ESCAPE");   mainComponent.getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> getModel({FormalParametersInternal}) : MethodDecl "public Model getModel() {   return model;  }" compose:Replacement merge: LineBased]
								[T -> getBar({FormalParametersInternal}) : MethodDecl "public JProgressBar getBar() {   return bar;  }" compose:Replacement merge: LineBased]
								[T -> getLabel({FormalParametersInternal}) : MethodDecl "public JLabel getLabel() {   return label;  }" compose:Replacement merge: LineBased]
					[NT -> LuytenTypeLoader.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.InputTypeLoader{ImportPackage} : ImportDeclaration "import com.strobel.assembler.InputTypeLoader;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.Buffer{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.Buffer;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.ITypeLoader{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.ITypeLoader;" compose:Replacement merge: Default]
							[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
							[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
							[NT -> LuytenTypeLoader : ClassDeclaration]
								[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> LuytenTypeLoader : Id "LuytenTypeLoader" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements ITypeLoader" compose:Replacement merge: SemanticConflict]
								[T -> _typeLoaders : FieldDecl "private final List<ITypeLoader> _typeLoaders;" compose:Replacement merge: SemanticConflict]
								[T -> LuytenTypeLoader({FormalParametersInternal}) : ConstructorDecl "public LuytenTypeLoader() {         _typeLoaders = new ArrayList<ITypeLoader>();         _typeLoaders.add(new InputTypeLoader());     }" compose:Replacement merge: LineBased]
								[T -> getTypeLoaders({FormalParametersInternal}) : MethodDecl "public final List<ITypeLoader> getTypeLoaders() {         return _typeLoaders;     }" compose:Replacement merge: LineBased]
								[T -> tryLoadType(String-String-Buffer-Buffer) : MethodDecl "@Override     public boolean tryLoadType(final String internalName, final Buffer buffer) {         for (final ITypeLoader typeLoader : _typeLoaders) {             if (typeLoader.tryLoadType(internalName, buffer)) {                 return true;             }              buffer.reset();         }          return false;     }" compose:Replacement merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> com : Folder]
			[NT -> modcrafting : Folder]
				[NT -> luyten : Folder]
					[NT -> FileDialog.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> javax.swing.JFileChooser{ImportPackage} : ImportDeclaration "import javax.swing.JFileChooser;" compose:Replacement merge: Default]
							[T -> javax.swing.filechooser.FileFilter{ImportPackage} : ImportDeclaration "import javax.swing.filechooser.FileFilter;" compose:Replacement merge: Default]
							[NT -> FileDialog : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileDialog : Id "FileDialog" compose:Replacement merge: Default]
								[T -> configSaver : FieldDecl "private ConfigSaver configSaver;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> parent : FieldDecl "private Component parent;" compose:Replacement merge: SemanticConflict]
								[T -> fcOpen : FieldDecl "private JFileChooser fcOpen;" compose:Replacement merge: SemanticConflict]
								[T -> fcSave : FieldDecl "private JFileChooser fcSave;" compose:Replacement merge: SemanticConflict]
								[T -> fcSaveAll : FieldDecl "private JFileChooser fcSaveAll;" compose:Replacement merge: SemanticConflict]
								[T -> FileDialog(Component-Component) : ConstructorDecl "public FileDialog(Component parent) {   this.parent = parent;   configSaver = ConfigSaver.getLoadedInstance();   luytenPrefs = configSaver.getLuytenPreferences();    new Thread() {    public void run() {     try {      initOpenDialog();      Thread.sleep(500);      initSaveAllDialog();      Thread.sleep(500);      initSaveDialog();     } catch (Exception e) {      e.printStackTrace();     }    };   }.start();  }" compose:Replacement merge: LineBased]
								[T -> doOpenDialog({FormalParametersInternal}) : MethodDecl "public File doOpenDialog() {   File selectedFile = null;   initOpenDialog();    retrieveOpenDialogDir(fcOpen);   int returnVal = fcOpen.showOpenDialog(parent);   saveOpenDialogDir(fcOpen);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcOpen.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> doSaveDialog(String-String) : MethodDecl "public File doSaveDialog(String recommendedFileName) {   File selectedFile = null;   initSaveDialog();    retrieveSaveDialogDir(fcSave);   fcSave.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSave.showSaveDialog(parent);   saveSaveDialogDir(fcSave);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSave.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> doSaveAllDialog(String-String) : MethodDecl "public File doSaveAllDialog(String recommendedFileName) {   File selectedFile = null;   initSaveAllDialog();    retrieveSaveDialogDir(fcSaveAll);   fcSaveAll.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSaveAll.showSaveDialog(parent);   saveSaveDialogDir(fcSaveAll);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSaveAll.getSelectedFile();   }   return selectedFile;  }" compose:Replacement merge: LineBased]
								[T -> initOpenDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initOpenDialog() {   if (fcOpen == null) {    fcOpen = createFileChooser("*.jar", "*.zip", "*.class");    retrieveOpenDialogDir(fcOpen);   }  }" compose:Replacement merge: LineBased]
								[T -> initSaveDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initSaveDialog() {   if (fcSave == null) {    fcSave = createFileChooser("*.txt", "*.java");    retrieveSaveDialogDir(fcSave);   }  }" compose:Replacement merge: LineBased]
								[T -> initSaveAllDialog({FormalParametersInternal}) : MethodDecl "public synchronized void initSaveAllDialog() {   if (fcSaveAll == null) {    fcSaveAll = createFileChooser("*.jar", "*.zip");    retrieveSaveDialogDir(fcSaveAll);   }  }" compose:Replacement merge: LineBased]
								[T -> createFileChooser(String-String) : MethodDecl "private JFileChooser createFileChooser(String... fileFilters) {   JFileChooser fc = new JFileChooser();   for (String fileFilter : fileFilters) {    fc.addChoosableFileFilter(new FileChooserFileFilter(fileFilter));   }   fc.setFileSelectionMode(JFileChooser.FILES_ONLY);   fc.setMultiSelectionEnabled(false);   return fc;  }" compose:Replacement merge: LineBased]
								[NT -> FileChooserFileFilter : InnerClassDecl]
									[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FileChooserFileFilter : Id "FileChooserFileFilter" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends FileFilter" compose:Replacement merge: Default]
									[T -> objType : FieldDecl "String objType;" compose:Replacement merge: SemanticConflict]
									[T -> FileChooserFileFilter(String-String) : ConstructorDecl "public FileChooserFileFilter(String string) {    objType = string;   }" compose:Replacement merge: LineBased]
									[T -> accept(File-File) : MethodDecl "@Override   public boolean accept(File f) {    if (f.isDirectory())     return false;    return f.getName().toLowerCase().endsWith(objType.substring(1));   }" compose:Replacement merge: LineBased]
									[T -> getDescription({FormalParametersInternal}) : MethodDecl "@Override   public String getDescription() {    return objType;   }" compose:Replacement merge: LineBased]
								[T -> retrieveOpenDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void retrieveOpenDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileOpenCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveOpenDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void saveOpenDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileOpenCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> retrieveSaveDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void retrieveSaveDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileSaveCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveSaveDialogDir(JFileChooser-JFileChooser) : MethodDecl "private void saveSaveDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileSaveCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }" compose:Replacement merge: LineBased]
					[NT -> DropListener.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.datatransfer.DataFlavor{ImportPackage} : ImportDeclaration "import java.awt.datatransfer.DataFlavor;" compose:Replacement merge: Default]
							[T -> java.awt.datatransfer.Transferable{ImportPackage} : ImportDeclaration "import java.awt.datatransfer.Transferable;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DnDConstants{ImportPackage} : ImportDeclaration "import java.awt.dnd.DnDConstants;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetDragEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetDragEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetDropEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetDropEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetEvent{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetEvent;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTargetListener{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTargetListener;" compose:Replacement merge: Default]
							[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.Reader{ImportPackage} : ImportDeclaration "import java.io.Reader;" compose:Replacement merge: Default]
							[T -> java.net.URI{ImportPackage} : ImportDeclaration "import java.net.URI;" compose:Replacement merge: Default]
							[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
							[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
							[NT -> DropListener : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> DropListener : Id "DropListener" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements DropTargetListener" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> DropListener(MainWindow-MainWindow) : ConstructorDecl "public DropListener(MainWindow mainWindow) {   this.mainWindow = mainWindow;  }" compose:Replacement merge: LineBased]
								[T -> drop(DropTargetDropEvent-DropTargetDropEvent) : MethodDecl "@SuppressWarnings("unchecked")  @Override  public void drop(DropTargetDropEvent event) {   event.acceptDrop(DnDConstants.ACTION_COPY);   Transferable transferable = event.getTransferable();   if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    for (DataFlavor flavor : flavors) {     try {      if (flavor.isFlavorJavaFileListType()) {       List<File> files = (List<File>) transferable         .getTransferData(flavor);       if (files.size() > 1) {        event.rejectDrop();        return;       }       if (files.size() == 1) {        mainWindow.onFileDropped(files.get(0));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }    event.dropComplete(true);   } else {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    boolean handled = false;    for (int zz = 0; zz < flavors.length; zz++) {     if (flavors[zz].isRepresentationClassReader()) {      try {       Reader reader = flavors[zz].getReaderForText(transferable);       BufferedReader br = new BufferedReader(reader);       List<File> list = new ArrayList<File>();       String line = null;       while ((line = br.readLine()) != null) {        try {         if (new String("" + (char) 0).equals(line))          continue;         File file = new File(new URI(line));         list.add(file);        } catch (Exception ex) {         ex.printStackTrace();        }       }       if (list.size() > 1) {        event.rejectDrop();        return;       }       if (list.size() == 1) {        mainWindow.onFileDropped(list.get(0));       }       event.getDropTargetContext().dropComplete(true);       handled = true;      } catch (Exception e) {       e.printStackTrace();      }      break;     }    }    if (!handled) {     event.rejectDrop();    }   }   }" compose:Replacement merge: LineBased]
								[T -> dragEnter(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dragEnter(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dragExit(DropTargetEvent-DropTargetEvent) : MethodDecl "@Override  public void dragExit(DropTargetEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dragOver(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dragOver(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
								[T -> dropActionChanged(DropTargetDragEvent-DropTargetDragEvent) : MethodDecl "@Override  public void dropActionChanged(DropTargetDragEvent arg0) {}" compose:Replacement merge: LineBased]
					[NT -> FileEntryNotFoundException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> FileEntryNotFoundException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileEntryNotFoundException : Id "FileEntryNotFoundException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
					[NT -> FileIsBinaryException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> FileIsBinaryException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FileIsBinaryException : Id "FileIsBinaryException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
					[NT -> JarEntryFilter.java : Java-File]
					[NT -> Closer.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> Closer : ClassDeclaration]
								[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Closer : Id "Closer" compose:Replacement merge: Default]
								[T -> tryClose(AutoCloseable-AutoCloseable) : MethodDecl "public static void tryClose(final AutoCloseable c) {         if (c == null) {             return;         }         try {             c.close();         }         catch (Throwable ignored) {         }     }" compose:Replacement merge: LineBased]
								[T -> tryClose(AutoCloseable-AutoCloseable) : MethodDecl "public static void tryClose(final AutoCloseable... items) {         if (items == null) {             return;         }         for (AutoCloseable c : items) {             tryClose(c);         }     }" compose:Replacement merge: LineBased]
					[NT -> Model.java : Java-File]
					[NT -> ConfigSaver.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.lang.reflect.Field{ImportPackage} : ImportDeclaration "import java.lang.reflect.Field;" compose:Replacement merge: Default]
							[T -> java.lang.reflect.Modifier{ImportPackage} : ImportDeclaration "import java.lang.reflect.Modifier;" compose:Replacement merge: Default]
							[T -> java.util.prefs.Preferences{ImportPackage} : ImportDeclaration "import java.util.prefs.Preferences;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Language{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Language;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Languages{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Languages;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.java.JavaFormattingOptions{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.java.JavaFormattingOptions;" compose:Replacement merge: Default]
							[NT -> ConfigSaver : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> ConfigSaver : Id "ConfigSaver" compose:Replacement merge: Default]
								[T -> FLATTEN_SWITCH_BLOCKS_ID : FieldDecl "private static final String FLATTEN_SWITCH_BLOCKS_ID = "flattenSwitchBlocks";" compose:Replacement merge: SemanticConflict]
								[T -> FORCE_EXPLICIT_IMPORTS_ID : FieldDecl "private static final String FORCE_EXPLICIT_IMPORTS_ID = "forceExplicitImports";" compose:Replacement merge: SemanticConflict]
								[T -> SHOW_SYNTHETIC_MEMBERS_ID : FieldDecl "private static final String SHOW_SYNTHETIC_MEMBERS_ID = "showSyntheticMembers";" compose:Replacement merge: SemanticConflict]
								[T -> EXCLUDE_NESTED_TYPES_ID : FieldDecl "private static final String EXCLUDE_NESTED_TYPES_ID = "excludeNestedTypes";" compose:Replacement merge: SemanticConflict]
								[T -> FORCE_EXPLICIT_TYPE_ARGUMENTS_ID : FieldDecl "private static final String FORCE_EXPLICIT_TYPE_ARGUMENTS_ID = "forceExplicitTypeArguments";" compose:Replacement merge: SemanticConflict]
								[T -> RETAIN_REDUNDANT_CASTS_ID : FieldDecl "private static final String RETAIN_REDUNDANT_CASTS_ID = "retainRedundantCasts";" compose:Replacement merge: SemanticConflict]
								[T -> INCLUDE_ERROR_DIAGNOSTICS_ID : FieldDecl "private static final String INCLUDE_ERROR_DIAGNOSTICS_ID = "includeErrorDiagnostics";" compose:Replacement merge: SemanticConflict]
								[T -> LANGUAGE_NAME_ID : FieldDecl "private static final String LANGUAGE_NAME_ID = "languageName";" compose:Replacement merge: SemanticConflict]
								[T -> MAIN_WINDOW_ID_PREFIX : FieldDecl "private static final String MAIN_WINDOW_ID_PREFIX = "main";" compose:Replacement merge: SemanticConflict]
								[T -> FIND_WINDOW_ID_PREFIX : FieldDecl "private static final String FIND_WINDOW_ID_PREFIX = "find";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_IS_FULL_SCREEN_ID : FieldDecl "private static final String WINDOW_IS_FULL_SCREEN_ID = "WindowIsFullScreen";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_WIDTH_ID : FieldDecl "private static final String WINDOW_WIDTH_ID = "WindowWidth";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_HEIGHT_ID : FieldDecl "private static final String WINDOW_HEIGHT_ID = "WindowHeight";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_X_ID : FieldDecl "private static final String WINDOW_X_ID = "WindowX";" compose:Replacement merge: SemanticConflict]
								[T -> WINDOW_Y_ID : FieldDecl "private static final String WINDOW_Y_ID = "WindowY";" compose:Replacement merge: SemanticConflict]
								[T -> decompilerSettings : FieldDecl "private DecompilerSettings decompilerSettings;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindowPosition : FieldDecl "private WindowPosition mainWindowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> findWindowPosition : FieldDecl "private WindowPosition findWindowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPreferences : FieldDecl "private LuytenPreferences luytenPreferences;" compose:Replacement merge: SemanticConflict]
								[T -> theLoadedInstance : FieldDecl "private static ConfigSaver theLoadedInstance;" compose:Replacement merge: SemanticConflict]
								[T -> ConfigSaver({FormalParametersInternal}) : ConstructorDecl "private ConfigSaver() {}" compose:Replacement merge: LineBased]
								[T -> getLoadedInstance({FormalParametersInternal}) : MethodDecl "public static ConfigSaver getLoadedInstance() {   if (theLoadedInstance == null) {    synchronized (ConfigSaver.class) {     if (theLoadedInstance == null) {      theLoadedInstance = new ConfigSaver();      theLoadedInstance.loadConfig();     }    }   }   return theLoadedInstance;  }" compose:Replacement merge: LineBased]
								[T -> loadConfig({FormalParametersInternal}) : MethodDecl "private void loadConfig() {   decompilerSettings = new DecompilerSettings();   if (decompilerSettings.getFormattingOptions() == null) {    decompilerSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   luytenPreferences = new LuytenPreferences();   mainWindowPosition = new WindowPosition();   findWindowPosition = new WindowPosition();   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     decompilerSettings.setFlattenSwitchBlocks(prefs.getBoolean(FLATTEN_SWITCH_BLOCKS_ID,      decompilerSettings.getFlattenSwitchBlocks()));    decompilerSettings.setForceExplicitImports(prefs.getBoolean(FORCE_EXPLICIT_IMPORTS_ID,      decompilerSettings.getForceExplicitImports()));    decompilerSettings.setShowSyntheticMembers(prefs.getBoolean(SHOW_SYNTHETIC_MEMBERS_ID,      decompilerSettings.getShowSyntheticMembers()));    decompilerSettings.setExcludeNestedTypes(prefs.getBoolean(EXCLUDE_NESTED_TYPES_ID,      decompilerSettings.getExcludeNestedTypes()));    decompilerSettings.setForceExplicitTypeArguments(prefs.getBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID,      decompilerSettings.getForceExplicitTypeArguments()));    decompilerSettings.setRetainRedundantCasts(prefs.getBoolean(RETAIN_REDUNDANT_CASTS_ID,      decompilerSettings.getRetainRedundantCasts()));    decompilerSettings.setIncludeErrorDiagnostics(prefs.getBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID,      decompilerSettings.getIncludeErrorDiagnostics()));    decompilerSettings.setLanguage(findLanguageByName(prefs.get(LANGUAGE_NAME_ID,      decompilerSettings.getLanguage().getName())));     mainWindowPosition = loadWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX);    findWindowPosition = loadWindowPosition(prefs, FIND_WINDOW_ID_PREFIX);    luytenPreferences = loadLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> loadWindowPosition(Preferences-Preferences-String-String) : MethodDecl "private WindowPosition loadWindowPosition(Preferences prefs, String windowIdPrefix) {   WindowPosition windowPosition = new WindowPosition();   windowPosition.setFullScreen(prefs.getBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, false));   windowPosition.setWindowWidth(prefs.getInt(windowIdPrefix + WINDOW_WIDTH_ID, 0));   windowPosition.setWindowHeight(prefs.getInt(windowIdPrefix + WINDOW_HEIGHT_ID, 0));   windowPosition.setWindowX(prefs.getInt(windowIdPrefix + WINDOW_X_ID, 0));   windowPosition.setWindowY(prefs.getInt(windowIdPrefix + WINDOW_Y_ID, 0));   return windowPosition;  }" compose:Replacement merge: LineBased]
								[T -> loadLuytenPreferences(Preferences-Preferences) : MethodDecl "private LuytenPreferences loadLuytenPreferences(Preferences prefs) throws Exception {   LuytenPreferences newLuytenPrefs = new LuytenPreferences();   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object defaultVal = field.get(newLuytenPrefs);     if (field.getType() == String.class) {     String defaultStr = (String) (defaultVal == null ? "" : defaultVal);     field.set(newLuytenPrefs, prefs.get(prefId, defaultStr));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     Boolean defaultBool = (Boolean) (defaultVal == null ? new Boolean(false) : defaultVal);     field.setBoolean(newLuytenPrefs, prefs.getBoolean(prefId, defaultBool));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     Integer defaultInt = (Integer) (defaultVal == null ? new Integer(0) : defaultVal);     field.setInt(newLuytenPrefs, prefs.getInt(prefId, defaultInt));    }   }   return newLuytenPrefs;  }" compose:Replacement merge: LineBased]
								[T -> saveConfig({FormalParametersInternal}) : MethodDecl "public void saveConfig() {   // Registry path on Windows Xp:   // HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\modcrafting\luyten   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     prefs.putBoolean(FLATTEN_SWITCH_BLOCKS_ID, decompilerSettings.getFlattenSwitchBlocks());    prefs.putBoolean(FORCE_EXPLICIT_IMPORTS_ID, decompilerSettings.getForceExplicitImports());    prefs.putBoolean(SHOW_SYNTHETIC_MEMBERS_ID, decompilerSettings.getShowSyntheticMembers());    prefs.putBoolean(EXCLUDE_NESTED_TYPES_ID, decompilerSettings.getExcludeNestedTypes());    prefs.putBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID, decompilerSettings.getForceExplicitTypeArguments());    prefs.putBoolean(RETAIN_REDUNDANT_CASTS_ID, decompilerSettings.getRetainRedundantCasts());    prefs.putBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID, decompilerSettings.getIncludeErrorDiagnostics());    prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     saveWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX, mainWindowPosition);    saveWindowPosition(prefs, FIND_WINDOW_ID_PREFIX, findWindowPosition);    saveLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> saveWindowPosition(Preferences-Preferences-String-String-WindowPosition-WindowPosition) : MethodDecl "private void saveWindowPosition(Preferences prefs, String windowIdPrefix, WindowPosition windowPosition) {   prefs.putBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, windowPosition.isFullScreen());   prefs.putInt(windowIdPrefix + WINDOW_WIDTH_ID, windowPosition.getWindowWidth());   prefs.putInt(windowIdPrefix + WINDOW_HEIGHT_ID, windowPosition.getWindowHeight());   prefs.putInt(windowIdPrefix + WINDOW_X_ID, windowPosition.getWindowX());   prefs.putInt(windowIdPrefix + WINDOW_Y_ID, windowPosition.getWindowY());  }" compose:Replacement merge: LineBased]
								[T -> saveLuytenPreferences(Preferences-Preferences) : MethodDecl "private void saveLuytenPreferences(Preferences prefs) throws Exception {   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object value = field.get(luytenPreferences);     if (field.getType() == String.class) {     prefs.put(prefId, (String) (value == null ? "" : value));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     prefs.putBoolean(prefId, (Boolean) (value == null ? new Boolean(false) : value));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     prefs.putInt(prefId, (Integer) (value == null ? new Integer(0) : value));    }   }  }" compose:Replacement merge: LineBased]
								[T -> findLanguageByName(String-String) : MethodDecl "private Language findLanguageByName(String languageName) {   if (languageName != null) {     if (languageName.equals(Languages.java().getName())) {     return Languages.java();    } else if (languageName.equals(Languages.bytecode().getName())) {     return Languages.bytecode();    } else if (languageName.equals(Languages.bytecodeAst().getName())) {     return Languages.bytecodeAst();    }     for (Language language : Languages.debug()) {     if (languageName.equals(language.getName())) {      return language;     }    }   }   return Languages.java();  }" compose:Replacement merge: LineBased]
								[T -> getDecompilerSettings({FormalParametersInternal}) : MethodDecl "public DecompilerSettings getDecompilerSettings() {   return decompilerSettings;  }" compose:Replacement merge: LineBased]
								[T -> getMainWindowPosition({FormalParametersInternal}) : MethodDecl "public WindowPosition getMainWindowPosition() {   return mainWindowPosition;  }" compose:Replacement merge: LineBased]
								[T -> getFindWindowPosition({FormalParametersInternal}) : MethodDecl "public WindowPosition getFindWindowPosition() {   return findWindowPosition;  }" compose:Replacement merge: LineBased]
								[T -> getLuytenPreferences({FormalParametersInternal}) : MethodDecl "public LuytenPreferences getLuytenPreferences() {   return luytenPreferences;  }" compose:Replacement merge: LineBased]
					[NT -> Luyten.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> javax.swing.SwingUtilities{ImportPackage} : ImportDeclaration "import javax.swing.SwingUtilities;" compose:Replacement merge: Default]
							[T -> javax.swing.UIManager{ImportPackage} : ImportDeclaration "import javax.swing.UIManager;" compose:Replacement merge: Default]
							[NT -> Luyten : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Luyten : Id "Luyten" compose:Replacement merge: Default]
								[T -> main(String[]-String[]) : MethodDecl "public static void main(String[] args) {   try {    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());   } catch (Exception e) {    e.printStackTrace();   }    // for TotalCommander External Viewer setting:   // javaw -jar "c:\Program Files\Luyten\luyten.jar"   // (TC will not complain about temporary file when opening .class from .zip or .jar)   final File fileFromCommandLine = getFileFromCommandLine(args);    SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     MainWindow mainWindow = new MainWindow(fileFromCommandLine);     mainWindow.setVisible(true);    }   });  }" compose:Replacement merge: LineBased]
								[T -> getFileFromCommandLine(String[]-String[]) : MethodDecl "public static File getFileFromCommandLine(String[] args) {   File fileFromCommandLine = null;   try {    if (args.length > 0) {     String realFileName = new File(args[0]).getCanonicalPath();     fileFromCommandLine = new File(realFileName);    }   } catch (Exception e) {    e.printStackTrace();   }   return fileFromCommandLine;  }" compose:Replacement merge: LineBased]
					[NT -> LinkProvider.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
							[T -> java.util.Set{ImportPackage} : ImportDeclaration "import java.util.Set;" compose:Replacement merge: Default]
							[NT -> LinkProvider : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface2 "interface" compose:Replacement merge: Default]
								[T -> LinkProvider : Id "LinkProvider" compose:Replacement merge: Default]
								[T -> generateContent({FormalParametersInternal}) : MethodDecl "public void generateContent();" compose:Replacement merge: LineBased]
								[T -> getTextContent({FormalParametersInternal}) : MethodDecl "public String getTextContent();" compose:Replacement merge: LineBased]
								[T -> processLinks({FormalParametersInternal}) : MethodDecl "public void processLinks();" compose:Replacement merge: LineBased]
								[T -> getDefinitionToSelectionMap({FormalParametersInternal}) : MethodDecl "public Map<String, Selection> getDefinitionToSelectionMap();" compose:Replacement merge: LineBased]
								[T -> getReferenceToSelectionsMap({FormalParametersInternal}) : MethodDecl "public Map<String, Set<Selection>> getReferenceToSelectionsMap();" compose:Replacement merge: LineBased]
								[T -> isLinkNavigable(String-String) : MethodDecl "public boolean isLinkNavigable(String uniqueStr);" compose:Replacement merge: LineBased]
								[T -> getLinkDescription(String-String) : MethodDecl "public String getLinkDescription(String uniqueStr);" compose:Replacement merge: LineBased]
					[NT -> TreeUtil.java : Java-File]
					[NT -> FindBox.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.Action{ImportPackage} : ImportDeclaration "import javax.swing.Action;" compose:Replacement merge: Default]
							[T -> javax.swing.BorderFactory{ImportPackage} : ImportDeclaration "import javax.swing.BorderFactory;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout;" compose:Replacement merge: Default]
							[T -> javax.swing.GroupLayout.Alignment{ImportPackage} : ImportDeclaration "import javax.swing.GroupLayout.Alignment;" compose:Replacement merge: Default]
							[T -> javax.swing.JButton{ImportPackage} : ImportDeclaration "import javax.swing.JButton;" compose:Replacement merge: Default]
							[T -> javax.swing.JCheckBox{ImportPackage} : ImportDeclaration "import javax.swing.JCheckBox;" compose:Replacement merge: Default]
							[T -> javax.swing.JComponent{ImportPackage} : ImportDeclaration "import javax.swing.JComponent;" compose:Replacement merge: Default]
							[T -> javax.swing.JDialog{ImportPackage} : ImportDeclaration "import javax.swing.JDialog;" compose:Replacement merge: Default]
							[T -> javax.swing.JLabel{ImportPackage} : ImportDeclaration "import javax.swing.JLabel;" compose:Replacement merge: Default]
							[T -> javax.swing.JTextField{ImportPackage} : ImportDeclaration "import javax.swing.JTextField;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.SwingConstants{ImportPackage} : ImportDeclaration "import javax.swing.SwingConstants;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rsyntaxtextarea.RSyntaxTextArea{ImportPackage} : ImportDeclaration "import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rtextarea.SearchContext{ImportPackage} : ImportDeclaration "import org.fife.ui.rtextarea.SearchContext;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rtextarea.SearchEngine{ImportPackage} : ImportDeclaration "import org.fife.ui.rtextarea.SearchEngine;" compose:Replacement merge: Default]
							[NT -> FindBox : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> FindBox : Id "FindBox" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JDialog" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -4125409760166690462L;" compose:Replacement merge: SemanticConflict]
								[T -> mcase : FieldDecl "private JCheckBox mcase;" compose:Replacement merge: SemanticConflict]
								[T -> regex : FieldDecl "private JCheckBox regex;" compose:Replacement merge: SemanticConflict]
								[T -> wholew : FieldDecl "private JCheckBox wholew;" compose:Replacement merge: SemanticConflict]
								[T -> reverse : FieldDecl "private JCheckBox reverse;" compose:Replacement merge: SemanticConflict]
								[T -> findButton : FieldDecl "private JButton findButton;" compose:Replacement merge: SemanticConflict]
								[T -> textField : FieldDecl "private JTextField textField;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> showFindBox({FormalParametersInternal}) : MethodDecl "public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();   this.textField.selectAll();  }" compose:Replacement merge: LineBased]
								[T -> hideFindBox({FormalParametersInternal}) : MethodDecl "public void hideFindBox() {   this.setVisible(false);  }" compose:Replacement merge: LineBased]
								[T -> FindBox(MainWindow-MainWindow) : ConstructorDecl "public FindBox(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();    JLabel label = new JLabel("Find What:");   textField = new JTextField();    RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();   if (pane != null) {    textField.setText(pane.getSelectedText());   }   mcase = new JCheckBox("Match Case");   regex = new JCheckBox("Regex");   wholew = new JCheckBox("Whole Words");   reverse = new JCheckBox("Search Backwards");    findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    mcase.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   regex.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   wholew.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   reverse.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     Math.min((int) (screenSize.height * 0.20), 200));   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    layout.setHorizontalGroup(layout.createSequentialGroup()     .addComponent(label)     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(textField)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(mcase)           .addComponent(wholew))         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(regex)           .addComponent(reverse))))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(findButton))     );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(Alignment.BASELINE)       .addComponent(label)       .addComponent(textField)       .addComponent(findButton))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(mcase)           .addComponent(regex))         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(wholew)           .addComponent(reverse))))     );    this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();    this.setName("Find");   this.setTitle("Find");   this.setVisible(true);  }" compose:Replacement merge: LineBased]
								[NT -> FindButton : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> FindButton : Id "FindButton" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 75954129199541874L;" compose:Replacement merge: SemanticConflict]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent event) {    if (textField.getText().length() == 0)     return;     RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();    if (pane == null)     return;     SearchContext context = new SearchContext();    context.setSearchFor(textField.getText());    context.setMatchCase(mcase.isSelected());    context.setRegularExpression(regex.isSelected());    context.setSearchForward(!reverse.isSelected());    context.setWholeWord(wholew.isSelected());     if (!SearchEngine.find(pane, context)) {     pane.setSelectionStart(0);     pane.setSelectionEnd(0);    }   }" compose:Replacement merge: LineBased]
								[T -> setHideOnEscapeButton({FormalParametersInternal}) : MethodDecl "private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(), windowPosition.getWindowY());   }  }" compose:Replacement merge: LineBased]
								[T -> setSaveWindowPositionOnClosing({FormalParametersInternal}) : MethodDecl "private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();     windowPosition.readPositionFromDialog(FindBox.this);    }   });  }" compose:Replacement merge: LineBased]
					[NT -> Selection.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> Selection : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> Selection : Id "Selection" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements Comparable<Selection>" compose:Replacement merge: SemanticConflict]
								[T -> from : FieldDecl "public final Integer from;" compose:Replacement merge: SemanticConflict]
								[T -> to : FieldDecl "public final Integer to;" compose:Replacement merge: SemanticConflict]
								[T -> Selection(Integer-Integer-Integer-Integer) : ConstructorDecl "public Selection(Integer from, Integer to) {   this.from = from;   this.to = to;  }" compose:Replacement merge: LineBased]
								[T -> compareTo(Selection-Selection) : MethodDecl "@Override  public int compareTo(Selection o) {   return from.compareTo(o.from);  }" compose:Replacement merge: LineBased]
								[T -> hashCode({FormalParametersInternal}) : MethodDecl "@Override  public int hashCode() {   final int prime = 31;   int result = 1;   result = prime * result + ((from == null) ? 0 : from.hashCode());   return result;  }" compose:Replacement merge: LineBased]
								[T -> equals(Object-Object) : MethodDecl "@Override  public boolean equals(Object obj) {   if (this == obj)    return true;   if (obj == null)    return false;   if (getClass() != obj.getClass())    return false;   Selection other = (Selection) obj;   if (from == null) {    if (other.from != null)     return false;   } else if (!from.equals(other.from))    return false;   return true;  }" compose:Replacement merge: LineBased]
					[NT -> MainMenuBar.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionListener{ImportPackage} : ImportDeclaration "import java.awt.event.ActionListener;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.util.Collections{ImportPackage} : ImportDeclaration "import java.util.Collections;" compose:Replacement merge: Default]
							[T -> java.util.HashMap{ImportPackage} : ImportDeclaration "import java.util.HashMap;" compose:Replacement merge: Default]
							[T -> java.util.Map{ImportPackage} : ImportDeclaration "import java.util.Map;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractButton{ImportPackage} : ImportDeclaration "import javax.swing.AbstractButton;" compose:Replacement merge: Default]
							[T -> javax.swing.ButtonGroup{ImportPackage} : ImportDeclaration "import javax.swing.ButtonGroup;" compose:Replacement merge: Default]
							[T -> javax.swing.ButtonModel{ImportPackage} : ImportDeclaration "import javax.swing.ButtonModel;" compose:Replacement merge: Default]
							[T -> javax.swing.JCheckBox{ImportPackage} : ImportDeclaration "import javax.swing.JCheckBox;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenu{ImportPackage} : ImportDeclaration "import javax.swing.JMenu;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenuBar{ImportPackage} : ImportDeclaration "import javax.swing.JMenuBar;" compose:Replacement merge: Default]
							[T -> javax.swing.JMenuItem{ImportPackage} : ImportDeclaration "import javax.swing.JMenuItem;" compose:Replacement merge: Default]
							[T -> javax.swing.JOptionPane{ImportPackage} : ImportDeclaration "import javax.swing.JOptionPane;" compose:Replacement merge: Default]
							[T -> javax.swing.JRadioButtonMenuItem{ImportPackage} : ImportDeclaration "import javax.swing.JRadioButtonMenuItem;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.text.DefaultEditorKit{ImportPackage} : ImportDeclaration "import javax.swing.text.DefaultEditorKit;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.DecompilerSettings{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.DecompilerSettings;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Language{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Language;" compose:Replacement merge: Default]
							[T -> com.strobel.decompiler.languages.Languages{ImportPackage} : ImportDeclaration "import com.strobel.decompiler.languages.Languages;" compose:Replacement merge: Default]
							[NT -> MainMenuBar : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> MainMenuBar : Id "MainMenuBar" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JMenuBar" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> mainWindow : FieldDecl "private final MainWindow mainWindow;" compose:Replacement merge: SemanticConflict]
								[T -> languageLookup : FieldDecl "private final Map<String, Language> languageLookup = new HashMap<String, Language>();" compose:Replacement merge: SemanticConflict]
								[T -> flattenSwitchBlocks : FieldDecl "private JCheckBox flattenSwitchBlocks;" compose:Replacement merge: SemanticConflict]
								[T -> forceExplicitImports : FieldDecl "private JCheckBox forceExplicitImports;" compose:Replacement merge: SemanticConflict]
								[T -> forceExplicitTypes : FieldDecl "private JCheckBox forceExplicitTypes;" compose:Replacement merge: SemanticConflict]
								[T -> showSyntheticMembers : FieldDecl "private JCheckBox showSyntheticMembers;" compose:Replacement merge: SemanticConflict]
								[T -> excludeNestedTypes : FieldDecl "private JCheckBox excludeNestedTypes;" compose:Replacement merge: SemanticConflict]
								[T -> retainRedundantCasts : FieldDecl "private JCheckBox retainRedundantCasts;" compose:Replacement merge: SemanticConflict]
								[T -> showDebugInfo : FieldDecl "private JCheckBox showDebugInfo;" compose:Replacement merge: SemanticConflict]
								[T -> java : FieldDecl "private JRadioButtonMenuItem java;" compose:Replacement merge: SemanticConflict]
								[T -> bytecode : FieldDecl "private JRadioButtonMenuItem bytecode;" compose:Replacement merge: SemanticConflict]
								[T -> bytecodeAST : FieldDecl "private JRadioButtonMenuItem bytecodeAST;" compose:Replacement merge: SemanticConflict]
								[T -> languagesGroup : FieldDecl "private ButtonGroup languagesGroup;" compose:Replacement merge: SemanticConflict]
								[T -> themesGroup : FieldDecl "private ButtonGroup themesGroup;" compose:Replacement merge: SemanticConflict]
								[T -> packageExplorerStyle : FieldDecl "private JCheckBox packageExplorerStyle;" compose:Replacement merge: SemanticConflict]
								[T -> filterOutInnerClassEntries : FieldDecl "private JCheckBox filterOutInnerClassEntries;" compose:Replacement merge: SemanticConflict]
								[T -> singleClickOpenEnabled : FieldDecl "private JCheckBox singleClickOpenEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> exitByEscEnabled : FieldDecl "private JCheckBox exitByEscEnabled;" compose:Replacement merge: SemanticConflict]
								[T -> settings : FieldDecl "private DecompilerSettings settings;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> MainMenuBar(MainWindow-MainWindow) : ConstructorDecl "public MainMenuBar(MainWindow mainWnd) {   this.mainWindow = mainWnd;   ConfigSaver configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    final JMenu fileMenu = new JMenu("File");   fileMenu.add(new JMenuItem("..."));   this.add(fileMenu);   final JMenu editMenu = new JMenu("Edit");   editMenu.add(new JMenuItem("..."));   this.add(editMenu);   final JMenu themesMenu = new JMenu("Themes");   themesMenu.add(new JMenuItem("..."));   this.add(themesMenu);   final JMenu operationMenu = new JMenu("Operation");   operationMenu.add(new JMenuItem("..."));   this.add(operationMenu);   final JMenu settingsMenu = new JMenu("Settings");   settingsMenu.add(new JMenuItem("..."));   this.add(settingsMenu);   final JMenu helpMenu = new JMenu("Help");   helpMenu.add(new JMenuItem("..."));   this.add(helpMenu);    // start quicker   new Thread() {    public void run() {     try {      // build menu later      buildFileMenu(fileMenu);      refreshMenuPopup(fileMenu);       buildEditMenu(editMenu);      refreshMenuPopup(editMenu);       buildThemesMenu(themesMenu);      refreshMenuPopup(themesMenu);       buildOperationMenu(operationMenu);      refreshMenuPopup(operationMenu);       buildSettingsMenu(settingsMenu);      refreshMenuPopup(settingsMenu);       buildHelpMenu(helpMenu);      refreshMenuPopup(helpMenu);     } catch (Exception e) {      e.printStackTrace();     }    }     // refresh currently opened menu     // (if user selected a menu before it was ready)    private void refreshMenuPopup(JMenu menu) {     try {      if (menu.isPopupMenuVisible()) {       menu.getPopupMenu().setVisible(false);       menu.getPopupMenu().setVisible(true);      }     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }" compose:Replacement merge: LineBased]
								[T -> buildFileMenu(JMenu-JMenu) : MethodDecl "private void buildFileMenu(final JMenu fileMenu) {   fileMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Open File...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onOpenFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Close");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onCloseFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Save As...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAsMenu();    }   });   fileMenu.add(menuItem);    menuItem = new JMenuItem("Save All...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAllMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Recent Files");   menuItem.setEnabled(false);   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Exit");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onExitMenu();    }   });   fileMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> buildEditMenu(JMenu-JMenu) : MethodDecl "private void buildEditMenu(JMenu editMenu) {   editMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Cut");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    menuItem = new JMenuItem("Copy");   menuItem.addActionListener(new DefaultEditorKit.CopyAction());   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));   editMenu.add(menuItem);    menuItem = new JMenuItem("Paste");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    editMenu.addSeparator();    menuItem = new JMenuItem("Select All");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSelectAllMenu();    }   });   editMenu.add(menuItem);   editMenu.addSeparator();    menuItem = new JMenuItem("Find...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onFindMenu();    }   });   editMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> buildThemesMenu(JMenu-JMenu) : MethodDecl "private void buildThemesMenu(JMenu themesMenu) {   themesMenu.removeAll();   themesGroup = new ButtonGroup();   JRadioButtonMenuItem a = new JRadioButtonMenuItem(new ThemeAction("Default", "default.xml"));   a.setSelected("default.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Dark", "dark.xml"));   a.setSelected("dark.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Eclipse", "eclipse.xml"));   a.setSelected("eclipse.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Visual Studio", "vs.xml"));   a.setSelected("vs.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);  }" compose:Replacement merge: LineBased]
								[T -> buildOperationMenu(JMenu-JMenu) : MethodDecl "private void buildOperationMenu(JMenu operationMenu) {   operationMenu.removeAll();   packageExplorerStyle = new JCheckBox("Package Explorer Style");   packageExplorerStyle.setSelected(luytenPrefs.isPackageExplorerStyle());   packageExplorerStyle.setContentAreaFilled(false);   packageExplorerStyle.setFocusable(false);   packageExplorerStyle.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setPackageExplorerStyle(packageExplorerStyle.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(packageExplorerStyle);      filterOutInnerClassEntries = new JCheckBox("Filter Out Inner Class Entries");   filterOutInnerClassEntries.setSelected(luytenPrefs.isFilterOutInnerClassEntries());   filterOutInnerClassEntries.setContentAreaFilled(false);   filterOutInnerClassEntries.setFocusable(false);   filterOutInnerClassEntries.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setFilterOutInnerClassEntries(filterOutInnerClassEntries.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(filterOutInnerClassEntries);    singleClickOpenEnabled = new JCheckBox("Single Click Open");   singleClickOpenEnabled.setSelected(luytenPrefs.isSingleClickOpenEnabled());   singleClickOpenEnabled.setContentAreaFilled(false);   singleClickOpenEnabled.setFocusable(false);   singleClickOpenEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setSingleClickOpenEnabled(singleClickOpenEnabled.isSelected());    }   });   operationMenu.add(singleClickOpenEnabled);    exitByEscEnabled = new JCheckBox("Exit By Esc");   exitByEscEnabled.setSelected(luytenPrefs.isExitByEscEnabled());   exitByEscEnabled.setContentAreaFilled(false);   exitByEscEnabled.setFocusable(false);   exitByEscEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setExitByEscEnabled(exitByEscEnabled.isSelected());    }   });   operationMenu.add(exitByEscEnabled);  }" compose:Replacement merge: LineBased]
								[T -> buildSettingsMenu(JMenu-JMenu) : MethodDecl "private void buildSettingsMenu(JMenu settingsMenu) {   settingsMenu.removeAll();   ActionListener settingsChanged = new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     new Thread() {      @Override      public void run() {       populateSettingsFromSettingsMenu();       mainWindow.onSettingsChanged();      }     }.start();    }   };   flattenSwitchBlocks = new JCheckBox("Flatten Switch Blocks");   flattenSwitchBlocks.setSelected(settings.getFlattenSwitchBlocks());   flattenSwitchBlocks.setContentAreaFilled(false);   flattenSwitchBlocks.setFocusable(false);   flattenSwitchBlocks.addActionListener(settingsChanged);   settingsMenu.add(flattenSwitchBlocks);    forceExplicitImports = new JCheckBox("Force Explicit Imports");   forceExplicitImports.setSelected(settings.getForceExplicitImports());   forceExplicitImports.setContentAreaFilled(false);   forceExplicitImports.setFocusable(false);   forceExplicitImports.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitImports);    forceExplicitTypes = new JCheckBox("Force Explicit Types");   forceExplicitTypes.setSelected(settings.getForceExplicitTypeArguments());   forceExplicitTypes.setContentAreaFilled(false);   forceExplicitTypes.setFocusable(false);   forceExplicitTypes.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitTypes);    showSyntheticMembers = new JCheckBox("Show Synthetic Members");   showSyntheticMembers.setSelected(settings.getShowSyntheticMembers());   showSyntheticMembers.setContentAreaFilled(false);   showSyntheticMembers.setFocusable(false);   showSyntheticMembers.addActionListener(settingsChanged);   settingsMenu.add(showSyntheticMembers);    excludeNestedTypes = new JCheckBox("Exclude Nested Types");   excludeNestedTypes.setSelected(settings.getExcludeNestedTypes());   excludeNestedTypes.setContentAreaFilled(false);   excludeNestedTypes.setFocusable(false);   excludeNestedTypes.addActionListener(settingsChanged);   settingsMenu.add(excludeNestedTypes);    retainRedundantCasts = new JCheckBox("Retain Redundant Casts");   retainRedundantCasts.setSelected(settings.getRetainRedundantCasts());   retainRedundantCasts.setContentAreaFilled(false);   retainRedundantCasts.setFocusable(false);   retainRedundantCasts.addActionListener(settingsChanged);   settingsMenu.add(retainRedundantCasts);    JMenu debugSettingsMenu = new JMenu("Debug Settings");   showDebugInfo = new JCheckBox("Include Error Diagnostics");   showDebugInfo.setSelected(settings.getIncludeErrorDiagnostics());   showDebugInfo.setContentAreaFilled(false);   showDebugInfo.setFocusable(false);   showDebugInfo.addActionListener(settingsChanged);    debugSettingsMenu.add(showDebugInfo);   settingsMenu.add(debugSettingsMenu);   settingsMenu.addSeparator();    languageLookup.put(Languages.java().getName(), Languages.java());   languageLookup.put(Languages.bytecode().getName(), Languages.bytecode());   languageLookup.put(Languages.bytecodeAst().getName(), Languages.bytecodeAst());    languagesGroup = new ButtonGroup();   java = new JRadioButtonMenuItem(Languages.java().getName());   java.getModel().setActionCommand(Languages.java().getName());   java.setSelected(Languages.java().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(java);   settingsMenu.add(java);   bytecode = new JRadioButtonMenuItem(Languages.bytecode().getName());   bytecode.getModel().setActionCommand(Languages.bytecode().getName());   bytecode.setSelected(Languages.bytecode().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecode);   settingsMenu.add(bytecode);   bytecodeAST = new JRadioButtonMenuItem(Languages.bytecodeAst().getName());   bytecodeAST.getModel().setActionCommand(Languages.bytecodeAst().getName());   bytecodeAST.setSelected(Languages.bytecodeAst().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecodeAST);   settingsMenu.add(bytecodeAST);    JMenu debugLanguagesMenu = new JMenu("Debug Languages");   for (final Language language : Languages.debug()) {    final JRadioButtonMenuItem m = new JRadioButtonMenuItem(language.getName());    m.getModel().setActionCommand(language.getName());    m.setSelected(language.getName().equals(settings.getLanguage().getName()));    languagesGroup.add(m);    debugLanguagesMenu.add(m);    languageLookup.put(language.getName(), language);   }   for (AbstractButton button : Collections.list(languagesGroup.getElements())) {    button.addActionListener(settingsChanged);   }   settingsMenu.add(debugLanguagesMenu);  }" compose:Replacement merge: LineBased]
								[T -> buildHelpMenu(JMenu-JMenu) : MethodDecl "private void buildHelpMenu(JMenu helpMenu) {   helpMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Legal");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onLegalMenu();    }   });   helpMenu.add(menuItem);   menuItem = new JMenuItem("About");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent event) {     JOptionPane.showMessageDialog(null,       "Luyten Gui \n" +         "by Deathmarine\n\n" +         "Powered By\nProcyon\n" +         "(c) 2013 Mike Strobel\n\n" +         "RSyntaxTextArea\n" +         "(c) 2012 Robert Futrell\n" +         "All rights reserved.");    }   });   helpMenu.add(menuItem);  }" compose:Replacement merge: LineBased]
								[T -> populateSettingsFromSettingsMenu({FormalParametersInternal}) : MethodDecl "private void populateSettingsFromSettingsMenu() {   // synchronized: do not disturb decompiler at work (synchronize every time before run decompiler)   synchronized (settings) {    settings.setFlattenSwitchBlocks(flattenSwitchBlocks.isSelected());    settings.setForceExplicitImports(forceExplicitImports.isSelected());    settings.setShowSyntheticMembers(showSyntheticMembers.isSelected());    settings.setExcludeNestedTypes(excludeNestedTypes.isSelected());    settings.setForceExplicitTypeArguments(forceExplicitTypes.isSelected());    settings.setRetainRedundantCasts(retainRedundantCasts.isSelected());    settings.setIncludeErrorDiagnostics(showDebugInfo.isSelected());    //    // Note: You shouldn't ever need to set this.  It's only for languages that support catch    //       blocks without an exception variable.  Java doesn't allow this.  I think Scala does.    //    // settings.setAlwaysGenerateExceptionVariableForCatchBlocks(true);    //     final ButtonModel selectedLanguage = languagesGroup.getSelection();    if (selectedLanguage != null) {     final Language language = languageLookup.get(selectedLanguage.getActionCommand());      if (language != null)      settings.setLanguage(language);    }     if (java.isSelected()) {     settings.setLanguage(Languages.java());    } else if (bytecode.isSelected()) {     settings.setLanguage(Languages.bytecode());    } else if (bytecodeAST.isSelected()) {     settings.setLanguage(Languages.bytecodeAst());    }   }  }" compose:Replacement merge: LineBased]
								[NT -> ThemeAction : InnerClassDecl]
									[T -> - : Modifiers "private" compose:Replacement merge: SemanticConflict]
									[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
									[T -> ThemeAction : Id "ThemeAction" compose:Replacement merge: Default]
									[T -> - : ExtendsList "extends AbstractAction" compose:Replacement merge: Default]
									[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -6618680171943723199L;" compose:Replacement merge: SemanticConflict]
									[T -> xml : FieldDecl "private String xml;" compose:Replacement merge: SemanticConflict]
									[T -> ThemeAction(String-String-String-String) : ConstructorDecl "public ThemeAction(String name, String xml) {    putValue(NAME, name);    this.xml = xml;   }" compose:Replacement merge: LineBased]
									[T -> actionPerformed(ActionEvent-ActionEvent) : MethodDecl "@Override   public void actionPerformed(ActionEvent e) {    luytenPrefs.setThemeXml(xml);    mainWindow.onThemesChanged();   }" compose:Replacement merge: LineBased]
					[NT -> TooLargeFileException.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.text.DecimalFormat{ImportPackage} : ImportDeclaration "import java.text.DecimalFormat;" compose:Replacement merge: Default]
							[NT -> TooLargeFileException : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> TooLargeFileException : Id "TooLargeFileException" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends Exception" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> size : FieldDecl "private long size;" compose:Replacement merge: SemanticConflict]
								[T -> TooLargeFileException(long-long) : ConstructorDecl "public TooLargeFileException(long size) {   this.size = size;  }" compose:Replacement merge: LineBased]
								[T -> getReadableFileSize({FormalParametersInternal}) : MethodDecl "public String getReadableFileSize() {   if (size <= 0)    return "0";   final String[] units = new String[] {"B", "KB", "MB", "GB", "TB"};   int digitGroups = (int) (Math.log10(size) / Math.log10(1024));   return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];  }" compose:Replacement merge: LineBased]
					[NT -> FileSaver.java : Java-File]
					[NT -> CellRenderer.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> javax.swing.Icon{ImportPackage} : ImportDeclaration "import javax.swing.Icon;" compose:Replacement merge: Default]
							[T -> javax.swing.ImageIcon{ImportPackage} : ImportDeclaration "import javax.swing.ImageIcon;" compose:Replacement merge: Default]
							[T -> javax.swing.JTree{ImportPackage} : ImportDeclaration "import javax.swing.JTree;" compose:Replacement merge: Default]
							[T -> javax.swing.tree.DefaultMutableTreeNode{ImportPackage} : ImportDeclaration "import javax.swing.tree.DefaultMutableTreeNode;" compose:Replacement merge: Default]
							[T -> javax.swing.tree.DefaultTreeCellRenderer{ImportPackage} : ImportDeclaration "import javax.swing.tree.DefaultTreeCellRenderer;" compose:Replacement merge: Default]
							[NT -> CellRenderer : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> CellRenderer : Id "CellRenderer" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends DefaultTreeCellRenderer" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = -5691181006363313993L;" compose:Replacement merge: SemanticConflict]
								[T -> pack : FieldDecl "Icon pack;" compose:Replacement merge: SemanticConflict]
								[T -> java_image : FieldDecl "Icon java_image;" compose:Replacement merge: SemanticConflict]
								[T -> file_image : FieldDecl "Icon file_image;" compose:Replacement merge: SemanticConflict]
								[T -> CellRenderer({FormalParametersInternal}) : ConstructorDecl "public CellRenderer(){   this.pack = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/package_obj.png")));   this.java_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/java.png")));   this.file_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/file.png")));  }" compose:Replacement merge: LineBased]
								[T -> getTreeCellRendererComponent(JTree-JTree-Object-Object-boolean-boolean-boolean-boolean-boolean-boolean-int-int-boolean-boolean) : MethodDecl "@Override  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);         DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;   if(node.getChildCount() > 0){    setIcon(this.pack);   }else if(getFileName(node).endsWith(".class") || getFileName(node).endsWith(".java")){    setIcon(this.java_image);   }else{    setIcon(this.file_image);   }      return this;  }" compose:Replacement merge: LineBased]
								[T -> getFileName(DefaultMutableTreeNode-DefaultMutableTreeNode) : MethodDecl "public String getFileName(DefaultMutableTreeNode node){         return ((TreeNodeUserObject) node.getUserObject()).getOriginalName();  }" compose:Replacement merge: LineBased]
					[NT -> TreeNodeUserObject.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> TreeNodeUserObject : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> TreeNodeUserObject : Id "TreeNodeUserObject" compose:Replacement merge: Default]
								[T -> originalName : FieldDecl "private String originalName;" compose:Replacement merge: SemanticConflict]
								[T -> displayName : FieldDecl "private String displayName;" compose:Replacement merge: SemanticConflict]
								[T -> TreeNodeUserObject(String-String) : ConstructorDecl "public TreeNodeUserObject(String name) {   this(name, name);  }" compose:Replacement merge: LineBased]
								[T -> TreeNodeUserObject(String-String-String-String) : ConstructorDecl "public TreeNodeUserObject(String originalName, String displayName) {   this.originalName = originalName;   this.displayName = displayName;  }" compose:Replacement merge: LineBased]
								[T -> getOriginalName({FormalParametersInternal}) : MethodDecl "public String getOriginalName() {   return originalName;  }" compose:Replacement merge: LineBased]
								[T -> setOriginalName(String-String) : MethodDecl "public void setOriginalName(String originalName) {   this.originalName = originalName;  }" compose:Replacement merge: LineBased]
								[T -> getDisplayName({FormalParametersInternal}) : MethodDecl "public String getDisplayName() {   return displayName;  }" compose:Replacement merge: LineBased]
								[T -> setDisplayName(String-String) : MethodDecl "public void setDisplayName(String displayName) {   this.displayName = displayName;  }" compose:Replacement merge: LineBased]
								[T -> toString({FormalParametersInternal}) : MethodDecl "@Override  public String toString() {   return displayName;  }" compose:Replacement merge: LineBased]
					[NT -> LuytenPreferences.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[NT -> LuytenPreferences : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> LuytenPreferences : Id "LuytenPreferences" compose:Replacement merge: Default]
								[T -> THEME_XML_PATH : FieldDecl "public static final String THEME_XML_PATH = "/themes/";" compose:Replacement merge: SemanticConflict]
								[T -> DEFAULT_THEME_XML : FieldDecl "public static final String DEFAULT_THEME_XML = "eclipse.xml";" compose:Replacement merge: SemanticConflict]
								[T -> themeXml : FieldDecl "private String themeXml = DEFAULT_THEME_XML;" compose:Replacement merge: SemanticConflict]
								[T -> fileOpenCurrentDirectory : FieldDecl "private String fileOpenCurrentDirectory = "";" compose:Replacement merge: SemanticConflict]
								[T -> fileSaveCurrentDirectory : FieldDecl "private String fileSaveCurrentDirectory = "";" compose:Replacement merge: SemanticConflict]
								[T -> isPackageExplorerStyle : FieldDecl "private boolean isPackageExplorerStyle = true;" compose:Replacement merge: SemanticConflict]
								[T -> isFilterOutInnerClassEntries : FieldDecl "private boolean isFilterOutInnerClassEntries = true;" compose:Replacement merge: SemanticConflict]
								[T -> isSingleClickOpenEnabled : FieldDecl "private boolean isSingleClickOpenEnabled = true;" compose:Replacement merge: SemanticConflict]
								[T -> isExitByEscEnabled : FieldDecl "private boolean isExitByEscEnabled = false;" compose:Replacement merge: SemanticConflict]
								[T -> getThemeXml({FormalParametersInternal}) : MethodDecl "public String getThemeXml() {   return themeXml;  }" compose:Replacement merge: LineBased]
								[T -> setThemeXml(String-String) : MethodDecl "public void setThemeXml(String themeXml) {   this.themeXml = themeXml;  }" compose:Replacement merge: LineBased]
								[T -> getFileOpenCurrentDirectory({FormalParametersInternal}) : MethodDecl "public String getFileOpenCurrentDirectory() {   return fileOpenCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> setFileOpenCurrentDirectory(String-String) : MethodDecl "public void setFileOpenCurrentDirectory(String fileOpenCurrentDirectory) {   this.fileOpenCurrentDirectory = fileOpenCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> getFileSaveCurrentDirectory({FormalParametersInternal}) : MethodDecl "public String getFileSaveCurrentDirectory() {   return fileSaveCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> setFileSaveCurrentDirectory(String-String) : MethodDecl "public void setFileSaveCurrentDirectory(String fileSaveCurrentDirectory) {   this.fileSaveCurrentDirectory = fileSaveCurrentDirectory;  }" compose:Replacement merge: LineBased]
								[T -> isPackageExplorerStyle({FormalParametersInternal}) : MethodDecl "public boolean isPackageExplorerStyle() {   return isPackageExplorerStyle;  }" compose:Replacement merge: LineBased]
								[T -> setPackageExplorerStyle(boolean-boolean) : MethodDecl "public void setPackageExplorerStyle(boolean isPackageExplorerStyle) {   this.isPackageExplorerStyle = isPackageExplorerStyle;  }" compose:Replacement merge: LineBased]
								[T -> isFilterOutInnerClassEntries({FormalParametersInternal}) : MethodDecl "public boolean isFilterOutInnerClassEntries() {   return isFilterOutInnerClassEntries;  }" compose:Replacement merge: LineBased]
								[T -> setFilterOutInnerClassEntries(boolean-boolean) : MethodDecl "public void setFilterOutInnerClassEntries(boolean isFilterOutInnerClassEntries) {   this.isFilterOutInnerClassEntries = isFilterOutInnerClassEntries;  }" compose:Replacement merge: LineBased]
								[T -> isSingleClickOpenEnabled({FormalParametersInternal}) : MethodDecl "public boolean isSingleClickOpenEnabled() {   return isSingleClickOpenEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setSingleClickOpenEnabled(boolean-boolean) : MethodDecl "public void setSingleClickOpenEnabled(boolean isSingleClickOpenEnabled) {   this.isSingleClickOpenEnabled = isSingleClickOpenEnabled;  }" compose:Replacement merge: LineBased]
								[T -> isExitByEscEnabled({FormalParametersInternal}) : MethodDecl "public boolean isExitByEscEnabled() {   return isExitByEscEnabled;  }" compose:Replacement merge: LineBased]
								[T -> setExitByEscEnabled(boolean-boolean) : MethodDecl "public void setExitByEscEnabled(boolean isExitByEscEnabled) {   this.isExitByEscEnabled = isExitByEscEnabled;  }" compose:Replacement merge: LineBased]
					[NT -> OpenFile.java : Java-File]
					[NT -> DecompilerLinkProvider.java : Java-File]
					[NT -> WindowPosition.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.Component{ImportPackage} : ImportDeclaration "import java.awt.Component;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> javax.swing.JDialog{ImportPackage} : ImportDeclaration "import javax.swing.JDialog;" compose:Replacement merge: Default]
							[T -> javax.swing.JFrame{ImportPackage} : ImportDeclaration "import javax.swing.JFrame;" compose:Replacement merge: Default]
							[NT -> WindowPosition : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> WindowPosition : Id "WindowPosition" compose:Replacement merge: Default]
								[T -> isFullScreen : FieldDecl "private boolean isFullScreen;" compose:Replacement merge: SemanticConflict]
								[T -> windowWidth : FieldDecl "private int windowWidth;" compose:Replacement merge: SemanticConflict]
								[T -> windowHeight : FieldDecl "private int windowHeight;" compose:Replacement merge: SemanticConflict]
								[T -> windowX : FieldDecl "private int windowX;" compose:Replacement merge: SemanticConflict]
								[T -> windowY : FieldDecl "private int windowY;" compose:Replacement merge: SemanticConflict]
								[T -> readPositionFromWindow(JFrame-JFrame) : MethodDecl "public void readPositionFromWindow(JFrame window) {   isFullScreen = (window.getExtendedState() == JFrame.MAXIMIZED_BOTH);   if (!isFullScreen) {    this.readPositionFromComponent(window);   }  }" compose:Replacement merge: LineBased]
								[T -> readPositionFromDialog(JDialog-JDialog) : MethodDecl "public void readPositionFromDialog(JDialog dialog) {   this.readPositionFromComponent(dialog);  }" compose:Replacement merge: LineBased]
								[T -> readPositionFromComponent(Component-Component) : MethodDecl "private void readPositionFromComponent(Component component) {   isFullScreen = false;   windowWidth = component.getWidth();   windowHeight = component.getHeight();   windowX = component.getX();   windowY = component.getY();  }" compose:Replacement merge: LineBased]
								[T -> isSavedWindowPositionValid({FormalParametersInternal}) : MethodDecl "public boolean isSavedWindowPositionValid() {   if (isFullScreen) {    return true;   }   if (windowWidth < 100 || windowHeight < 100) {    return false;   }   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (windowWidth > screenSize.width + 50 || windowHeight > screenSize.height + 50) {    return false;   }   if (windowY < -20 || windowY > screenSize.height - 50 ||     windowX < 50 - windowWidth || windowX > screenSize.width - 50) {    return false;   }   return true;  }" compose:Replacement merge: LineBased]
								[T -> isFullScreen({FormalParametersInternal}) : MethodDecl "public boolean isFullScreen() {   return isFullScreen;  }" compose:Replacement merge: LineBased]
								[T -> setFullScreen(boolean-boolean) : MethodDecl "public void setFullScreen(boolean isFullScreen) {   this.isFullScreen = isFullScreen;  }" compose:Replacement merge: LineBased]
								[T -> getWindowWidth({FormalParametersInternal}) : MethodDecl "public int getWindowWidth() {   return windowWidth;  }" compose:Replacement merge: LineBased]
								[T -> setWindowWidth(int-int) : MethodDecl "public void setWindowWidth(int windowWidth) {   this.windowWidth = windowWidth;  }" compose:Replacement merge: LineBased]
								[T -> getWindowHeight({FormalParametersInternal}) : MethodDecl "public int getWindowHeight() {   return windowHeight;  }" compose:Replacement merge: LineBased]
								[T -> setWindowHeight(int-int) : MethodDecl "public void setWindowHeight(int windowHeight) {   this.windowHeight = windowHeight;  }" compose:Replacement merge: LineBased]
								[T -> getWindowX({FormalParametersInternal}) : MethodDecl "public int getWindowX() {   return windowX;  }" compose:Replacement merge: LineBased]
								[T -> setWindowX(int-int) : MethodDecl "public void setWindowX(int windowX) {   this.windowX = windowX;  }" compose:Replacement merge: LineBased]
								[T -> getWindowY({FormalParametersInternal}) : MethodDecl "public int getWindowY() {   return windowY;  }" compose:Replacement merge: LineBased]
								[T -> setWindowY(int-int) : MethodDecl "public void setWindowY(int windowY) {   this.windowY = windowY;  }" compose:Replacement merge: LineBased]
					[NT -> MainWindow.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> java.awt.BorderLayout{ImportPackage} : ImportDeclaration "import java.awt.BorderLayout;" compose:Replacement merge: Default]
							[T -> java.awt.Dimension{ImportPackage} : ImportDeclaration "import java.awt.Dimension;" compose:Replacement merge: Default]
							[T -> java.awt.Toolkit{ImportPackage} : ImportDeclaration "import java.awt.Toolkit;" compose:Replacement merge: Default]
							[T -> java.awt.dnd.DropTarget{ImportPackage} : ImportDeclaration "import java.awt.dnd.DropTarget;" compose:Replacement merge: Default]
							[T -> java.awt.event.ActionEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ActionEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.ComponentAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.ComponentAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.ComponentEvent{ImportPackage} : ImportDeclaration "import java.awt.event.ComponentEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.KeyEvent{ImportPackage} : ImportDeclaration "import java.awt.event.KeyEvent;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowAdapter{ImportPackage} : ImportDeclaration "import java.awt.event.WindowAdapter;" compose:Replacement merge: Default]
							[T -> java.awt.event.WindowEvent{ImportPackage} : ImportDeclaration "import java.awt.event.WindowEvent;" compose:Replacement merge: Default]
							[T -> java.io.BufferedReader{ImportPackage} : ImportDeclaration "import java.io.BufferedReader;" compose:Replacement merge: Default]
							[T -> java.io.File{ImportPackage} : ImportDeclaration "import java.io.File;" compose:Replacement merge: Default]
							[T -> java.io.IOException{ImportPackage} : ImportDeclaration "import java.io.IOException;" compose:Replacement merge: Default]
							[T -> java.io.InputStreamReader{ImportPackage} : ImportDeclaration "import java.io.InputStreamReader;" compose:Replacement merge: Default]
							[T -> javax.swing.AbstractAction{ImportPackage} : ImportDeclaration "import javax.swing.AbstractAction;" compose:Replacement merge: Default]
							[T -> javax.swing.Action{ImportPackage} : ImportDeclaration "import javax.swing.Action;" compose:Replacement merge: Default]
							[T -> javax.swing.BoxLayout{ImportPackage} : ImportDeclaration "import javax.swing.BoxLayout;" compose:Replacement merge: Default]
							[T -> javax.swing.JComponent{ImportPackage} : ImportDeclaration "import javax.swing.JComponent;" compose:Replacement merge: Default]
							[T -> javax.swing.JFrame{ImportPackage} : ImportDeclaration "import javax.swing.JFrame;" compose:Replacement merge: Default]
							[T -> javax.swing.JLabel{ImportPackage} : ImportDeclaration "import javax.swing.JLabel;" compose:Replacement merge: Default]
							[T -> javax.swing.JPanel{ImportPackage} : ImportDeclaration "import javax.swing.JPanel;" compose:Replacement merge: Default]
							[T -> javax.swing.JProgressBar{ImportPackage} : ImportDeclaration "import javax.swing.JProgressBar;" compose:Replacement merge: Default]
							[T -> javax.swing.KeyStroke{ImportPackage} : ImportDeclaration "import javax.swing.KeyStroke;" compose:Replacement merge: Default]
							[T -> javax.swing.border.BevelBorder{ImportPackage} : ImportDeclaration "import javax.swing.border.BevelBorder;" compose:Replacement merge: Default]
							[T -> org.fife.ui.rsyntaxtextarea.RSyntaxTextArea{ImportPackage} : ImportDeclaration "import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;" compose:Replacement merge: Default]
							[NT -> MainWindow : ClassDeclaration]
								[T -> - : Modifiers "public" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> MainWindow : Id "MainWindow" compose:Replacement merge: Default]
								[T -> - : ExtendsList "extends JFrame" compose:Replacement merge: Default]
								[T -> serialVersionUID : FieldDecl "private static final long serialVersionUID = 1L;" compose:Replacement merge: SemanticConflict]
								[T -> TITLE : FieldDecl "private static final String TITLE = "Luyten";" compose:Replacement merge: SemanticConflict]
								[T -> model : FieldDecl "private Model model;" compose:Replacement merge: SemanticConflict]
								[T -> bar : FieldDecl "private JProgressBar bar;" compose:Replacement merge: SemanticConflict]
								[T -> label : FieldDecl "private JLabel label;" compose:Replacement merge: SemanticConflict]
								[T -> findBox : FieldDecl "private FindBox findBox;" compose:Replacement merge: SemanticConflict]
								[T -> configSaver : FieldDecl "private ConfigSaver configSaver;" compose:Replacement merge: SemanticConflict]
								[T -> windowPosition : FieldDecl "private WindowPosition windowPosition;" compose:Replacement merge: SemanticConflict]
								[T -> luytenPrefs : FieldDecl "private LuytenPreferences luytenPrefs;" compose:Replacement merge: SemanticConflict]
								[T -> fileDialog : FieldDecl "private FileDialog fileDialog;" compose:Replacement merge: SemanticConflict]
								[T -> fileSaver : FieldDecl "private FileSaver fileSaver;" compose:Replacement merge: SemanticConflict]
								[T -> MainWindow(File-File) : ConstructorDecl "public MainWindow(File fileFromCommandLine) {   configSaver = ConfigSaver.getLoadedInstance();   windowPosition = configSaver.getMainWindowPosition();   luytenPrefs = configSaver.getLuytenPreferences();    MainMenuBar mainMenuBar = new MainMenuBar(this);   this.setJMenuBar(mainMenuBar);    this.adjustWindowPositionBySavedState();   this.setHideFindBoxOnMainWindowFocus();   this.setQuitOnWindowClosing();   this.setTitle(TITLE);    JPanel pane = new JPanel();   pane.setBorder(new BevelBorder(BevelBorder.LOWERED));   pane.setPreferredSize(new Dimension(this.getWidth(), 24));   pane.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));    JPanel panel1 = new JPanel();   label = new JLabel(" ");   label.setHorizontalAlignment(JLabel.LEFT);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setBorder(new BevelBorder(BevelBorder.LOWERED));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(label);   pane.add(panel1);    panel1 = new JPanel();   bar = new JProgressBar();   bar.setIndeterminate(true);   bar.setOpaque(false);   bar.setVisible(false);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(bar);   pane.add(panel1);    model = new Model(this);   this.getContentPane().add(model);   this.add(pane, BorderLayout.SOUTH);    if (fileFromCommandLine != null) {    model.loadFile(fileFromCommandLine);   }    try {    DropTarget dt = new DropTarget();    dt.addDropTargetListener(new DropListener(this));    this.setDropTarget(dt);   } catch (Exception e) {    e.printStackTrace();   }    fileDialog = new FileDialog(this);   fileSaver = new FileSaver(bar, label);    this.setExitOnEscWhenEnabled(model);    if (fileFromCommandLine == null || fileFromCommandLine.getName().toLowerCase().endsWith(".jar") ||     fileFromCommandLine.getName().toLowerCase().endsWith(".zip")) {    model.startWarmUpThread();   }  }" compose:Replacement merge: LineBased]
								[T -> onOpenFileMenu({FormalParametersInternal}) : MethodDecl "public void onOpenFileMenu() {   File selectedFile = fileDialog.doOpenDialog();   if (selectedFile != null) {    this.getModel().loadFile(selectedFile);   }  }" compose:Replacement merge: LineBased]
								[T -> onCloseFileMenu({FormalParametersInternal}) : MethodDecl "public void onCloseFileMenu() {   this.getModel().closeFile();  }" compose:Replacement merge: LineBased]
								[T -> onSaveAsMenu({FormalParametersInternal}) : MethodDecl "public void onSaveAsMenu() {   RSyntaxTextArea pane = this.getModel().getCurrentTextArea();   if (pane == null)    return;   String tabTitle = this.getModel().getCurrentTabTitle();   if (tabTitle == null)    return;    String recommendedFileName = tabTitle.replace(".class", ".java");   File selectedFile = fileDialog.doSaveDialog(recommendedFileName);   if (selectedFile != null) {    fileSaver.saveText(pane.getText(), selectedFile);   }  }" compose:Replacement merge: LineBased]
								[T -> onSaveAllMenu({FormalParametersInternal}) : MethodDecl "public void onSaveAllMenu() {   File openedFile = this.getModel().getOpenedFile();   if (openedFile == null)    return;    String fileName = openedFile.getName();   if (fileName.endsWith(".class")) {    fileName = fileName.replace(".class", ".java");   } else if (fileName.toLowerCase().endsWith(".jar")) {    fileName = "decompiled-" + fileName.replaceAll("\\.[jJ][aA][rR]", ".zip");   } else {    fileName = "saved-" + fileName;   }    File selectedFileToSave = fileDialog.doSaveAllDialog(fileName);   if (selectedFileToSave != null) {    fileSaver.saveAllDecompiled(openedFile, selectedFileToSave);   }  }" compose:Replacement merge: LineBased]
								[T -> onExitMenu({FormalParametersInternal}) : MethodDecl "public void onExitMenu() {   quit();  }" compose:Replacement merge: LineBased]
								[T -> onSelectAllMenu({FormalParametersInternal}) : MethodDecl "public void onSelectAllMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     pane.requestFocusInWindow();     pane.setSelectionStart(0);     pane.setSelectionEnd(pane.getText().length());    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onFindMenu({FormalParametersInternal}) : MethodDecl "public void onFindMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     if (findBox == null)      findBox = new FindBox(this);     findBox.showFindBox();    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onLegalMenu({FormalParametersInternal}) : MethodDecl "public void onLegalMenu() {   new Thread() {    public void run() {     try {      bar.setVisible(true);      String legalStr = getLegalStr();      MainWindow.this.getModel().showLegal(legalStr);     } finally {      bar.setVisible(false);     }    }   }.start();  }" compose:Replacement merge: LineBased]
								[T -> getLegalStr({FormalParametersInternal}) : MethodDecl "private String getLegalStr() {   StringBuilder sb = new StringBuilder();   try {    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/Procyon.License.txt")));    String line;    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");    sb.append("\n\n\n\n\n");    reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/RSyntaxTextArea.License.txt")));    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");   } catch (IOException e) {    e.printStackTrace();   }   return sb.toString();  }" compose:Replacement merge: LineBased]
								[T -> onThemesChanged({FormalParametersInternal}) : MethodDecl "public void onThemesChanged() {   this.getModel().changeTheme(luytenPrefs.getThemeXml());  }" compose:Replacement merge: LineBased]
								[T -> onSettingsChanged({FormalParametersInternal}) : MethodDecl "public void onSettingsChanged() {   this.getModel().updateOpenClasses();  }" compose:Replacement merge: LineBased]
								[T -> onTreeSettingsChanged({FormalParametersInternal}) : MethodDecl "public void onTreeSettingsChanged() {   this.getModel().updateTree();  }" compose:Replacement merge: LineBased]
								[T -> onFileDropped(File-File) : MethodDecl "public void onFileDropped(File file) {   if (file != null) {    this.getModel().loadFile(file);   }  }" compose:Replacement merge: LineBased]
								[T -> onFileLoadEnded(File-File-boolean-boolean) : MethodDecl "public void onFileLoadEnded(File file, boolean isSuccess) {   try {    if (file != null && isSuccess) {     this.setTitle(TITLE + " - " + file.getName());    } else {     this.setTitle(TITLE);    }   } catch (Exception e) {    e.printStackTrace();   }  }" compose:Replacement merge: LineBased]
								[T -> onNavigationRequest(String-String) : MethodDecl "public void onNavigationRequest(String uniqueStr) {   this.getModel().navigateTo(uniqueStr);  }" compose:Replacement merge: LineBased]
								[T -> adjustWindowPositionBySavedState({FormalParametersInternal}) : MethodDecl "private void adjustWindowPositionBySavedState() {   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (!windowPosition.isSavedWindowPositionValid()) {    final Dimension center = new Dimension((int) (screenSize.width * 0.75), (int) (screenSize.height * 0.75));    final int x = (int) (center.width * 0.2);    final int y = (int) (center.height * 0.2);    this.setBounds(x, y, center.width, center.height);    } else if (windowPosition.isFullScreen()) {    int heightMinusTray = screenSize.height;    if (screenSize.height > 30)     heightMinusTray -= 30;    this.setBounds(0, 0, screenSize.width, heightMinusTray);    this.setExtendedState(JFrame.MAXIMIZED_BOTH);     this.addComponentListener(new ComponentAdapter() {     @Override     public void componentResized(ComponentEvent e) {      if (MainWindow.this.getExtendedState() != JFrame.MAXIMIZED_BOTH) {       windowPosition.setFullScreen(false);       if (windowPosition.isSavedWindowPositionValid()) {        MainWindow.this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),          windowPosition.getWindowWidth(), windowPosition.getWindowHeight());       }       MainWindow.this.removeComponentListener(this);      }     }    });    } else {    this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),      windowPosition.getWindowWidth(), windowPosition.getWindowHeight());   }  }" compose:Replacement merge: LineBased]
								[T -> setHideFindBoxOnMainWindowFocus({FormalParametersInternal}) : MethodDecl "private void setHideFindBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findBox != null && findBox.isVisible()) {      findBox.setVisible(false);     }    }   });  }" compose:Replacement merge: LineBased]
								[T -> setQuitOnWindowClosing({FormalParametersInternal}) : MethodDecl "private void setQuitOnWindowClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowClosing(WindowEvent e) {     quit();    }   });  }" compose:Replacement merge: LineBased]
								[T -> quit({FormalParametersInternal}) : MethodDecl "private void quit() {   try {    windowPosition.readPositionFromWindow(this);    configSaver.saveConfig();   } catch (Exception exc) {    exc.printStackTrace();   } finally {    try {     this.dispose();    } finally {     System.exit(0);    }   }  }" compose:Replacement merge: LineBased]
								[T -> setExitOnEscWhenEnabled(JComponent-JComponent) : MethodDecl "private void setExitOnEscWhenEnabled(JComponent mainComponent) {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     if (luytenPrefs.isExitByEscEnabled()) {      quit();     }    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   mainComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(escapeKeyStroke, "ESCAPE");   mainComponent.getActionMap().put("ESCAPE", escapeAction);  }" compose:Replacement merge: LineBased]
								[T -> getModel({FormalParametersInternal}) : MethodDecl "public Model getModel() {   return model;  }" compose:Replacement merge: LineBased]
								[T -> getBar({FormalParametersInternal}) : MethodDecl "public JProgressBar getBar() {   return bar;  }" compose:Replacement merge: LineBased]
								[T -> getLabel({FormalParametersInternal}) : MethodDecl "public JLabel getLabel() {   return label;  }" compose:Replacement merge: LineBased]
					[NT -> LuytenTypeLoader.java : Java-File]
						[NT -> - : CompilationUnit]
							[T -> - : PackageDeclaration "package com.modcrafting.luyten;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.InputTypeLoader{ImportPackage} : ImportDeclaration "import com.strobel.assembler.InputTypeLoader;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.Buffer{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.Buffer;" compose:Replacement merge: Default]
							[T -> com.strobel.assembler.metadata.ITypeLoader{ImportPackage} : ImportDeclaration "import com.strobel.assembler.metadata.ITypeLoader;" compose:Replacement merge: Default]
							[T -> java.util.ArrayList{ImportPackage} : ImportDeclaration "import java.util.ArrayList;" compose:Replacement merge: Default]
							[T -> java.util.List{ImportPackage} : ImportDeclaration "import java.util.List;" compose:Replacement merge: Default]
							[NT -> LuytenTypeLoader : ClassDeclaration]
								[T -> - : Modifiers "public final" compose:Replacement merge: SemanticConflict]
								[T -> - : ClassOrInterface1 "class" compose:Replacement merge: Default]
								[T -> LuytenTypeLoader : Id "LuytenTypeLoader" compose:Replacement merge: Default]
								[T -> ImplList : ImplementsList "implements ITypeLoader" compose:Replacement merge: SemanticConflict]
								[T -> _typeLoaders : FieldDecl "private final List<ITypeLoader> _typeLoaders;" compose:Replacement merge: SemanticConflict]
								[T -> LuytenTypeLoader({FormalParametersInternal}) : ConstructorDecl "public LuytenTypeLoader() {         _typeLoaders = new ArrayList<ITypeLoader>();         _typeLoaders.add(new InputTypeLoader());     }" compose:Replacement merge: LineBased]
								[T -> getTypeLoaders({FormalParametersInternal}) : MethodDecl "public final List<ITypeLoader> getTypeLoaders() {         return _typeLoaders;     }" compose:Replacement merge: LineBased]
								[T -> tryLoadType(String-String-Buffer-Buffer) : MethodDecl "@Override     public boolean tryLoadType(final String internalName, final Buffer buffer) {         for (final ITypeLoader typeLoader : _typeLoaders) {             if (typeLoader.tryLoadType(internalName, buffer)) {                 return true;             }              buffer.reset();         }          return false;     }" compose:Replacement merge: LineBased]
[NT -> left : Feature]
	[NT -> src : Folder]
		[NT -> us : Folder]
			[NT -> deathmarine : Folder]
				[NT -> luyten : Folder]
					[NT -> FileDialog.java.merge : .java.merge-File]
						[T -> FileDialog.java : .java-Content "package us.deathmarine.luyten;  import java.awt.Component; import java.io.File; import javax.swing.JFileChooser; import javax.swing.filechooser.FileFilter;  /**  * FileChoosers for Open and Save  */ public class FileDialog {  private ConfigSaver configSaver;  private LuytenPreferences luytenPrefs;  private Component parent;  private JFileChooser fcOpen;  private JFileChooser fcSave;  private JFileChooser fcSaveAll;   public FileDialog(Component parent) {   this.parent = parent;   configSaver = ConfigSaver.getLoadedInstance();   luytenPrefs = configSaver.getLuytenPreferences();    new Thread() {    public void run() {     initOpenDialog();     initSaveDialog();     initSaveAllDialog();    };   }.start();  }   public File doOpenDialog() {   File selectedFile = null;   initOpenDialog();    retrieveOpenDialogDir(fcOpen);   int returnVal = fcOpen.showOpenDialog(parent);   saveOpenDialogDir(fcOpen);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcOpen.getSelectedFile();   }   return selectedFile;  }   public File doSaveDialog(String recommendedFileName) {   File selectedFile = null;   initSaveDialog();    retrieveSaveDialogDir(fcSave);   fcSave.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSave.showSaveDialog(parent);   saveSaveDialogDir(fcSave);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSave.getSelectedFile();   }   return selectedFile;  }   public File doSaveAllDialog(String recommendedFileName) {   File selectedFile = null;   initSaveAllDialog();      retrieveSaveDialogDir(fcSaveAll);   fcSaveAll.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSaveAll.showSaveDialog(parent);   saveSaveDialogDir(fcSaveAll);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSaveAll.getSelectedFile();   }   return selectedFile;  }   public synchronized void initOpenDialog() {   if (fcOpen == null) {    fcOpen = createFileChooser("*.jar", "*.zip", "*.class");    retrieveOpenDialogDir(fcOpen);   }  }   public synchronized void initSaveDialog() {   if (fcSave == null) {    fcSave = createFileChooser("*.txt", "*.java");    retrieveSaveDialogDir(fcSave);   }  }   public synchronized void initSaveAllDialog() {   if (fcSaveAll == null) {    fcSaveAll = createFileChooser("*.jar", "*.zip");    retrieveSaveDialogDir(fcSaveAll);   }  }   private JFileChooser createFileChooser(String... fileFilters) {   JFileChooser fc = new JFileChooser();   for (String fileFilter : fileFilters) {    fc.addChoosableFileFilter(new FileChooserFileFilter(fileFilter));   }   fc.setFileSelectionMode(JFileChooser.FILES_ONLY);   fc.setMultiSelectionEnabled(false);   return fc;  }   public class FileChooserFileFilter extends FileFilter {   String objType;    public FileChooserFileFilter(String string) {    objType = string;   }    @Override   public boolean accept(File f) {    if (f.isDirectory())     return false;    return f.getName().toLowerCase().endsWith(objType.substring(1));   }    @Override   public String getDescription() {    return objType;   }  }   private void retrieveOpenDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileOpenCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void saveOpenDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileOpenCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void retrieveSaveDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileSaveCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void saveSaveDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileSaveCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  } } " compose:StringConcatenation merge: LineBased]
					[NT -> DropListener.java.merge : .java.merge-File]
						[T -> DropListener.java : .java-Content "package us.deathmarine.luyten;  import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.dnd.DnDConstants; import java.awt.dnd.DropTargetDragEvent; import java.awt.dnd.DropTargetDropEvent; import java.awt.dnd.DropTargetEvent; import java.awt.dnd.DropTargetListener; import java.io.BufferedReader; import java.io.File; import java.io.Reader; import java.net.URI; import java.util.ArrayList; import java.util.List;  /**  * Drag-Drop (only MainWindow should be called from here)  */ public class DropListener implements DropTargetListener {  private MainWindow mainWindow;   public DropListener(MainWindow mainWindow) {   this.mainWindow = mainWindow;  }   @SuppressWarnings("unchecked")  @Override  public void drop(DropTargetDropEvent event) {   event.acceptDrop(DnDConstants.ACTION_COPY);   Transferable transferable = event.getTransferable();   if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    for (DataFlavor flavor : flavors) {     try {      if (flavor.isFlavorJavaFileListType()) {       List<File> files = (List<File>) transferable         .getTransferData(flavor);       if (files.size() > 1) {        event.rejectDrop();        return;       }       if (files.size() == 1) {        mainWindow.onFileDropped(files.get(0));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }    event.dropComplete(true);   } else {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    boolean handled = false;    for (int zz = 0; zz < flavors.length; zz++) {     if (flavors[zz].isRepresentationClassReader()) {      try {       Reader reader = flavors[zz].getReaderForText(transferable);       BufferedReader br = new BufferedReader(reader);       List<File> list = new ArrayList<File>();       String line = null;       while ((line = br.readLine()) != null) {        try {         if (new String("" + (char) 0).equals(line))          continue;         File file = new File(new URI(line));         list.add(file);        } catch (Exception ex) {         ex.printStackTrace();        }       }       if (list.size() > 1) {        event.rejectDrop();        return;       }       if (list.size() == 1) {        mainWindow.onFileDropped(list.get(0));       }       event.getDropTargetContext().dropComplete(true);       handled = true;      } catch (Exception e) {       e.printStackTrace();      }      break;     }    }    if (!handled) {     event.rejectDrop();    }   }   }   @Override  public void dragEnter(DropTargetDragEvent arg0) {}   @Override  public void dragExit(DropTargetEvent arg0) {}   @Override  public void dragOver(DropTargetDragEvent arg0) {}   @Override  public void dropActionChanged(DropTargetDragEvent arg0) {} } " compose:StringConcatenation merge: LineBased]
					[NT -> FileEntryNotFoundException.java.merge : .java.merge-File]
						[T -> FileEntryNotFoundException.java : .java-Content "package us.deathmarine.luyten;  public class FileEntryNotFoundException extends Exception {  private static final long serialVersionUID = 1L;  } " compose:StringConcatenation merge: LineBased]
					[NT -> FileIsBinaryException.java.merge : .java.merge-File]
						[T -> FileIsBinaryException.java : .java-Content "package us.deathmarine.luyten;  public class FileIsBinaryException extends Exception {  private static final long serialVersionUID = 1L;  } " compose:StringConcatenation merge: LineBased]
					[NT -> JarEntryFilter.java.merge : .java.merge-File]
						[T -> JarEntryFilter.java : .java-Content "package us.deathmarine.luyten;  import java.util.ArrayList; import java.util.Enumeration; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.jar.JarEntry; import java.util.jar.JarFile;  public class JarEntryFilter {   private JarFile jfile;   public JarEntryFilter() {}   public JarEntryFilter(JarFile jfile) {   this.jfile = jfile;  }   public List<String> getAllEntriesFromJar() {   List<String> mass = new ArrayList<>();   Enumeration<JarEntry> entries = jfile.entries();   while (entries.hasMoreElements()) {    JarEntry e = entries.nextElement();    if (!e.isDirectory()) {     mass.add(e.getName());    }   }   return mass;  }   public List<String> getEntriesWithoutInnerClasses() {   List<String> mass = new ArrayList<>();   Enumeration<JarEntry> entries = jfile.entries();   Set<String> possibleInnerClasses = new HashSet<String>();   Set<String> baseClasses = new HashSet<String>();    while (entries.hasMoreElements()) {    JarEntry e = entries.nextElement();    if (!e.isDirectory()) {     String entryName = e.getName();      if (entryName != null && entryName.trim().length() > 0) {      entryName = entryName.trim();       if (!entryName.endsWith(".class")) {       mass.add(entryName);        // com/acme/Model$16.class      } else if (entryName.matches(".*[^(/|\\\\)]+\\$[^(/|\\\\)]+$")) {       possibleInnerClasses.add(entryName);       } else {       baseClasses.add(entryName);       mass.add(entryName);      }     }    }   }    // keep Badly$Named but not inner classes   for (String inner : possibleInnerClasses) {     // com/acme/Connection$Conn$1.class -> com/acme/Connection    String innerWithoutTail = inner.replaceAll("\\$[^(/|\\\\)]+\\.class$", "");    if (!baseClasses.contains(innerWithoutTail + ".class")) {     mass.add(inner);    }   }   return mass;  }   public JarFile getJfile() {   return jfile;  }   public void setJfile(JarFile jfile) {   this.jfile = jfile;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Closer.java.merge : .java.merge-File]
						[T -> Closer.java : .java-Content "package us.deathmarine.luyten;  public final class Closer {     public static void tryClose(final AutoCloseable c) {         if (c == null) {             return;         }         try {             c.close();         }         catch (Throwable ignored) {         }     }      public static void tryClose(final AutoCloseable... items) {         if (items == null) {             return;         }         for (AutoCloseable c : items) {             tryClose(c);         }     } } " compose:StringConcatenation merge: LineBased]
					[NT -> Model.java.merge : .java.merge-File]
						[T -> Model.java : .java-Content "package us.deathmarine.luyten;  import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import java.awt.Insets; import java.awt.Toolkit; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.io.StringWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Enumeration; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Set; import java.util.TreeMap; import java.util.TreeSet; import java.util.jar.JarEntry; import java.util.jar.JarFile; import java.util.regex.Matcher; import java.util.regex.Pattern; import javax.swing.BorderFactory; import javax.swing.BoxLayout; import javax.swing.ImageIcon; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.JScrollPane; import javax.swing.JSplitPane; import javax.swing.JTabbedPane; import javax.swing.JTree; import javax.swing.SwingUtilities; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.DefaultTreeModel; import javax.swing.tree.TreeNode; import javax.swing.tree.TreePath; import javax.swing.tree.TreeSelectionModel; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rsyntaxtextarea.Theme; import org.fife.ui.rtextarea.RTextScrollPane; import com.strobel.assembler.InputTypeLoader; import com.strobel.assembler.metadata.ITypeLoader; import com.strobel.assembler.metadata.JarTypeLoader; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.core.VerifyArgument; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput;  /**  * Jar-level model  */ public class Model extends JSplitPane {  private static final long serialVersionUID = 6896857630400910200L;   private static final long MAX_JAR_FILE_SIZE_BYTES = 1_000_000_000;  private static final long MAX_UNPACKED_FILE_SIZE_BYTES = 1_000_000;      private static LuytenTypeLoader typeLoader = new LuytenTypeLoader();     public static MetadataSystem metadataSystem = new MetadataSystem(typeLoader);   private JTree tree;  private JTabbedPane house;  private File file;  private DecompilerSettings settings;  private DecompilationOptions decompilationOptions;  private Theme theme;  private MainWindow mainWindow;  private JProgressBar bar;  private JLabel label;  private HashSet<OpenFile> hmap = new HashSet<OpenFile>();  private Set<String> treeExpansionState;  private boolean open = false;  private State state;  private ConfigSaver configSaver;  private LuytenPreferences luytenPrefs;   public Model(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.bar = mainWindow.getBar();   this.label = mainWindow.getLabel();    configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    try {    String themeXml = luytenPrefs.getThemeXml();    theme = Theme.load(getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + themeXml));   } catch (Exception e1) {    try {     e1.printStackTrace();     String themeXml = LuytenPreferences.DEFAULT_THEME_XML;     luytenPrefs.setThemeXml(themeXml);     theme = Theme.load(getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + themeXml));    } catch (Exception e2) {     e2.printStackTrace();    }   }    tree = new JTree();   tree.setModel(new DefaultTreeModel(null));   tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);   tree.setCellRenderer(new CellRenderer());   TreeListener tl = new TreeListener();   tree.addMouseListener(tl);    JPanel panel2 = new JPanel();   panel2.setLayout(new BoxLayout(panel2, 1));   panel2.setBorder(BorderFactory.createTitledBorder("Structure"));   panel2.add(new JScrollPane(tree));    house = new JTabbedPane();   house.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);   house.addChangeListener(new TabChangeListener());    JPanel panel = new JPanel();   panel.setLayout(new BoxLayout(panel, 1));   panel.setBorder(BorderFactory.createTitledBorder("Code"));   panel.add(house);   this.setOrientation(JSplitPane.HORIZONTAL_SPLIT);   this.setDividerLocation(250 % mainWindow.getWidth());   this.setLeftComponent(panel2);   this.setRightComponent(panel);    decompilationOptions = new DecompilationOptions();   decompilationOptions.setSettings(settings);   decompilationOptions.setFullDecompilation(true);  }   public void showLegal(String legalStr) {   OpenFile open = new OpenFile("Legal", "*/Legal", legalStr, theme);   hmap.add(open);   addOrSwitchToTab(open);  }   private void addOrSwitchToTab(OpenFile open) {   String title = open.name;   RTextScrollPane rTextScrollPane = open.scrollPane;   if (house.indexOfTab(title) < 0) {    house.addTab(title, rTextScrollPane);    house.setSelectedIndex(house.indexOfTab(title));    int index = house.indexOfTab(title);    Tab ct = new Tab(title);    ct.getButton().addMouseListener(new CloseTab(title));    house.setTabComponentAt(index, ct);   } else {    house.setSelectedIndex(house.indexOfTab(title));   }  }   private void closeOpenTab(int index) {   RTextScrollPane co = (RTextScrollPane) house.getComponentAt(index);   RSyntaxTextArea pane = (RSyntaxTextArea) co.getViewport().getView();   OpenFile open = null;   for (OpenFile file : hmap)    if (pane.equals(file.textArea))     open = file;   if (open != null && hmap.contains(open))    hmap.remove(open);   house.remove(co);  }   private String getName(String path) {   if (path == null)    return "";   int i = path.lastIndexOf("/");   if (i == -1)    i = path.lastIndexOf("\\");   if (i != -1)    return path.substring(i + 1);   return path;  }   private class TreeListener extends MouseAdapter {   @Override   public void mousePressed(MouseEvent event) {    boolean isClickCountMatches = (event.getClickCount() == 1 && luytenPrefs.isSingleClickOpenEnabled())      || (event.getClickCount() == 2 && !luytenPrefs.isSingleClickOpenEnabled());    if (!isClickCountMatches)     return;     if (!SwingUtilities.isLeftMouseButton(event))     return;     final TreePath trp = tree.getPathForLocation(event.getX(), event.getY());    if (trp == null)     return;     Object lastPathComponent = trp.getLastPathComponent();    boolean isLeaf = (lastPathComponent instanceof TreeNode && ((TreeNode) lastPathComponent).isLeaf());    if (!isLeaf)     return;     new Thread() {     public void run() {      openEntryByTreePath(trp);     }    }.start();   }  }   private void openEntryByTreePath(TreePath trp) {   String name = "";   String path = "";   try {    bar.setVisible(true);    if (trp.getPathCount() > 1) {     for (int i = 1; i < trp.getPathCount(); i++) {      DefaultMutableTreeNode node = (DefaultMutableTreeNode) trp.getPathComponent(i);      TreeNodeUserObject userObject = (TreeNodeUserObject) node.getUserObject();      if (i == trp.getPathCount() - 1) {       name = userObject.getOriginalName();      } else {       path = path + userObject.getOriginalName() + "/";      }     }     path = path + name;      if (file.getName().endsWith(".jar") || file.getName().endsWith(".zip")) {      if (state == null) {       JarFile jfile = new JarFile(file);       ITypeLoader jarLoader = new JarTypeLoader(jfile);        typeLoader.getTypeLoaders().add(jarLoader);       state = new State(file.getCanonicalPath(), file, jfile, jarLoader);      }       JarEntry entry = state.jarFile.getJarEntry(path);      if (entry == null) {       throw new FileEntryNotFoundException();      }      if (entry.getSize() > MAX_UNPACKED_FILE_SIZE_BYTES) {       throw new TooLargeFileException(entry.getSize());      }      String entryName = entry.getName();      if (entryName.endsWith(".class")) {       label.setText("Extracting: " + name);       String internalName = StringUtilities.removeRight(entryName, ".class");       TypeReference type = metadataSystem.lookupType(internalName);       extractClassToTextPane(type, name, path);      } else {       label.setText("Opening: " + name);       try (InputStream in = state.jarFile.getInputStream(entry);) {        extractSimpleFileEntryToTextPane(in, name, path);       }      }     }    } else {     name = file.getName();     path = file.getPath().replaceAll("\\\\", "/");     if (file.length() > MAX_UNPACKED_FILE_SIZE_BYTES) {      throw new TooLargeFileException(file.length());     }     if (name.endsWith(".class")) {      label.setText("Extracting: " + name);      TypeReference type = metadataSystem.lookupType(path);      extractClassToTextPane(type, name, path);     } else {      label.setText("Opening: " + name);      try (InputStream in = new FileInputStream(file);) {       extractSimpleFileEntryToTextPane(in, name, path);      }     }    }    label.setText("Complete");   } catch (FileEntryNotFoundException e) {    label.setText("File not found: " + name);   } catch (FileIsBinaryException e) {    label.setText("Binary resource: " + name);   } catch (TooLargeFileException e) {    label.setText("File is too large: " + name + " - size: " + e.getReadableFileSize());   } catch (Exception e) {    label.setText("Cannot open: " + name);    e.printStackTrace();    JOptionPane.showMessageDialog(null, e.toString(), "Error!", JOptionPane.ERROR_MESSAGE);   } finally {    bar.setVisible(false);   }  }   private void extractClassToTextPane(TypeReference type, String tabTitle, String path) throws Exception {   if (tabTitle == null || tabTitle.trim().length() < 1 || path == null) {    throw new FileEntryNotFoundException();   }   OpenFile sameTitledOpen = null;   for (OpenFile nextOpen : hmap) {    if (tabTitle.equals(nextOpen.name)) {     sameTitledOpen = nextOpen;     break;    }   }   if (sameTitledOpen != null && path.equals(sameTitledOpen.getPath()) &&     type.equals(sameTitledOpen.getType()) && sameTitledOpen.isContentValid()) {    addOrSwitchToTab(sameTitledOpen);    return;   }    // build tab content: do decompilation   String decompiledSource = extractClassToString(type);    // open tab, store type information   if (sameTitledOpen != null) {    sameTitledOpen.setContent(decompiledSource);    sameTitledOpen.setPath(path);    sameTitledOpen.setType(type);    sameTitledOpen.setContentValid(true);    addOrSwitchToTab(sameTitledOpen);   } else {    OpenFile open = new OpenFile(type, tabTitle, path, decompiledSource, theme);    open.setContentValid(true);    hmap.add(open);    addOrSwitchToTab(open);   }  }   private String extractClassToString(TypeReference type) throws Exception {   // synchronized: do not accept changes from menu while running   synchronized (settings) {    TypeDefinition resolvedType = null;    if (type == null || ((resolvedType = type.resolve()) == null)) {     throw new Exception("Unable to resolve type.");    }    StringWriter stringwriter = new StringWriter();    settings.getLanguage().decompileType(resolvedType,      new PlainTextOutput(stringwriter), decompilationOptions);     if (configSaver.isUnicodeReplaceEnabled()) {     String javaCode = stringwriter.toString();     Pattern p = Pattern.compile("\\\\u(\\p{XDigit}{4})");     Matcher m = p.matcher(javaCode);     StringBuffer buf = new StringBuffer(javaCode.length());     while (m.find()) {      String ch = String.valueOf((char) Integer.parseInt(m.group(1), 16));      m.appendReplacement(buf, Matcher.quoteReplacement(ch));     }     m.appendTail(buf);     return buf.toString();    }    return stringwriter.toString();   }  }   private void extractSimpleFileEntryToTextPane(InputStream inputStream, String tabTitle, String path)    throws Exception {   if (inputStream == null || tabTitle == null || tabTitle.trim().length() < 1 || path == null) {    throw new FileEntryNotFoundException();   }   OpenFile sameTitledOpen = null;   for (OpenFile nextOpen : hmap) {    if (tabTitle.equals(nextOpen.name)) {     sameTitledOpen = nextOpen;     break;    }   }   if (sameTitledOpen != null && path.equals(sameTitledOpen.getPath())) {    addOrSwitchToTab(sameTitledOpen);    return;   }    // build tab content   StringBuilder sb = new StringBuilder();   long nonprintableCharactersCount = 0;   try (InputStreamReader inputStreamReader = new InputStreamReader(inputStream);     BufferedReader reader = new BufferedReader(inputStreamReader);) {    String line;    while ((line = reader.readLine()) != null) {     sb.append(line).append("\n");      for (byte nextByte : line.getBytes()) {      if (nextByte <= 0) {       nonprintableCharactersCount++;      }     }     }   }    // guess binary or text   String extension = "." + tabTitle.replaceAll("^[^\\.]*$", "").replaceAll("[^\\.]*\\.", "");   boolean isTextFile = (OpenFile.WELL_KNOWN_TEXT_FILE_EXTENSIONS.contains(extension) ||     nonprintableCharactersCount < sb.length() / 5);   if (!isTextFile) {    throw new FileIsBinaryException();   }    // open tab   if (sameTitledOpen != null) {    sameTitledOpen.setContent(sb.toString());    sameTitledOpen.setPath(path);    addOrSwitchToTab(sameTitledOpen);   } else {    OpenFile open = new OpenFile(tabTitle, path, sb.toString(), theme);    hmap.add(open);    addOrSwitchToTab(open);   }  }   private class TabChangeListener implements ChangeListener {   @Override   public void stateChanged(ChangeEvent e) {    int selectedIndex = house.getSelectedIndex();    if (selectedIndex < 0) {     return;    }    for (OpenFile open : hmap) {     if (house.indexOfTab(open.name) == selectedIndex) {       if (open.getType() != null && !open.isContentValid()) {       updateOpenClass(open);       break;      }      }    }   }  }   public void updateOpenClasses() {   // invalidate all open classes (update will hapen at tab change)   for (OpenFile open : hmap) {    open.setContentValid(false);   }   // ensure not showing old codes   for (OpenFile open : hmap) {    if (open.getType() != null) {     open.setContent("");    }   }   // update the current open tab - if it is a class   for (OpenFile open : hmap) {    if (open.getType() != null && isTabInForeground(open)) {     updateOpenClass(open);     break;    }   }  }   private void updateOpenClass(final OpenFile open) {   if (open.getType() == null) {    return;   }   new Thread(new Runnable() {    @Override    public void run() {     try {      bar.setVisible(true);      label.setText("Extracting: " + open.name);      String decompiledSource = extractClassToString(open.getType());      open.setContent(decompiledSource);      open.setContentValid(true);      label.setText("Complete");     } catch (Exception e) {      label.setText("Error, cannot update: " + open.name);     } finally {      bar.setVisible(false);     }    }   }).start();  }   private boolean isTabInForeground(OpenFile open) {   String title = open.name;   int selectedIndex = house.getSelectedIndex();   return (selectedIndex >= 0 && selectedIndex == house.indexOfTab(title));  }   private final class State implements AutoCloseable {   private final String key;   private final File file;   final JarFile jarFile;   final ITypeLoader typeLoader;    private State(String key, File file, JarFile jarFile, ITypeLoader typeLoader) {    this.key = VerifyArgument.notNull(key, "key");    this.file = VerifyArgument.notNull(file, "file");    this.jarFile = jarFile;    this.typeLoader = typeLoader;   }    @Override   public void close() {    if (typeLoader != null) {     Model.this.typeLoader.getTypeLoaders().remove(typeLoader);    }    Closer.tryClose(jarFile);   }    @SuppressWarnings("unused")   public File getFile() {    return file;   }    @SuppressWarnings("unused")   public String getKey() {    return key;   }  }   private class Tab extends JPanel {   private static final long serialVersionUID = -514663009333644974L;   private JLabel closeButton = new JLabel(new ImageIcon(Toolkit.getDefaultToolkit().getImage(     this.getClass().getResource("/resources/icon_close.png"))));   private JLabel tabTitle = new JLabel();   private String title = "";    public Tab(String t) {    super(new GridBagLayout());    this.setOpaque(false);     this.title = t;    this.tabTitle = new JLabel(title);     this.createTab();   }    public JLabel getButton() {    return this.closeButton;   }    public void createTab() {    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weightx = 1;    this.add(tabTitle, gbc);    gbc.gridx++;    gbc.insets = new Insets(0, 5, 0, 0);    gbc.anchor = GridBagConstraints.EAST;    this.add(closeButton, gbc);   }  }   private class CloseTab extends MouseAdapter {   String title;    public CloseTab(String title) {    this.title = title;   }    @Override   public void mouseClicked(MouseEvent e) {    int index = house.indexOfTab(title);    closeOpenTab(index);   }  }   public DefaultMutableTreeNode loadNodesByNames(DefaultMutableTreeNode node, List<String> originalNames) {   List<TreeNodeUserObject> args = new ArrayList<>();   for (String originalName : originalNames) {    args.add(new TreeNodeUserObject(originalName));   }   return loadNodesByUserObj(node, args);  }   public DefaultMutableTreeNode loadNodesByUserObj(DefaultMutableTreeNode node, List<TreeNodeUserObject> args) {   if (args.size() > 0) {    TreeNodeUserObject name = args.remove(0);    DefaultMutableTreeNode nod = getChild(node, name);    if (nod == null)     nod = new DefaultMutableTreeNode(name);    node.add(loadNodesByUserObj(nod, args));   }   return node;  }   @SuppressWarnings("unchecked")  public DefaultMutableTreeNode getChild(DefaultMutableTreeNode node, TreeNodeUserObject name) {   Enumeration<DefaultMutableTreeNode> entry = node.children();   while (entry.hasMoreElements()) {    DefaultMutableTreeNode nods = entry.nextElement();    if (((TreeNodeUserObject) nods.getUserObject()).getOriginalName().equals(name.getOriginalName())) {     return nods;    }   }   return null;  }   public void loadFile(File file) {   if (open)    closeFile();   this.file = file;   loadTree();  }   public void updateTree() {   TreeUtil treeUtil = new TreeUtil(tree);   treeExpansionState = treeUtil.getExpansionState();   loadTree();  }   public void loadTree() {   new Thread(new Runnable() {    @Override    public void run() {     try {      if (file == null) {       return;      }      tree.setModel(new DefaultTreeModel(null));       if (file.length() > MAX_JAR_FILE_SIZE_BYTES) {       throw new TooLargeFileException(file.length());      }      if (file.getName().endsWith(".zip") || file.getName().endsWith(".jar")) {       JarFile jfile;       jfile = new JarFile(file);       label.setText("Loading: " + jfile.getName());       bar.setVisible(true);        JarEntryFilter jarEntryFilter = new JarEntryFilter(jfile);       List<String> mass = null;       if (luytenPrefs.isFilterOutInnerClassEntries()) {        mass = jarEntryFilter.getEntriesWithoutInnerClasses();       } else {        mass = jarEntryFilter.getAllEntriesFromJar();       }       buildTreeFromMass(mass);        if (state == null) {        ITypeLoader jarLoader = new JarTypeLoader(jfile);        typeLoader.getTypeLoaders().add(jarLoader);        state = new State(file.getCanonicalPath(), file, jfile, jarLoader);       }       open = true;       label.setText("Complete");      } else {       TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));       final DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);       tree.setModel(new DefaultTreeModel(top));       settings.setTypeLoader(new InputTypeLoader());       open = true;       label.setText("Complete");        // open it automatically       new Thread() {        public void run() {         TreePath trp = new TreePath(top.getPath());         openEntryByTreePath(trp);        };       }.start();      }       if (treeExpansionState != null) {       try {        TreeUtil treeUtil = new TreeUtil(tree);        treeUtil.restoreExpanstionState(treeExpansionState);       } catch (Exception exc) {        exc.printStackTrace();       }      }     } catch (TooLargeFileException e) {      label.setText("File is too large: " + file.getName() + " - size: " + e.getReadableFileSize());      closeFile();     } catch (Exception e1) {      e1.printStackTrace();      label.setText("Cannot open: " + file.getName());      closeFile();     } finally {      mainWindow.onFileLoadEnded(file, open);      bar.setVisible(false);     }    }    }).start();  }   private void buildTreeFromMass(List<String> mass) {   if (luytenPrefs.isPackageExplorerStyle()) {    buildFlatTreeFromMass(mass);   } else {    buildDirectoryTreeFromMass(mass);   }  }   private void buildDirectoryTreeFromMass(List<String> mass) {   TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));   DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);   List<String> sort = new ArrayList<String>();   Collections.sort(mass, String.CASE_INSENSITIVE_ORDER);   for (String m : mass)    if (m.contains("META-INF") && !sort.contains(m))     sort.add(m);   Set<String> set = new HashSet<String>();   for (String m : mass) {    if (m.contains("/")) {     set.add(m.substring(0, m.lastIndexOf("/") + 1));    }   }   List<String> packs = Arrays.asList(set.toArray(new String[] {}));   Collections.sort(packs, String.CASE_INSENSITIVE_ORDER);   Collections.sort(packs, new Comparator<String>() {    public int compare(String o1, String o2) {     return o2.split("/").length - o1.split("/").length;    }   });   for (String pack : packs)    for (String m : mass)     if (!m.contains("META-INF") && m.contains(pack)       && !m.replace(pack, "").contains("/"))      sort.add(m);   for (String m : mass)    if (!m.contains("META-INF") && !m.contains("/") && !sort.contains(m))     sort.add(m);   for (String pack : sort) {    LinkedList<String> list = new LinkedList<String>(Arrays.asList(pack.split("/")));    loadNodesByNames(top, list);   }   tree.setModel(new DefaultTreeModel(top));  }   private void buildFlatTreeFromMass(List<String> mass) {   TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));   DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);    TreeMap<String, TreeSet<String>> packages = new TreeMap<>();   HashSet<String> classContainingPackageRoots = new HashSet<>();    Comparator<String> sortByFileExtensionsComparator = new Comparator<String>() {    // (assertion: mass does not contain null elements)    @Override    public int compare(String o1, String o2) {     int comp = o1.replaceAll("[^\\.]*\\.", "").compareTo(o2.replaceAll("[^\\.]*\\.", ""));     if (comp != 0)      return comp;     return o1.compareTo(o2);    }   };    for (String entry : mass) {    String packagePath = "";    String packageRoot = "";    if (entry.contains("/")) {     packagePath = entry.replaceAll("/[^/]*$", "");     packageRoot = entry.replaceAll("/.*$", "");    }    String packageEntry = entry.replace(packagePath + "/", "");    if (!packages.containsKey(packagePath)) {     packages.put(packagePath, new TreeSet<String>(sortByFileExtensionsComparator));    }    packages.get(packagePath).add(packageEntry);    if (!entry.startsWith("META-INF") && packageRoot.trim().length() > 0 &&      entry.matches(".*\\.(class|java|prop|properties)$")) {     classContainingPackageRoots.add(packageRoot);    }   }    // META-INF comes first -> not flat   for (String packagePath : packages.keySet()) {    if (packagePath.startsWith("META-INF")) {     List<String> packagePathElements = Arrays.asList(packagePath.split("/"));     for (String entry : packages.get(packagePath)) {      ArrayList<String> list = new ArrayList<>(packagePathElements);      list.add(entry);      loadNodesByNames(top, list);     }    }   }    // real packages: path starts with a classContainingPackageRoot -> flat   for (String packagePath : packages.keySet()) {    String packageRoot = packagePath.replaceAll("/.*$", "");    if (classContainingPackageRoots.contains(packageRoot)) {     for (String entry : packages.get(packagePath)) {      ArrayList<TreeNodeUserObject> list = new ArrayList<>();      list.add(new TreeNodeUserObject(packagePath, packagePath.replaceAll("/", ".")));      list.add(new TreeNodeUserObject(entry));      loadNodesByUserObj(top, list);     }    }   }    // the rest, not real packages but directories -> not flat   for (String packagePath : packages.keySet()) {    String packageRoot = packagePath.replaceAll("/.*$", "");    if (!classContainingPackageRoots.contains(packageRoot) &&      !packagePath.startsWith("META-INF") && packagePath.length() > 0) {     List<String> packagePathElements = Arrays.asList(packagePath.split("/"));     for (String entry : packages.get(packagePath)) {      ArrayList<String> list = new ArrayList<>(packagePathElements);      list.add(entry);      loadNodesByNames(top, list);     }    }   }    // the default package -> not flat   String packagePath = "";   if (packages.containsKey(packagePath)) {    for (String entry : packages.get(packagePath)) {     ArrayList<String> list = new ArrayList<>();     list.add(entry);     loadNodesByNames(top, list);    }   }   tree.setModel(new DefaultTreeModel(top));  }   public void closeFile() {   for (OpenFile co : hmap) {    int pos = house.indexOfTab(co.name);    if (pos >= 0)     house.remove(pos);   }    final State oldState = state;   Model.this.state = null;   if (oldState != null) {    Closer.tryClose(oldState);   }    hmap.clear();   tree.setModel(new DefaultTreeModel(null));   metadataSystem = new MetadataSystem(typeLoader);   file = null;   treeExpansionState = null;   open = false;   mainWindow.onFileLoadEnded(file, open);  }   public void changeTheme(String xml) {   InputStream in = getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + xml);   try {    if (in != null) {     theme = Theme.load(in);     for (OpenFile f : hmap) {      theme.apply(f.textArea);     }    }   } catch (Exception e1) {    e1.printStackTrace();    JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);   }  }   public File getOpenedFile() {   File openedFile = null;   if (file != null && open) {    openedFile = file;   }   if (openedFile == null) {    label.setText("No open file");   }   return openedFile;  }   public String getCurrentTabTitle() {   String tabTitle = null;   try {    int pos = house.getSelectedIndex();    if (pos >= 0) {     tabTitle = house.getTitleAt(pos);    }   } catch (Exception e1) {    e1.printStackTrace();   }   if (tabTitle == null) {    label.setText("No open tab");   }   return tabTitle;  }   public RSyntaxTextArea getCurrentTextArea() {   RSyntaxTextArea currentTextArea = null;   try {    int pos = house.getSelectedIndex();    if (pos >= 0) {     RTextScrollPane co = (RTextScrollPane) house.getComponentAt(pos);     currentTextArea = (RSyntaxTextArea) co.getViewport().getView();    }   } catch (Exception e1) {    e1.printStackTrace();   }   if (currentTextArea == null) {    label.setText("No open tab");   }   return currentTextArea;  }   public void startWarmUpThread() {   new Thread() {    public void run() {     try {      Thread.sleep(500);      String internalName = FindBox.class.getName();      TypeReference type = metadataSystem.lookupType(internalName);      TypeDefinition resolvedType = null;      if ((type == null) || ((resolvedType = type.resolve()) == null)) {       return;      }      StringWriter stringwriter = new StringWriter();      settings.getLanguage().decompileType(resolvedType,        new PlainTextOutput(stringwriter), decompilationOptions);      String decompiledSource = stringwriter.toString();      OpenFile open = new OpenFile(internalName, "*/" + internalName, decompiledSource, theme);      JTabbedPane pane = new JTabbedPane();      pane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);      pane.addTab("title", open.scrollPane);      pane.setSelectedIndex(pane.indexOfTab("title"));     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  } } " compose:StringConcatenation merge: LineBased]
					[NT -> ConfigSaver.java.merge : .java.merge-File]
						[T -> ConfigSaver.java : .java-Content "package us.deathmarine.luyten;  import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.prefs.Preferences; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.languages.Language; import com.strobel.decompiler.languages.Languages; import com.strobel.decompiler.languages.java.JavaFormattingOptions;  public class ConfigSaver {   private static final String FLATTEN_SWITCH_BLOCKS_ID = "flattenSwitchBlocks";  private static final String FORCE_EXPLICIT_IMPORTS_ID = "forceExplicitImports";  private static final String SHOW_SYNTHETIC_MEMBERS_ID = "showSyntheticMembers";  private static final String EXCLUDE_NESTED_TYPES_ID = "excludeNestedTypes";  private static final String FORCE_EXPLICIT_TYPE_ARGUMENTS_ID = "forceExplicitTypeArguments";  private static final String RETAIN_REDUNDANT_CASTS_ID = "retainRedundantCasts";  private static final String INCLUDE_ERROR_DIAGNOSTICS_ID = "includeErrorDiagnostics";  private static final String UNICODE_REPLACE_ENABLED_ID = "unicodeReplaceEnabled";  private static final String LANGUAGE_NAME_ID = "languageName";   private static final String MAIN_WINDOW_ID_PREFIX = "main";  private static final String FIND_WINDOW_ID_PREFIX = "find";  private static final String WINDOW_IS_FULL_SCREEN_ID = "WindowIsFullScreen";  private static final String WINDOW_WIDTH_ID = "WindowWidth";  private static final String WINDOW_HEIGHT_ID = "WindowHeight";  private static final String WINDOW_X_ID = "WindowX";  private static final String WINDOW_Y_ID = "WindowY";   private DecompilerSettings decompilerSettings;  private WindowPosition mainWindowPosition;  private WindowPosition findWindowPosition;  private LuytenPreferences luytenPreferences;  private boolean isUnicodeReplaceEnabled;   private static ConfigSaver theLoadedInstance;   /**   * Do not instantiate, get the loaded instance   */  private ConfigSaver() {}   public static ConfigSaver getLoadedInstance() {   if (theLoadedInstance == null) {    synchronized (ConfigSaver.class) {     if (theLoadedInstance == null) {      theLoadedInstance = new ConfigSaver();      theLoadedInstance.loadConfig();     }    }   }   return theLoadedInstance;  }   /**   * Do not load, get the loaded instance   */  private void loadConfig() {   decompilerSettings = new DecompilerSettings();   if (decompilerSettings.getFormattingOptions() == null) {    decompilerSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   luytenPreferences = new LuytenPreferences();   mainWindowPosition = new WindowPosition();   findWindowPosition = new WindowPosition();   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);    if(!prefs.get(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName()).equals(      decompilerSettings.getLanguage().getName()))     prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     decompilerSettings.setFlattenSwitchBlocks(prefs.getBoolean(FLATTEN_SWITCH_BLOCKS_ID,      decompilerSettings.getFlattenSwitchBlocks()));    decompilerSettings.setForceExplicitImports(prefs.getBoolean(FORCE_EXPLICIT_IMPORTS_ID,      decompilerSettings.getForceExplicitImports()));    decompilerSettings.setShowSyntheticMembers(prefs.getBoolean(SHOW_SYNTHETIC_MEMBERS_ID,      decompilerSettings.getShowSyntheticMembers()));    decompilerSettings.setExcludeNestedTypes(prefs.getBoolean(EXCLUDE_NESTED_TYPES_ID,      decompilerSettings.getExcludeNestedTypes()));    decompilerSettings.setForceExplicitTypeArguments(prefs.getBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID,      decompilerSettings.getForceExplicitTypeArguments()));    decompilerSettings.setRetainRedundantCasts(prefs.getBoolean(RETAIN_REDUNDANT_CASTS_ID,      decompilerSettings.getRetainRedundantCasts()));    decompilerSettings.setIncludeErrorDiagnostics(prefs.getBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID,      decompilerSettings.getIncludeErrorDiagnostics()));    decompilerSettings.setLanguage(findLanguageByName(prefs.get(LANGUAGE_NAME_ID,      decompilerSettings.getLanguage().getName())));    isUnicodeReplaceEnabled = prefs.getBoolean(UNICODE_REPLACE_ENABLED_ID, false);     mainWindowPosition = loadWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX);    findWindowPosition = loadWindowPosition(prefs, FIND_WINDOW_ID_PREFIX);    luytenPreferences = loadLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }   private WindowPosition loadWindowPosition(Preferences prefs, String windowIdPrefix) {   WindowPosition windowPosition = new WindowPosition();   windowPosition.setFullScreen(prefs.getBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, false));   windowPosition.setWindowWidth(prefs.getInt(windowIdPrefix + WINDOW_WIDTH_ID, 0));   windowPosition.setWindowHeight(prefs.getInt(windowIdPrefix + WINDOW_HEIGHT_ID, 0));   windowPosition.setWindowX(prefs.getInt(windowIdPrefix + WINDOW_X_ID, 0));   windowPosition.setWindowY(prefs.getInt(windowIdPrefix + WINDOW_Y_ID, 0));   return windowPosition;  }   // load preferences by their java variable names  private LuytenPreferences loadLuytenPreferences(Preferences prefs) throws Exception {   LuytenPreferences newLuytenPrefs = new LuytenPreferences();   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object defaultVal = field.get(newLuytenPrefs);     if (field.getType() == String.class) {     String defaultStr = (String) (defaultVal == null ? "" : defaultVal);     field.set(newLuytenPrefs, prefs.get(prefId, defaultStr));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     Boolean defaultBool = (Boolean) (defaultVal == null ? new Boolean(false) : defaultVal);     field.setBoolean(newLuytenPrefs, prefs.getBoolean(prefId, defaultBool));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     Integer defaultInt = (Integer) (defaultVal == null ? new Integer(0) : defaultVal);     field.setInt(newLuytenPrefs, prefs.getInt(prefId, defaultInt));    }   }   return newLuytenPrefs;  }   public void saveConfig() {   // Registry path on Windows Xp:   // HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\modcrafting\luyten   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     prefs.putBoolean(FLATTEN_SWITCH_BLOCKS_ID, decompilerSettings.getFlattenSwitchBlocks());    prefs.putBoolean(FORCE_EXPLICIT_IMPORTS_ID, decompilerSettings.getForceExplicitImports());    prefs.putBoolean(SHOW_SYNTHETIC_MEMBERS_ID, decompilerSettings.getShowSyntheticMembers());    prefs.putBoolean(EXCLUDE_NESTED_TYPES_ID, decompilerSettings.getExcludeNestedTypes());    prefs.putBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID, decompilerSettings.getForceExplicitTypeArguments());    prefs.putBoolean(RETAIN_REDUNDANT_CASTS_ID, decompilerSettings.getRetainRedundantCasts());    prefs.putBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID, decompilerSettings.getIncludeErrorDiagnostics());    prefs.putBoolean(UNICODE_REPLACE_ENABLED_ID, isUnicodeReplaceEnabled);    prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     saveWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX, mainWindowPosition);    saveWindowPosition(prefs, FIND_WINDOW_ID_PREFIX, findWindowPosition);    saveLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }   private void saveWindowPosition(Preferences prefs, String windowIdPrefix, WindowPosition windowPosition) {   prefs.putBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, windowPosition.isFullScreen());   prefs.putInt(windowIdPrefix + WINDOW_WIDTH_ID, windowPosition.getWindowWidth());   prefs.putInt(windowIdPrefix + WINDOW_HEIGHT_ID, windowPosition.getWindowHeight());   prefs.putInt(windowIdPrefix + WINDOW_X_ID, windowPosition.getWindowX());   prefs.putInt(windowIdPrefix + WINDOW_Y_ID, windowPosition.getWindowY());  }   // save preferences by their java variable names  private void saveLuytenPreferences(Preferences prefs) throws Exception {   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object value = field.get(luytenPreferences);     if (field.getType() == String.class) {     prefs.put(prefId, (String) (value == null ? "" : value));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     prefs.putBoolean(prefId, (Boolean) (value == null ? new Boolean(false) : value));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     prefs.putInt(prefId, (Integer) (value == null ? new Integer(0) : value));    }   }  }   private Language findLanguageByName(String languageName) {   if (languageName != null) {     if (languageName.equals(Languages.java().getName())) {     return Languages.java();    } else if (languageName.equals(Languages.bytecode().getName())) {     return Languages.bytecode();    } else if (languageName.equals(Languages.bytecodeAst().getName())) {     return Languages.bytecodeAst();    }     for (Language language : Languages.debug()) {     if (languageName.equals(language.getName())) {      return language;     }    }   }   return Languages.java();  }   public DecompilerSettings getDecompilerSettings() {   return decompilerSettings;  }   public boolean isUnicodeReplaceEnabled(){   return isUnicodeReplaceEnabled;  }   public void setUnicodeReplaceEnabled(boolean value){   isUnicodeReplaceEnabled = value;  }   public WindowPosition getMainWindowPosition() {   return mainWindowPosition;  }   public WindowPosition getFindWindowPosition() {   return findWindowPosition;  }    public LuytenPreferences getLuytenPreferences() {   return luytenPreferences;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Luyten.java.merge : .java.merge-File]
						[T -> Luyten.java : .java-Content "package us.deathmarine.luyten;  import java.io.File; import javax.swing.SwingUtilities; import javax.swing.UIManager;  /**  * Starter, the main class  */ public class Luyten {   public static void main(String[] args) {   try {    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());   } catch (Exception e) {    e.printStackTrace();   }    // for TotalCommander External Viewer setting:   // javaw -jar "c:\Program Files\Luyten\luyten.jar"   // (TC will not complain about temporary file when opening .class from .zip or .jar)   final File fileFromCommandLine = getFileFromCommandLine(args);    SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     MainWindow mainWindow = new MainWindow(fileFromCommandLine);     mainWindow.setVisible(true);    }   });  }   public static File getFileFromCommandLine(String[] args) {   File fileFromCommandLine = null;   try {    if (args.length > 0) {     String realFileName = new File(args[0]).getCanonicalPath();     fileFromCommandLine = new File(realFileName);    }   } catch (Exception e) {    e.printStackTrace();   }   return fileFromCommandLine;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FindAllBox.java.merge : .java.merge-File]
						[T -> FindAllBox.java : .java-Content "package us.deathmarine.luyten;  import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput;  import us.deathmarine.luyten.ConfigSaver; import us.deathmarine.luyten.MainWindow; import us.deathmarine.luyten.Model;  import java.awt.*; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.io.File; import java.io.IOException; import java.io.StringWriter; import java.util.Collections; import java.util.Enumeration; import java.util.jar.JarEntry; import java.util.jar.JarFile;  import javax.swing.*; import javax.swing.GroupLayout.Alignment;  public class FindAllBox extends JDialog {  private static final long serialVersionUID = -4125409760166690462L;  private boolean cancel;  private boolean searching;  private JButton findButton;  private JTextField textField;  JProgressBar progressBar;  private DefaultListModel<String> classesList = new DefaultListModel<String>();  private JLabel statusLabel = new JLabel("");   public FindAllBox() {   progressBar = new JProgressBar(0, 100);   JLabel label = new JLabel("Find What:");   textField = new JTextField();   findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    JList<String> list = new JList<String>(classesList);   list.setSelectionMode(ListSelectionModel.SINGLE_INTERVAL_SELECTION);   list.setLayoutOrientation(JList.VERTICAL_WRAP);   list.setVisibleRowCount(-1);   JScrollPane listScroller = new JScrollPane(list);    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     500);   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    JButton cancelButton = new JButton("Cancel");   cancelButton.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     if (isSearching())      setCancel(true);    }   });    layout.setHorizontalGroup(layout     .createSequentialGroup()     .addComponent(label)     .addGroup(       layout.createParallelGroup(Alignment.LEADING)         .addComponent(statusLabel)         .addComponent(textField)         .addGroup(           layout.createSequentialGroup()             .addGroup(               layout.createParallelGroup(                 Alignment.LEADING)                 .addComponent(                   listScroller)                 .addComponent(                   progressBar))))     .addGroup(       layout.createParallelGroup(Alignment.LEADING)         .addComponent(findButton)         .addComponent(cancelButton))    );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout     .createSequentialGroup()     .addGroup(       layout.createParallelGroup(Alignment.BASELINE)         .addComponent(label).addComponent(textField)         .addComponent(findButton))     .addGroup(       layout.createParallelGroup(Alignment.LEADING).addGroup(         layout.createSequentialGroup().addGroup(           layout.createParallelGroup(             Alignment.BASELINE)             .addComponent(listScroller)             .addComponent(cancelButton))))     .addGroup(layout.createParallelGroup(Alignment.LEADING))     .addComponent(statusLabel).addComponent(progressBar));   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();   this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();   this.setModalityType(Dialog.ModalityType.APPLICATION_MODAL);    this.setName("Find All");   this.setTitle("Find All");  }   private class FindButton extends AbstractAction {   private static final long serialVersionUID = 75954129199541874L;    @Override   public void actionPerformed(ActionEvent event) {    Thread tmp_thread = new Thread() {     public void run() {      setSearching(true);      classesList.clear();      ConfigSaver configSaver = ConfigSaver.getLoadedInstance();      DecompilerSettings settings = configSaver        .getDecompilerSettings();      File inFile = MainWindow.model.getOpenedFile();      try {       JarFile jfile = new JarFile(inFile);       Enumeration<JarEntry> entLength = jfile.entries();       initProgressBar(Collections.list(entLength).size());       Enumeration<JarEntry> ent = jfile.entries();       while (ent.hasMoreElements() && !isCancel()) {        JarEntry entry = ent.nextElement();        setStatus(entry.getName());        if (entry.getName().endsWith(".class")) {         synchronized (settings) {          String internalName = StringUtilities            .removeRight(entry.getName(),              ".class");          TypeReference type = Model.metadataSystem            .lookupType(internalName);          TypeDefinition resolvedType = null;          if (type == null            || ((resolvedType = type.resolve()) == null)) {           throw new Exception(             "Unable to resolve type.");          }          StringWriter stringwriter = new StringWriter();          DecompilationOptions decompilationOptions;          decompilationOptions = new DecompilationOptions();          decompilationOptions.setSettings(settings);          decompilationOptions            .setFullDecompilation(true);          settings.getLanguage().decompileType(            resolvedType,            new PlainTextOutput(stringwriter),            decompilationOptions);          String decompiledSource = stringwriter            .toString().toLowerCase();          if (decompiledSource.contains(textField            .getText().toLowerCase())) {           addClassName(entry.getName());          }         }        }       }       setSearching(false);       if (isCancel()) {        setCancel(false);        setStatus("Cancelled.");       } else {        setStatus("Done.");       }       jfile.close();      } catch (IOException e1) {       e1.printStackTrace();      } catch (Exception e1) {       e1.printStackTrace();      }     }    };    tmp_thread.start();    }   }   private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindAllBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,     0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW)     .put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }   private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance()     .getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(),      windowPosition.getWindowY());   }  }   private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance()       .getFindWindowPosition();     windowPosition.readPositionFromDialog(FindAllBox.this);     if (isSearching())      setCancel(true);    }   });  }   public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();  }   public void hideFindBox() {   this.setVisible(false);  }   public void setStatus(String text) {   if (text.length() > 25) {    this.statusLabel.setText("Searching in file: ..."      + text.substring(text.length() - 25));   } else {    this.statusLabel.setText("Searching in file: " + text);   }    progressBar.setValue(progressBar.getValue() + 1);  }   public void addClassName(String className) {   this.classesList.addElement(className);  }   public void initProgressBar(Integer length) {   progressBar.setMaximum(length);   progressBar.setValue(0);   progressBar.setStringPainted(true);  }   public boolean isCancel() {   return cancel;  }   public void setCancel(boolean cancel) {   this.cancel = cancel;  }   public boolean isSearching() {   return searching;  }   public void setSearching(boolean searching) {   this.searching = searching;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> TreeUtil.java.merge : .java.merge-File]
						[T -> TreeUtil.java : .java-Content "package us.deathmarine.luyten;  import java.util.HashSet; import java.util.Set; import javax.swing.JTree; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.TreePath;  public class TreeUtil {   private JTree tree;   public TreeUtil() {}   public TreeUtil(JTree tree) {   this.tree = tree;  }   public Set<String> getExpansionState() {   Set<String> openedSet = new HashSet<>();   if (tree != null) {    int rowCount = tree.getRowCount();    for (int i = 0; i < rowCount; i++) {     TreePath path = tree.getPathForRow(i);     if (tree.isExpanded(path)) {      String rowPathStr = getRowPathStr(path);      // for switching Package Explorer on/off      openedSet.addAll(getAllParentPathsStr(rowPathStr));     }    }   }   return openedSet;  }   private Set<String> getAllParentPathsStr(String rowPathStr) {   Set<String> parents = new HashSet<>();   parents.add(rowPathStr);   if (rowPathStr.contains("/")) {    String[] pathElements = rowPathStr.split("/");    String path = "";    for (String pathElement : pathElements) {     path = path + pathElement + "/";     parents.add(path);    }   }   return parents;  }   public void restoreExpanstionState(Set<String> expansionState) {   if (tree != null && expansionState != null) {    // tree.getRowCount() changes at tree.expandRow()    for (int i = 0; i < tree.getRowCount(); i++) {     TreePath path = tree.getPathForRow(i);     if (expansionState.contains(getRowPathStr(path))) {      tree.expandRow(i);     }    }   }  }   private String getRowPathStr(TreePath trp) {   String pathStr = "";   if (trp.getPathCount() > 1) {    for (int i = 1; i < trp.getPathCount(); i++) {     DefaultMutableTreeNode node = (DefaultMutableTreeNode) trp.getPathComponent(i);     TreeNodeUserObject userObject = (TreeNodeUserObject) node.getUserObject();     pathStr = pathStr + userObject.getOriginalName() + "/";    }   }   return pathStr;  }   public JTree getTree() {   return tree;  }   public void setTree(JTree tree) {   this.tree = tree;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FindBox.java.merge : .java.merge-File]
						[T -> FindBox.java : .java-Content "package us.deathmarine.luyten;  import java.awt.Dimension; import java.awt.Toolkit; import java.awt.event.ActionEvent; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.BorderFactory; import javax.swing.GroupLayout; import javax.swing.GroupLayout.Alignment; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComponent; import javax.swing.JDialog; import javax.swing.JLabel; import javax.swing.JTextField; import javax.swing.KeyStroke; import javax.swing.SwingConstants; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rtextarea.SearchContext; import org.fife.ui.rtextarea.SearchEngine;  public class FindBox extends JDialog {  private static final long serialVersionUID = -4125409760166690462L;   private JCheckBox mcase;  private JCheckBox regex;  private JCheckBox wholew;  private JCheckBox reverse;  private JButton findButton;  private JTextField textField;  private MainWindow mainWindow;   public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();  }   public void hideFindBox() {   this.setVisible(false);  }   public FindBox(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();    JLabel label = new JLabel("Find What:");   textField = new JTextField();    RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();   if (pane != null) {    textField.setText(pane.getSelectedText());   }   mcase = new JCheckBox("Match Case");   regex = new JCheckBox("Regex");   wholew = new JCheckBox("Whole Words");   reverse = new JCheckBox("Search Backwards");    findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    mcase.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   regex.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   wholew.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   reverse.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     Math.min((int) (screenSize.height * 0.20), 200));   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    layout.setHorizontalGroup(layout.createSequentialGroup()     .addComponent(label)     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(textField)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(mcase)           .addComponent(wholew))         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(regex)           .addComponent(reverse))))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(findButton))     );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(Alignment.BASELINE)       .addComponent(label)       .addComponent(textField)       .addComponent(findButton))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(mcase)           .addComponent(regex))         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(wholew)           .addComponent(reverse))))     );    this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();    this.setName("Find");   this.setTitle("Find");   this.setVisible(true);  }   private class FindButton extends AbstractAction {   private static final long serialVersionUID = 75954129199541874L;    @Override   public void actionPerformed(ActionEvent event) {    if (textField.getText().length() == 0)     return;     RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();    if (pane == null)     return;     SearchContext context = new SearchContext();    context.setSearchFor(textField.getText());    context.setMatchCase(mcase.isSelected());    context.setRegularExpression(regex.isSelected());    context.setSearchForward(!reverse.isSelected());    context.setWholeWord(wholew.isSelected());     if (!SearchEngine.find(pane, context).wasFound()) {     pane.setSelectionStart(0);     pane.setSelectionEnd(0);    }   }   }   private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }   private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(), windowPosition.getWindowY());   }  }   private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();     windowPosition.readPositionFromDialog(FindBox.this);    }   });  } } " compose:StringConcatenation merge: LineBased]
					[NT -> MainMenuBar.java.merge : .java.merge-File]
						[T -> MainMenuBar.java : .java-Content "package us.deathmarine.luyten;  import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.util.Collections; import java.util.HashMap; import java.util.Map; import javax.swing.AbstractAction; import javax.swing.AbstractButton; import javax.swing.ButtonGroup; import javax.swing.ButtonModel; import javax.swing.JCheckBox; import javax.swing.JMenu; import javax.swing.JMenuBar; import javax.swing.JMenuItem; import javax.swing.JOptionPane; import javax.swing.JRadioButtonMenuItem; import javax.swing.KeyStroke; import javax.swing.text.DefaultEditorKit; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.languages.Language; import com.strobel.decompiler.languages.Languages;  /**  * Main menu (only MainWindow should be called from here)  */ public class MainMenuBar extends JMenuBar {  private static final long serialVersionUID = 1L;   private final MainWindow mainWindow;  private final Map<String, Language> languageLookup = new HashMap<String, Language>();   private JCheckBox flattenSwitchBlocks;  private JCheckBox forceExplicitImports;  private JCheckBox forceExplicitTypes;  private JCheckBox showSyntheticMembers;  private JCheckBox excludeNestedTypes;  private JCheckBox retainRedundantCasts;  private JCheckBox unicodeReplacement;  private JCheckBox showDebugInfo;  private JRadioButtonMenuItem java;  private JRadioButtonMenuItem bytecode;  private JRadioButtonMenuItem bytecodeAST;  private ButtonGroup languagesGroup;  private ButtonGroup themesGroup;  private JCheckBox packageExplorerStyle;  private JCheckBox filterOutInnerClassEntries;  private JCheckBox singleClickOpenEnabled;  private JCheckBox exitByEscEnabled;  private DecompilerSettings settings;  private LuytenPreferences luytenPrefs;   public MainMenuBar(MainWindow mainWnd) {   this.mainWindow = mainWnd;   final ConfigSaver configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    final JMenu fileMenu = new JMenu("File");   fileMenu.add(new JMenuItem("..."));   this.add(fileMenu);   final JMenu editMenu = new JMenu("Edit");   editMenu.add(new JMenuItem("..."));   this.add(editMenu);   final JMenu themesMenu = new JMenu("Themes");   themesMenu.add(new JMenuItem("..."));   this.add(themesMenu);   final JMenu operationMenu = new JMenu("Operation");   operationMenu.add(new JMenuItem("..."));   this.add(operationMenu);   final JMenu settingsMenu = new JMenu("Settings");   settingsMenu.add(new JMenuItem("..."));   this.add(settingsMenu);   final JMenu helpMenu = new JMenu("Help");   helpMenu.add(new JMenuItem("..."));   this.add(helpMenu);    // start quicker   new Thread() {    public void run() {     try {      // build menu later      buildFileMenu(fileMenu);      refreshMenuPopup(fileMenu);       buildEditMenu(editMenu);      refreshMenuPopup(editMenu);       buildThemesMenu(themesMenu);      refreshMenuPopup(themesMenu);       buildOperationMenu(operationMenu);      refreshMenuPopup(operationMenu);       buildSettingsMenu(settingsMenu, configSaver);      refreshMenuPopup(settingsMenu);       buildHelpMenu(helpMenu);      refreshMenuPopup(helpMenu);     } catch (Exception e) {      e.printStackTrace();     }    }     // refresh currently opened menu     // (if user selected a menu before it was ready)    private void refreshMenuPopup(JMenu menu) {     try {      if (menu.isPopupMenuVisible()) {       menu.getPopupMenu().setVisible(false);       menu.getPopupMenu().setVisible(true);      }     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }   private void buildFileMenu(final JMenu fileMenu) {   fileMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Open File...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onOpenFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Close");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onCloseFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Save As...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAsMenu();    }   });   fileMenu.add(menuItem);    menuItem = new JMenuItem("Save All...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAllMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Recent Files");   menuItem.setEnabled(false);   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Exit");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onExitMenu();    }   });   fileMenu.add(menuItem);  }   private void buildEditMenu(JMenu editMenu) {   editMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Cut");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    menuItem = new JMenuItem("Copy");   menuItem.addActionListener(new DefaultEditorKit.CopyAction());   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));   editMenu.add(menuItem);    menuItem = new JMenuItem("Paste");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    editMenu.addSeparator();    menuItem = new JMenuItem("Select All");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSelectAllMenu();    }   });   editMenu.add(menuItem);   editMenu.addSeparator();    menuItem = new JMenuItem("Find...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onFindMenu();    }   });   editMenu.add(menuItem);          menuItem = new JMenuItem("Find All");         menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_G, ActionEvent.CTRL_MASK));         menuItem.addActionListener(new ActionListener() {             @Override             public void actionPerformed(ActionEvent e) {                 mainWindow.onFindAllMenu();              }         });         editMenu.add(menuItem);  }   private void buildThemesMenu(JMenu themesMenu) {   themesMenu.removeAll();   themesGroup = new ButtonGroup();   JRadioButtonMenuItem a = new JRadioButtonMenuItem(new ThemeAction("Default", "default.xml"));   a.setSelected("default.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Dark", "dark.xml"));   a.setSelected("dark.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Eclipse", "eclipse.xml"));   a.setSelected("eclipse.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Visual Studio", "vs.xml"));   a.setSelected("vs.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);  }   private void buildOperationMenu(JMenu operationMenu) {   operationMenu.removeAll();   packageExplorerStyle = new JCheckBox("    Package Explorer Style");   packageExplorerStyle.setSelected(luytenPrefs.isPackageExplorerStyle());   packageExplorerStyle.setContentAreaFilled(false);   packageExplorerStyle.setFocusable(false);   packageExplorerStyle.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setPackageExplorerStyle(packageExplorerStyle.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(packageExplorerStyle);      filterOutInnerClassEntries = new JCheckBox("    Filter Out Inner Class Entries");   filterOutInnerClassEntries.setSelected(luytenPrefs.isFilterOutInnerClassEntries());   filterOutInnerClassEntries.setContentAreaFilled(false);   filterOutInnerClassEntries.setFocusable(false);   filterOutInnerClassEntries.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setFilterOutInnerClassEntries(filterOutInnerClassEntries.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(filterOutInnerClassEntries);    singleClickOpenEnabled = new JCheckBox("    Single Click Open");   singleClickOpenEnabled.setSelected(luytenPrefs.isSingleClickOpenEnabled());   singleClickOpenEnabled.setContentAreaFilled(false);   singleClickOpenEnabled.setFocusable(false);   singleClickOpenEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setSingleClickOpenEnabled(singleClickOpenEnabled.isSelected());    }   });   operationMenu.add(singleClickOpenEnabled);    exitByEscEnabled = new JCheckBox("    Exit By Esc");   exitByEscEnabled.setSelected(luytenPrefs.isExitByEscEnabled());   exitByEscEnabled.setContentAreaFilled(false);   exitByEscEnabled.setFocusable(false);   exitByEscEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setExitByEscEnabled(exitByEscEnabled.isSelected());    }   });   operationMenu.add(exitByEscEnabled);  }   private void buildSettingsMenu(JMenu settingsMenu, ConfigSaver configSaver) {   settingsMenu.removeAll();   ActionListener settingsChanged = new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     new Thread() {      @Override      public void run() {       populateSettingsFromSettingsMenu();       mainWindow.onSettingsChanged();      }     }.start();    }   };   flattenSwitchBlocks = new JCheckBox("    Flatten Switch Blocks");   flattenSwitchBlocks.setSelected(settings.getFlattenSwitchBlocks());   flattenSwitchBlocks.setContentAreaFilled(false);   flattenSwitchBlocks.setFocusable(false);   flattenSwitchBlocks.addActionListener(settingsChanged);   settingsMenu.add(flattenSwitchBlocks);    forceExplicitImports = new JCheckBox("    Force Explicit Imports");   forceExplicitImports.setSelected(settings.getForceExplicitImports());   forceExplicitImports.setContentAreaFilled(false);   forceExplicitImports.setFocusable(false);   forceExplicitImports.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitImports);    forceExplicitTypes = new JCheckBox("    Force Explicit Types");   forceExplicitTypes.setSelected(settings.getForceExplicitTypeArguments());   forceExplicitTypes.setContentAreaFilled(false);   forceExplicitTypes.setFocusable(false);   forceExplicitTypes.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitTypes);    showSyntheticMembers = new JCheckBox("    Show Synthetic Members");   showSyntheticMembers.setSelected(settings.getShowSyntheticMembers());   showSyntheticMembers.setContentAreaFilled(false);   showSyntheticMembers.setFocusable(false);   showSyntheticMembers.addActionListener(settingsChanged);   settingsMenu.add(showSyntheticMembers);    excludeNestedTypes = new JCheckBox("    Exclude Nested Types");   excludeNestedTypes.setSelected(settings.getExcludeNestedTypes());   excludeNestedTypes.setContentAreaFilled(false);   excludeNestedTypes.setFocusable(false);   excludeNestedTypes.addActionListener(settingsChanged);   settingsMenu.add(excludeNestedTypes);    retainRedundantCasts = new JCheckBox("    Retain Redundant Casts");   retainRedundantCasts.setSelected(settings.getRetainRedundantCasts());   retainRedundantCasts.setContentAreaFilled(false);   retainRedundantCasts.setFocusable(false);   retainRedundantCasts.addActionListener(settingsChanged);   settingsMenu.add(retainRedundantCasts);    unicodeReplacement = new JCheckBox("    Enable Unicode Replacement");   unicodeReplacement.setSelected(configSaver.isUnicodeReplaceEnabled());   unicodeReplacement.setContentAreaFilled(false);   unicodeReplacement.setFocusable(false);   unicodeReplacement.addActionListener(settingsChanged);   settingsMenu.add(unicodeReplacement);    JMenu debugSettingsMenu = new JMenu("Debug Settings");   showDebugInfo = new JCheckBox("    Include Error Diagnostics");   showDebugInfo.setSelected(settings.getIncludeErrorDiagnostics());   showDebugInfo.setContentAreaFilled(false);   showDebugInfo.setFocusable(false);   showDebugInfo.addActionListener(settingsChanged);    debugSettingsMenu.add(showDebugInfo);   settingsMenu.add(debugSettingsMenu);   settingsMenu.addSeparator();    languageLookup.put(Languages.java().getName(), Languages.java());   languageLookup.put(Languages.bytecode().getName(), Languages.bytecode());   languageLookup.put(Languages.bytecodeAst().getName(), Languages.bytecodeAst());    languagesGroup = new ButtonGroup();   java = new JRadioButtonMenuItem(Languages.java().getName());   java.getModel().setActionCommand(Languages.java().getName());   java.setSelected(Languages.java().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(java);   settingsMenu.add(java);   bytecode = new JRadioButtonMenuItem(Languages.bytecode().getName());   bytecode.getModel().setActionCommand(Languages.bytecode().getName());   bytecode.setSelected(Languages.bytecode().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecode);   settingsMenu.add(bytecode);   bytecodeAST = new JRadioButtonMenuItem(Languages.bytecodeAst().getName());   bytecodeAST.getModel().setActionCommand(Languages.bytecodeAst().getName());   bytecodeAST.setSelected(Languages.bytecodeAst().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecodeAST);   settingsMenu.add(bytecodeAST);    JMenu debugLanguagesMenu = new JMenu("Debug Languages");   for (final Language language : Languages.debug()) {    final JRadioButtonMenuItem m = new JRadioButtonMenuItem(language.getName());    m.getModel().setActionCommand(language.getName());    m.setSelected(language.getName().equals(settings.getLanguage().getName()));    languagesGroup.add(m);    debugLanguagesMenu.add(m);    languageLookup.put(language.getName(), language);   }   for (AbstractButton button : Collections.list(languagesGroup.getElements())) {    button.addActionListener(settingsChanged);   }   settingsMenu.add(debugLanguagesMenu);  }   private void buildHelpMenu(JMenu helpMenu) {   helpMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Legal");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onLegalMenu();    }   });   helpMenu.add(menuItem);   menuItem = new JMenuItem("About");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent event) {     JOptionPane.showMessageDialog(null,       "Luyten Gui \n" +         "by Deathmarine, Zerdei\n\n" +         "Powered By\nProcyon\n" +         "(c) 2013 Mike Strobel\n\n" +         "RSyntaxTextArea\n" +         "(c) 2012 Robert Futrell\n" +         "All rights reserved.");    }   });   helpMenu.add(menuItem);  }   private void populateSettingsFromSettingsMenu() {   // synchronized: do not disturb decompiler at work (synchronize every time before run decompiler)   synchronized (settings) {    settings.setFlattenSwitchBlocks(flattenSwitchBlocks.isSelected());    settings.setForceExplicitImports(forceExplicitImports.isSelected());    settings.setShowSyntheticMembers(showSyntheticMembers.isSelected());    settings.setExcludeNestedTypes(excludeNestedTypes.isSelected());    settings.setForceExplicitTypeArguments(forceExplicitTypes.isSelected());    settings.setRetainRedundantCasts(retainRedundantCasts.isSelected());    settings.setIncludeErrorDiagnostics(showDebugInfo.isSelected());    ConfigSaver.getLoadedInstance().setUnicodeReplaceEnabled(unicodeReplacement.isSelected());    //    // Note: You shouldn't ever need to set this.  It's only for languages that support catch    //       blocks without an exception variable.  Java doesn't allow this.  I think Scala does.    //    // settings.setAlwaysGenerateExceptionVariableForCatchBlocks(true);    //     final ButtonModel selectedLanguage = languagesGroup.getSelection();    if (selectedLanguage != null) {     final Language language = languageLookup.get(selectedLanguage.getActionCommand());      if (language != null)      settings.setLanguage(language);    }     if (java.isSelected()) {     settings.setLanguage(Languages.java());    } else if (bytecode.isSelected()) {     settings.setLanguage(Languages.bytecode());    } else if (bytecodeAST.isSelected()) {     settings.setLanguage(Languages.bytecodeAst());    }   }  }   private class ThemeAction extends AbstractAction {   private static final long serialVersionUID = -6618680171943723199L;   private String xml;    public ThemeAction(String name, String xml) {    putValue(NAME, name);    this.xml = xml;   }    @Override   public void actionPerformed(ActionEvent e) {    luytenPrefs.setThemeXml(xml);    mainWindow.onThemesChanged();   }  } } " compose:StringConcatenation merge: LineBased]
					[NT -> TooLargeFileException.java.merge : .java.merge-File]
						[T -> TooLargeFileException.java : .java-Content "package us.deathmarine.luyten;  import java.text.DecimalFormat;  public class TooLargeFileException extends Exception {  private static final long serialVersionUID = 1L;  private long size;   public TooLargeFileException(long size) {   this.size = size;  }   public String getReadableFileSize() {   if (size <= 0)    return "0";   final String[] units = new String[] {"B", "KB", "MB", "GB", "TB"};   int digitGroups = (int) (Math.log10(size) / Math.log10(1024));   return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FileSaver.java.merge : .java.merge-File]
						[T -> FileSaver.java : .java-Content "package us.deathmarine.luyten;  import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.BufferedOutputStream; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.InputStream; import java.io.OutputStreamWriter; import java.io.StringWriter; import java.io.Writer; import java.util.Enumeration; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.jar.JarEntry; import java.util.jar.JarFile; import java.util.zip.ZipException; import java.util.zip.ZipOutputStream;  import javax.swing.JLabel; import javax.swing.JMenuItem; import javax.swing.JOptionPane; import javax.swing.JPopupMenu; import javax.swing.JProgressBar; import javax.swing.SwingUtilities;  import com.strobel.assembler.metadata.ITypeLoader; import com.strobel.assembler.metadata.JarTypeLoader; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput; import com.strobel.decompiler.languages.java.JavaFormattingOptions;  /**  * Performs Save and Save All  */ public class FileSaver {   private JProgressBar bar;  private JLabel label;  private boolean cancel;  private boolean extracting;   public FileSaver(JProgressBar bar, JLabel label) {   this.bar = bar;   this.label = label;   final JPopupMenu menu = new JPopupMenu("Cancel");   final JMenuItem item = new JMenuItem("Cancel");   item.addActionListener(new ActionListener(){    @Override    public void actionPerformed(ActionEvent arg0) {     setCancel(true);        }   });   menu.add(item);   this.label.addMouseListener(new MouseAdapter(){       public void mouseClicked(MouseEvent ev) {        if(SwingUtilities.isRightMouseButton(ev) && isExtracting())             menu.show(ev.getComponent(), ev.getX(), ev.getY());       }     });  }   public void saveText(final String text, final File file) {   new Thread(new Runnable() {    @Override    public void run() {     long time = System.currentTimeMillis();     try (FileWriter fw = new FileWriter(file);       BufferedWriter bw = new BufferedWriter(fw);) {      label.setText("Extracting: " + file.getName());      bar.setVisible(true);      bw.write(text);      bw.flush();      label.setText("Completed: "+getTime(time));     } catch (Exception e1) {      label.setText("Cannot save file: " + file.getName());      e1.printStackTrace();      JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);     } finally {      setExtracting(false);      bar.setVisible(false);     }    }   }).start();  }   public void saveAllDecompiled(final File inFile, final File outFile) {   new Thread(new Runnable() {    @Override    public void run() {     long time = System.currentTimeMillis();     try {      bar.setVisible(true);      setExtracting(true);      label.setText("Extracting: " + outFile.getName());      String inFileName = inFile.getName().toLowerCase();       if (inFileName.endsWith(".jar") || inFileName.endsWith(".zip")) {       doSaveJarDecompiled(inFile, outFile);      } else if (inFileName.endsWith(".class")) {       doSaveClassDecompiled(inFile, outFile);      } else {       doSaveUnknownFile(inFile, outFile);      }      if(cancel){       label.setText("Cancelled");       outFile.delete();       setCancel(false);      }else{       label.setText("Completed: "+ getTime(time));      }     } catch (Exception e1) {      e1.printStackTrace();      label.setText("Cannot save file: " + outFile.getName());      JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);     } finally {      setExtracting(false);      bar.setVisible(false);     }    }   }).start();  }   private void doSaveJarDecompiled(File inFile, File outFile) throws Exception {   try (JarFile jfile = new JarFile(inFile);     FileOutputStream dest = new FileOutputStream(outFile);     BufferedOutputStream buffDest = new BufferedOutputStream(dest);     ZipOutputStream out = new ZipOutputStream(buffDest);) {    bar.setMinimum(0);    bar.setMaximum(jfile.size());    byte data[] = new byte[1024];    DecompilerSettings settings = cloneSettings();    LuytenTypeLoader typeLoader = new LuytenTypeLoader();    MetadataSystem metadataSystem = new MetadataSystem(typeLoader);    ITypeLoader jarLoader = new JarTypeLoader(jfile);    typeLoader.getTypeLoaders().add(jarLoader);     DecompilationOptions decompilationOptions = new DecompilationOptions();    decompilationOptions.setSettings(settings);    decompilationOptions.setFullDecompilation(true);     List<String> mass = null;    JarEntryFilter jarEntryFilter = new JarEntryFilter(jfile);    LuytenPreferences luytenPrefs = ConfigSaver.getLoadedInstance().getLuytenPreferences();    if (luytenPrefs.isFilterOutInnerClassEntries()) {     mass = jarEntryFilter.getEntriesWithoutInnerClasses();    } else {     mass = jarEntryFilter.getAllEntriesFromJar();    }     Enumeration<JarEntry> ent = jfile.entries();    Set<JarEntry> history = new HashSet<JarEntry>();    int tick = 0;    while (ent.hasMoreElements() && !cancel) {     bar.setValue(++tick);     JarEntry entry = ent.nextElement();     if (!mass.contains(entry.getName()))      continue;     label.setText("Extracting: " + entry.getName());     bar.setVisible(true);     if (entry.getName().endsWith(".class")) {      JarEntry etn = new JarEntry(entry.getName().replace(".class", ".java"));      label.setText("Extracting: " + etn.getName());      //Duplicate      if(history.add(etn)){       out.putNextEntry(etn);       try {        String internalName = StringUtilities.removeRight(entry.getName(), ".class");        TypeReference type = metadataSystem.lookupType(internalName);        TypeDefinition resolvedType = null;        if ((type == null) || ((resolvedType = type.resolve()) == null)) {         throw new Exception("Unable to resolve type.");        }        Writer writer = new OutputStreamWriter(out);        settings.getLanguage().decompileType(resolvedType,          new PlainTextOutput(writer), decompilationOptions);        writer.flush();       } finally {        out.closeEntry();       }      }     } else {      try {       JarEntry etn = new JarEntry(entry.getName());       if(history.add(etn))        continue;       history.add(etn);       out.putNextEntry(etn);       try {        InputStream in = jfile.getInputStream(entry);        if (in != null) {         try {          int count;          while ((count = in.read(data, 0, 1024)) != -1) {           out.write(data, 0, count);          }         } finally {          in.close();         }        }       } finally {        out.closeEntry();       }      } catch (ZipException ze) {       // some jar-s contain duplicate pom.xml entries: ignore it       if (!ze.getMessage().contains("duplicate")) {        throw ze;       }      }     }    }   }  }   private void doSaveClassDecompiled(File inFile, File outFile) throws Exception {   DecompilerSettings settings = cloneSettings();   LuytenTypeLoader typeLoader = new LuytenTypeLoader();   MetadataSystem metadataSystem = new MetadataSystem(typeLoader);   TypeReference type = metadataSystem.lookupType(inFile.getCanonicalPath());    DecompilationOptions decompilationOptions = new DecompilationOptions();   decompilationOptions.setSettings(settings);   decompilationOptions.setFullDecompilation(true);    TypeDefinition resolvedType = null;   if (type == null || ((resolvedType = type.resolve()) == null)) {    throw new Exception("Unable to resolve type.");   }   StringWriter stringwriter = new StringWriter();   settings.getLanguage().decompileType(resolvedType,     new PlainTextOutput(stringwriter), decompilationOptions);   String decompiledSource = stringwriter.toString();    try (FileWriter fw = new FileWriter(outFile);     BufferedWriter bw = new BufferedWriter(fw);) {    bw.write(decompiledSource);    bw.flush();   }  }   private void doSaveUnknownFile(File inFile, File outFile) throws Exception {   try (FileInputStream in = new FileInputStream(inFile);     FileOutputStream out = new FileOutputStream(outFile);) {     byte data[] = new byte[1024];    int count;    while ((count = in.read(data, 0, 1024)) != -1) {     out.write(data, 0, count);    }   }  }   private DecompilerSettings cloneSettings() {   DecompilerSettings settings = ConfigSaver.getLoadedInstance().getDecompilerSettings();   DecompilerSettings newSettings = new DecompilerSettings();   if (newSettings.getFormattingOptions() == null) {    newSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   // synchronized: against main menu changes   synchronized (settings) {    newSettings.setExcludeNestedTypes(settings.getExcludeNestedTypes());    newSettings.setFlattenSwitchBlocks(settings.getFlattenSwitchBlocks());    newSettings.setForceExplicitImports(settings.getForceExplicitImports());    newSettings.setForceExplicitTypeArguments(settings.getForceExplicitTypeArguments());    newSettings.setOutputFileHeaderText(settings.getOutputFileHeaderText());    newSettings.setLanguage(settings.getLanguage());    newSettings.setShowSyntheticMembers(settings.getShowSyntheticMembers());    newSettings.setAlwaysGenerateExceptionVariableForCatchBlocks(settings      .getAlwaysGenerateExceptionVariableForCatchBlocks());    newSettings.setOutputDirectory(settings.getOutputDirectory());    newSettings.setRetainRedundantCasts(settings.getRetainRedundantCasts());    newSettings.setIncludeErrorDiagnostics(settings.getIncludeErrorDiagnostics());    newSettings.setIncludeLineNumbersInBytecode(settings.getIncludeLineNumbersInBytecode());    newSettings.setRetainPointlessSwitches(settings.getRetainPointlessSwitches());    newSettings.setUnicodeOutputEnabled(settings.isUnicodeOutputEnabled());    newSettings.setMergeVariables(settings.getMergeVariables());    newSettings.setShowDebugLineNumbers(settings.getShowDebugLineNumbers());   }   return newSettings;  }   public boolean isCancel() {   return cancel;  }   public void setCancel(boolean cancel) {   this.cancel = cancel;  }   public boolean isExtracting() {   return extracting;  }   public void setExtracting(boolean extracting) {   this.extracting = extracting;  }    public static String getTime(long time){   long lap = System.currentTimeMillis()-time;   lap = lap/1000;    StringBuilder sb = new StringBuilder();   int hour = (int) ((lap/60)/60);   int min = (int) ((lap-(hour*60*60))/60);   int sec =(int) ((lap-(hour*60*60)-(min*60))/60);   if(hour > 0)    sb.append("Hour:").append(hour).append(" ");   sb.append("Min(s): ").append(min).append(" Sec: ").append(sec);   return sb.toString();    } } " compose:StringConcatenation merge: LineBased]
					[NT -> CellRenderer.java.merge : .java.merge-File]
						[T -> CellRenderer.java : .java-Content "package us.deathmarine.luyten;  import java.awt.Component; import java.awt.Toolkit;  import javax.swing.Icon; import javax.swing.ImageIcon; import javax.swing.JTree; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.DefaultTreeCellRenderer;  public class CellRenderer extends DefaultTreeCellRenderer{  private static final long serialVersionUID = -5691181006363313993L;  Icon pack;  Icon java_image;  Icon file_image;    public CellRenderer(){   this.pack = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/package_obj.png")));   this.java_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/java.png")));   this.file_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/file.png")));  }   @Override  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);         DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;   if(node.getChildCount() > 0){    setIcon(this.pack);   }else if(getFileName(node).endsWith(".class") || getFileName(node).endsWith(".java")){    setIcon(this.java_image);   }else{    setIcon(this.file_image);   }      return this;  }    public String getFileName(DefaultMutableTreeNode node){         return ((TreeNodeUserObject) node.getUserObject()).getOriginalName();  }  } " compose:StringConcatenation merge: LineBased]
					[NT -> TreeNodeUserObject.java.merge : .java.merge-File]
						[T -> TreeNodeUserObject.java : .java-Content "package us.deathmarine.luyten;  public class TreeNodeUserObject {   private String originalName;  private String displayName;   public TreeNodeUserObject(String name) {   this(name, name);  }   public TreeNodeUserObject(String originalName, String displayName) {   this.originalName = originalName;   this.displayName = displayName;  }   public String getOriginalName() {   return originalName;  }   public void setOriginalName(String originalName) {   this.originalName = originalName;  }   public String getDisplayName() {   return displayName;  }   public void setDisplayName(String displayName) {   this.displayName = displayName;  }   @Override  public String toString() {   return displayName;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LuytenPreferences.java.merge : .java.merge-File]
						[T -> LuytenPreferences.java : .java-Content "package us.deathmarine.luyten;  /**  * Do not instantiate this class, get the instance from  * ConfigSaver. All not-static fields will be saved  * automatically named by the field's java variable name.  * (Watch for collisions with existing IDs defined in  * ConfigSaver.) Only String, boolean and int fields are  * supported. Write default values into the field  * declarations.  */ public class LuytenPreferences {   public static final String THEME_XML_PATH = "/themes/";  public static final String DEFAULT_THEME_XML = "eclipse.xml";   private String themeXml = DEFAULT_THEME_XML;  private String fileOpenCurrentDirectory = "";  private String fileSaveCurrentDirectory = "";   private boolean isPackageExplorerStyle = true;  private boolean isFilterOutInnerClassEntries = true;  private boolean isSingleClickOpenEnabled = true;  private boolean isExitByEscEnabled = false;   public String getThemeXml() {   return themeXml;  }   public void setThemeXml(String themeXml) {   this.themeXml = themeXml;  }   public String getFileOpenCurrentDirectory() {   return fileOpenCurrentDirectory;  }   public void setFileOpenCurrentDirectory(String fileOpenCurrentDirectory) {   this.fileOpenCurrentDirectory = fileOpenCurrentDirectory;  }   public String getFileSaveCurrentDirectory() {   return fileSaveCurrentDirectory;  }   public void setFileSaveCurrentDirectory(String fileSaveCurrentDirectory) {   this.fileSaveCurrentDirectory = fileSaveCurrentDirectory;  }   public boolean isPackageExplorerStyle() {   return isPackageExplorerStyle;  }   public void setPackageExplorerStyle(boolean isPackageExplorerStyle) {   this.isPackageExplorerStyle = isPackageExplorerStyle;  }   public boolean isFilterOutInnerClassEntries() {   return isFilterOutInnerClassEntries;  }   public void setFilterOutInnerClassEntries(boolean isFilterOutInnerClassEntries) {   this.isFilterOutInnerClassEntries = isFilterOutInnerClassEntries;  }   public boolean isSingleClickOpenEnabled() {   return isSingleClickOpenEnabled;  }   public void setSingleClickOpenEnabled(boolean isSingleClickOpenEnabled) {   this.isSingleClickOpenEnabled = isSingleClickOpenEnabled;  }   public boolean isExitByEscEnabled() {   return isExitByEscEnabled;  }   public void setExitByEscEnabled(boolean isExitByEscEnabled) {   this.isExitByEscEnabled = isExitByEscEnabled;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> OpenFile.java.merge : .java.merge-File]
						[T -> OpenFile.java : .java-Content "package us.deathmarine.luyten;  import java.awt.Panel; import java.util.Arrays; import java.util.HashSet; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rsyntaxtextarea.SyntaxConstants; import org.fife.ui.rsyntaxtextarea.Theme; import org.fife.ui.rtextarea.RTextScrollPane; import com.strobel.assembler.metadata.TypeReference;  public class OpenFile implements SyntaxConstants {   public static final HashSet<String> WELL_KNOWN_TEXT_FILE_EXTENSIONS = new HashSet<>(Arrays.asList(    ".java", ".xml", ".rss", ".project", ".classpath", ".h", ".sql", ".js", ".php", ".php5",    ".phtml", ".html", ".htm", ".xhtm", ".xhtml", ".lua", ".bat", ".pl", ".sh", ".css",    ".json", ".txt", ".rb", ".make", ".mak", ".py", ".properties", ".prop"));   RTextScrollPane scrollPane;  Panel image_pane;  RSyntaxTextArea textArea;  String name;  private String path;  private TypeReference type = null;  private boolean isContentValid = false;   public OpenFile(TypeReference type, String name, String path, String content, Theme theme) {   this(name, path, content, theme);   this.type = type;  }    public OpenFile(String name, String path, String contents, Theme theme) {   this.name = name;   this.path = path;   textArea = new RSyntaxTextArea(25, 70);   textArea.setCaretPosition(0);   textArea.requestFocusInWindow();   textArea.setMarkOccurrences(true);   textArea.setClearWhitespaceLinesEnabled(false);   textArea.setEditable(false);   textArea.setAntiAliasingEnabled(true);   textArea.setCodeFoldingEnabled(true);   if (name.toLowerCase().endsWith(".class")     || name.toLowerCase().endsWith(".java"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVA);   else if (name.toLowerCase().endsWith(".xml")     || name.toLowerCase().endsWith(".rss")     || name.toLowerCase().endsWith(".project")     || name.toLowerCase().endsWith(".classpath"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_XML);   else if (name.toLowerCase().endsWith(".h"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_C);   else if (name.toLowerCase().endsWith(".sql"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_SQL);   else if (name.toLowerCase().endsWith(".js"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVASCRIPT);   else if (name.toLowerCase().endsWith(".php")     || name.toLowerCase().endsWith(".php5")     || name.toLowerCase().endsWith(".phtml"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PHP);   else if (name.toLowerCase().endsWith(".html")     || name.toLowerCase().endsWith(".htm")     || name.toLowerCase().endsWith(".xhtm")     || name.toLowerCase().endsWith(".xhtml"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_HTML);   else if (name.toLowerCase().endsWith(".js"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVASCRIPT);   else if (name.toLowerCase().endsWith(".lua"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_LUA);   else if (name.toLowerCase().endsWith(".bat"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_WINDOWS_BATCH);   else if (name.toLowerCase().endsWith(".pl"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PERL);   else if (name.toLowerCase().endsWith(".sh"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_UNIX_SHELL);   else if (name.toLowerCase().endsWith(".css"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_CSS);   else if (name.toLowerCase().endsWith(".json"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JSON);   else if (name.toLowerCase().endsWith(".txt"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_NONE);   else if (name.toLowerCase().endsWith(".rb"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_RUBY);   else if (name.toLowerCase().endsWith(".make")     || name.toLowerCase().endsWith(".mak"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_MAKEFILE);   else if (name.toLowerCase().endsWith(".py"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PYTHON);   else    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PROPERTIES_FILE);   scrollPane = new RTextScrollPane(textArea, true);   scrollPane.setIconRowHeaderEnabled(true);   textArea.setText(contents);   theme.apply(textArea);  }   public void setContent(String content) {   textArea.setText(content);  }   public String getPath() {   return path;  }   public void setPath(String path) {   this.path = path;  }   public TypeReference getType() {   return type;  }   public void setType(TypeReference type) {   this.type = type;  }   public boolean isContentValid() {   return isContentValid;  }   public void setContentValid(boolean isContentValid) {   this.isContentValid = isContentValid;  }    @Override  public int hashCode() {   final int prime = 31;   int result = 1;   result = prime * result + ((name == null) ? 0 : name.hashCode());   return result;  }   @Override  public boolean equals(Object obj) {   if (this == obj)    return true;   if (obj == null)    return false;   if (getClass() != obj.getClass())    return false;   OpenFile other = (OpenFile) obj;   if (name == null) {    if (other.name != null)     return false;   } else if (!name.equals(other.name))    return false;   return true;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> WindowPosition.java.merge : .java.merge-File]
						[T -> WindowPosition.java : .java-Content "package us.deathmarine.luyten;  import java.awt.Component; import java.awt.Dimension; import java.awt.Toolkit; import javax.swing.JDialog; import javax.swing.JFrame;  public class WindowPosition {   private boolean isFullScreen;  private int windowWidth;  private int windowHeight;  private int windowX;  private int windowY;   public void readPositionFromWindow(JFrame window) {   isFullScreen = (window.getExtendedState() == JFrame.MAXIMIZED_BOTH);   if (!isFullScreen) {    this.readPositionFromComponent(window);   }  }   public void readPositionFromDialog(JDialog dialog) {   this.readPositionFromComponent(dialog);  }   private void readPositionFromComponent(Component component) {   isFullScreen = false;   windowWidth = component.getWidth();   windowHeight = component.getHeight();   windowX = component.getX();   windowY = component.getY();  }   public boolean isSavedWindowPositionValid() {   if (isFullScreen) {    return true;   }   if (windowWidth < 100 || windowHeight < 100) {    return false;   }   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (windowWidth > screenSize.width + 50 || windowHeight > screenSize.height + 50) {    return false;   }   if (windowY < -20 || windowY > screenSize.height - 50 ||     windowX < 50 - windowWidth || windowX > screenSize.width - 50) {    return false;   }   return true;  }   public boolean isFullScreen() {   return isFullScreen;  }   public void setFullScreen(boolean isFullScreen) {   this.isFullScreen = isFullScreen;  }   public int getWindowWidth() {   return windowWidth;  }   public void setWindowWidth(int windowWidth) {   this.windowWidth = windowWidth;  }   public int getWindowHeight() {   return windowHeight;  }   public void setWindowHeight(int windowHeight) {   this.windowHeight = windowHeight;  }   public int getWindowX() {   return windowX;  }   public void setWindowX(int windowX) {   this.windowX = windowX;  }   public int getWindowY() {   return windowY;  }   public void setWindowY(int windowY) {   this.windowY = windowY;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> MainWindow.java.merge : .java.merge-File]
						[T -> MainWindow.java : .java-Content "package us.deathmarine.luyten;  import java.awt.BorderLayout; import java.awt.Dimension; import java.awt.FlowLayout; import java.awt.Toolkit; import java.awt.dnd.DropTarget; import java.awt.event.ActionEvent; import java.awt.event.ComponentAdapter; import java.awt.event.ComponentEvent; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader;  import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.ImageIcon; import javax.swing.JComponent; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.JSplitPane; import javax.swing.KeyStroke; import javax.swing.border.BevelBorder;  import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;  /**  * Dispatcher  */ public class MainWindow extends JFrame {  private static final long serialVersionUID = 1L;  private static final String TITLE = "Luyten";   public static Model model;  private JProgressBar bar;  private JLabel label;  private FindBox findBox;  private FindAllBox findAllBox;  private ConfigSaver configSaver;  private WindowPosition windowPosition;  private LuytenPreferences luytenPrefs;  private FileDialog fileDialog;  private FileSaver fileSaver;   public MainWindow(File fileFromCommandLine) {   configSaver = ConfigSaver.getLoadedInstance();   windowPosition = configSaver.getMainWindowPosition();   luytenPrefs = configSaver.getLuytenPreferences();    MainMenuBar mainMenuBar = new MainMenuBar(this);   this.setJMenuBar(mainMenuBar);    this.adjustWindowPositionBySavedState();   this.setHideFindBoxOnMainWindowFocus();   this.setShowFindAllBoxOnMainWindowFocus();   this.setQuitOnWindowClosing();   this.setTitle(TITLE);         this.setIconImage(new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/Luyten.png"))).getImage());    // JPanel pane = new JPanel();   JPanel panel1 = new JPanel(new FlowLayout(FlowLayout.LEFT));   label = new JLabel();   label.setHorizontalAlignment(JLabel.LEFT);   // panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setBorder(new BevelBorder(BevelBorder.LOWERED));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(label);   // pane.add(panel1);    JPanel panel2 = new JPanel(new FlowLayout(FlowLayout.RIGHT));   bar = new JProgressBar();   // bar.setIndeterminate(true);    bar.setStringPainted(true);   bar.setOpaque(false);   bar.setVisible(false);   // panel2.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel2.setPreferredSize(new Dimension(this.getWidth() / 3, 20));   panel2.add(bar);   // pane.add(panel1);    model = new Model(this);   this.getContentPane().add(model);    JSplitPane spt = new JSplitPane(JSplitPane.HORIZONTAL_SPLIT, panel1,     panel2) {    private static final long serialVersionUID = 2189946972124687305L;    private final int location = 400;    {     setDividerLocation(location);    }     @Override    public int getDividerLocation() {     return location;    }     @Override    public int getLastDividerLocation() {     return location;    }   };   spt.setBorder(new BevelBorder(BevelBorder.LOWERED));   spt.setPreferredSize(new Dimension(this.getWidth(), 24));    // spt.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));   this.add(spt, BorderLayout.SOUTH);    if (fileFromCommandLine != null) {    model.loadFile(fileFromCommandLine);   }    try {    DropTarget dt = new DropTarget();    dt.addDropTargetListener(new DropListener(this));    this.setDropTarget(dt);   } catch (Exception e) {    e.printStackTrace();   }    fileDialog = new FileDialog(this);   fileSaver = new FileSaver(bar, label);    this.setExitOnEscWhenEnabled(model);    if (fileFromCommandLine == null     || fileFromCommandLine.getName().toLowerCase().endsWith(".jar")     || fileFromCommandLine.getName().toLowerCase().endsWith(".zip")) {    model.startWarmUpThread();   }  }   public void onOpenFileMenu() {   File selectedFile = fileDialog.doOpenDialog();   if (selectedFile != null) {    this.getModel().loadFile(selectedFile);   }  }   public void onCloseFileMenu() {   this.getModel().closeFile();  }   public void onSaveAsMenu() {   RSyntaxTextArea pane = this.getModel().getCurrentTextArea();   if (pane == null)    return;   String tabTitle = this.getModel().getCurrentTabTitle();   if (tabTitle == null)    return;    String recommendedFileName = tabTitle.replace(".class", ".java");   File selectedFile = fileDialog.doSaveDialog(recommendedFileName);   if (selectedFile != null) {    fileSaver.saveText(pane.getText(), selectedFile);   }  }   public void onSaveAllMenu() {   File openedFile = this.getModel().getOpenedFile();   if (openedFile == null)    return;    String fileName = openedFile.getName();   if (fileName.endsWith(".class")) {    fileName = fileName.replace(".class", ".java");   } else if (fileName.toLowerCase().endsWith(".jar")) {    fileName = "decompiled-"      + fileName.replaceAll("\\.[jJ][aA][rR]", ".zip");   } else {    fileName = "saved-" + fileName;   }    File selectedFileToSave = fileDialog.doSaveAllDialog(fileName);   if (selectedFileToSave != null) {    fileSaver.saveAllDecompiled(openedFile, selectedFileToSave);   }  }   public void onExitMenu() {   quit();  }   public void onSelectAllMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     pane.requestFocusInWindow();     pane.setSelectionStart(0);     pane.setSelectionEnd(pane.getText().length());    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onFindMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     if (findBox == null)      findBox = new FindBox(this);     findBox.showFindBox();    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onFindAllMenu() {   try {    if (findAllBox == null)     findAllBox = new FindAllBox();    findAllBox.showFindBox();    } catch (Exception e) {    e.printStackTrace();   }  }   public void onLegalMenu() {   new Thread() {    public void run() {     try {      bar.setVisible(true);      bar.setIndeterminate(true);      String legalStr = getLegalStr();      MainWindow.this.getModel().showLegal(legalStr);     } finally {      bar.setIndeterminate(false);      bar.setVisible(false);     }    }   }.start();  }   private String getLegalStr() {   StringBuilder sb = new StringBuilder();   try {    BufferedReader reader = new BufferedReader(new InputStreamReader(      getClass().getResourceAsStream(        "/distfiles/Procyon.License.txt")));    String line;    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");    sb.append("\n\n\n\n\n");    reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream(        "/distfiles/RSyntaxTextArea.License.txt")));    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");   } catch (IOException e) {    e.printStackTrace();   }   return sb.toString();  }   public void onThemesChanged() {   this.getModel().changeTheme(luytenPrefs.getThemeXml());  }   public void onSettingsChanged() {   this.getModel().updateOpenClasses();  }   public void onTreeSettingsChanged() {   this.getModel().updateTree();  }   public void onFileDropped(File file) {   if (file != null) {    this.getModel().loadFile(file);   }  }   public void onFileLoadEnded(File file, boolean isSuccess) {   try {    if (file != null && isSuccess) {     this.setTitle(TITLE + " - " + file.getName());    } else {     this.setTitle(TITLE);    }   } catch (Exception e) {    e.printStackTrace();   }  }   private void adjustWindowPositionBySavedState() {   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (!windowPosition.isSavedWindowPositionValid()) {    final Dimension center = new Dimension(      (int) (screenSize.width * 0.75),      (int) (screenSize.height * 0.75));    final int x = (int) (center.width * 0.2);    final int y = (int) (center.height * 0.2);    this.setBounds(x, y, center.width, center.height);    } else if (windowPosition.isFullScreen()) {    int heightMinusTray = screenSize.height;    if (screenSize.height > 30)     heightMinusTray -= 30;    this.setBounds(0, 0, screenSize.width, heightMinusTray);    this.setExtendedState(JFrame.MAXIMIZED_BOTH);     this.addComponentListener(new ComponentAdapter() {     @Override     public void componentResized(ComponentEvent e) {      if (MainWindow.this.getExtendedState() != JFrame.MAXIMIZED_BOTH) {       windowPosition.setFullScreen(false);       if (windowPosition.isSavedWindowPositionValid()) {        MainWindow.this.setBounds(          windowPosition.getWindowX(),          windowPosition.getWindowY(),          windowPosition.getWindowWidth(),          windowPosition.getWindowHeight());       }       MainWindow.this.removeComponentListener(this);      }     }    });    } else {    this.setBounds(windowPosition.getWindowX(),      windowPosition.getWindowY(),      windowPosition.getWindowWidth(),      windowPosition.getWindowHeight());   }  }   private void setHideFindBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findBox != null && findBox.isVisible()) {      findBox.setVisible(false);     }    }   });  }   private void setShowFindAllBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findAllBox != null && findAllBox.isVisible()) {      findAllBox.requestFocus();     }    }   });  }   private void setQuitOnWindowClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowClosing(WindowEvent e) {     quit();    }   });  }   private void quit() {   try {    windowPosition.readPositionFromWindow(this);    configSaver.saveConfig();   } catch (Exception exc) {    exc.printStackTrace();   } finally {    try {     this.dispose();    } finally {     System.exit(0);    }   }  }   private void setExitOnEscWhenEnabled(JComponent mainComponent) {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     if (luytenPrefs.isExitByEscEnabled()) {      quit();     }    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE,     0, false);   mainComponent     .getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT)     .put(escapeKeyStroke, "ESCAPE");   mainComponent.getActionMap().put("ESCAPE", escapeAction);  }   public Model getModel() {   return model;  }   public JProgressBar getBar() {   return bar;  }   public JLabel getLabel() {   return label;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LuytenTypeLoader.java.merge : .java.merge-File]
						[T -> LuytenTypeLoader.java : .java-Content "package us.deathmarine.luyten;  import com.strobel.assembler.InputTypeLoader; import com.strobel.assembler.metadata.Buffer; import com.strobel.assembler.metadata.ITypeLoader;  import java.util.ArrayList; import java.util.List;  public final class LuytenTypeLoader implements ITypeLoader {     private final List<ITypeLoader> _typeLoaders;      public LuytenTypeLoader() {         _typeLoaders = new ArrayList<ITypeLoader>();         _typeLoaders.add(new InputTypeLoader());     }      public final List<ITypeLoader> getTypeLoaders() {         return _typeLoaders;     }      @Override     public boolean tryLoadType(final String internalName, final Buffer buffer) {         for (final ITypeLoader typeLoader : _typeLoaders) {             if (typeLoader.tryLoadType(internalName, buffer)) {                 return true;             }              buffer.reset();         }          return false;     } } " compose:StringConcatenation merge: LineBased]
[NT -> base : Feature]
	[NT -> src : Folder]
		[NT -> com : Folder]
			[NT -> modcrafting : Folder]
				[NT -> luyten : Folder]
					[NT -> FileDialog.java.merge : .java.merge-File]
						[T -> FileDialog.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Component; import java.io.File; import javax.swing.JFileChooser; import javax.swing.filechooser.FileFilter;  /**  * FileChoosers for Open and Save  */ public class FileDialog {  private ConfigSaver configSaver;  private LuytenPreferences luytenPrefs;  private Component parent;  private JFileChooser fcOpen;  private JFileChooser fcSave;  private JFileChooser fcSaveAll;   public FileDialog(Component parent) {   this.parent = parent;   configSaver = ConfigSaver.getLoadedInstance();   luytenPrefs = configSaver.getLuytenPreferences();    new Thread() {    public void run() {     initOpenDialog();     initSaveDialog();     initSaveAllDialog();    };   }.start();  }   public File doOpenDialog() {   File selectedFile = null;   initOpenDialog();    retrieveOpenDialogDir(fcOpen);   int returnVal = fcOpen.showOpenDialog(parent);   saveOpenDialogDir(fcOpen);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcOpen.getSelectedFile();   }   return selectedFile;  }   public File doSaveDialog(String recommendedFileName) {   File selectedFile = null;   initSaveDialog();    retrieveSaveDialogDir(fcSave);   fcSave.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSave.showSaveDialog(parent);   saveSaveDialogDir(fcSave);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSave.getSelectedFile();   }   return selectedFile;  }   public File doSaveAllDialog(String recommendedFileName) {   File selectedFile = null;   initSaveAllDialog();      retrieveSaveDialogDir(fcSaveAll);   fcSaveAll.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSaveAll.showSaveDialog(parent);   saveSaveDialogDir(fcSaveAll);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSaveAll.getSelectedFile();   }   return selectedFile;  }   public synchronized void initOpenDialog() {   if (fcOpen == null) {    fcOpen = createFileChooser("*.jar", "*.zip", "*.class");    retrieveOpenDialogDir(fcOpen);   }  }   public synchronized void initSaveDialog() {   if (fcSave == null) {    fcSave = createFileChooser("*.txt", "*.java");    retrieveSaveDialogDir(fcSave);   }  }   public synchronized void initSaveAllDialog() {   if (fcSaveAll == null) {    fcSaveAll = createFileChooser("*.jar", "*.zip");    retrieveSaveDialogDir(fcSaveAll);   }  }   private JFileChooser createFileChooser(String... fileFilters) {   JFileChooser fc = new JFileChooser();   for (String fileFilter : fileFilters) {    fc.addChoosableFileFilter(new FileChooserFileFilter(fileFilter));   }   fc.setFileSelectionMode(JFileChooser.FILES_ONLY);   fc.setMultiSelectionEnabled(false);   return fc;  }   public class FileChooserFileFilter extends FileFilter {   String objType;    public FileChooserFileFilter(String string) {    objType = string;   }    @Override   public boolean accept(File f) {    if (f.isDirectory())     return false;    return f.getName().toLowerCase().endsWith(objType.substring(1));   }    @Override   public String getDescription() {    return objType;   }  }   private void retrieveOpenDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileOpenCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void saveOpenDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileOpenCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void retrieveSaveDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileSaveCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void saveSaveDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileSaveCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  } } " compose:StringConcatenation merge: LineBased]
					[NT -> DropListener.java.merge : .java.merge-File]
						[T -> DropListener.java : .java-Content "package com.modcrafting.luyten;  import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.dnd.DnDConstants; import java.awt.dnd.DropTargetDragEvent; import java.awt.dnd.DropTargetDropEvent; import java.awt.dnd.DropTargetEvent; import java.awt.dnd.DropTargetListener; import java.io.BufferedReader; import java.io.File; import java.io.Reader; import java.net.URI; import java.util.ArrayList; import java.util.List;  /**  * Drag-Drop (only MainWindow should be called from here)  */ public class DropListener implements DropTargetListener {  private MainWindow mainWindow;   public DropListener(MainWindow mainWindow) {   this.mainWindow = mainWindow;  }   @SuppressWarnings("unchecked")  @Override  public void drop(DropTargetDropEvent event) {   event.acceptDrop(DnDConstants.ACTION_COPY);   Transferable transferable = event.getTransferable();   if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    for (DataFlavor flavor : flavors) {     try {      if (flavor.isFlavorJavaFileListType()) {       List<File> files = (List<File>) transferable         .getTransferData(flavor);       if (files.size() > 1) {        event.rejectDrop();        return;       }       if (files.size() == 1) {        mainWindow.onFileDropped(files.get(0));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }    event.dropComplete(true);   } else {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    boolean handled = false;    for (int zz = 0; zz < flavors.length; zz++) {     if (flavors[zz].isRepresentationClassReader()) {      try {       Reader reader = flavors[zz].getReaderForText(transferable);       BufferedReader br = new BufferedReader(reader);       List<File> list = new ArrayList<File>();       String line = null;       while ((line = br.readLine()) != null) {        try {         if (new String("" + (char) 0).equals(line))          continue;         File file = new File(new URI(line));         list.add(file);        } catch (Exception ex) {         ex.printStackTrace();        }       }       if (list.size() > 1) {        event.rejectDrop();        return;       }       if (list.size() == 1) {        mainWindow.onFileDropped(list.get(0));       }       event.getDropTargetContext().dropComplete(true);       handled = true;      } catch (Exception e) {       e.printStackTrace();      }      break;     }    }    if (!handled) {     event.rejectDrop();    }   }   }   @Override  public void dragEnter(DropTargetDragEvent arg0) {}   @Override  public void dragExit(DropTargetEvent arg0) {}   @Override  public void dragOver(DropTargetDragEvent arg0) {}   @Override  public void dropActionChanged(DropTargetDragEvent arg0) {} } " compose:StringConcatenation merge: LineBased]
					[NT -> FileEntryNotFoundException.java.merge : .java.merge-File]
						[T -> FileEntryNotFoundException.java : .java-Content "package com.modcrafting.luyten;  public class FileEntryNotFoundException extends Exception {  private static final long serialVersionUID = 1L;  } " compose:StringConcatenation merge: LineBased]
					[NT -> FileIsBinaryException.java.merge : .java.merge-File]
						[T -> FileIsBinaryException.java : .java-Content "package com.modcrafting.luyten;  public class FileIsBinaryException extends Exception {  private static final long serialVersionUID = 1L;  } " compose:StringConcatenation merge: LineBased]
					[NT -> JarEntryFilter.java.merge : .java.merge-File]
						[T -> JarEntryFilter.java : .java-Content "package com.modcrafting.luyten;  import java.util.ArrayList; import java.util.Enumeration; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.jar.JarEntry; import java.util.jar.JarFile;  public class JarEntryFilter {   private JarFile jfile;   public JarEntryFilter() {}   public JarEntryFilter(JarFile jfile) {   this.jfile = jfile;  }   public List<String> getAllEntriesFromJar() {   List<String> mass = new ArrayList<>();   Enumeration<JarEntry> entries = jfile.entries();   while (entries.hasMoreElements()) {    JarEntry e = entries.nextElement();    if (!e.isDirectory()) {     mass.add(e.getName());    }   }   return mass;  }   public List<String> getEntriesWithoutInnerClasses() {   List<String> mass = new ArrayList<>();   Enumeration<JarEntry> entries = jfile.entries();   Set<String> possibleInnerClasses = new HashSet<String>();   Set<String> baseClasses = new HashSet<String>();    while (entries.hasMoreElements()) {    JarEntry e = entries.nextElement();    if (!e.isDirectory()) {     String entryName = e.getName();      if (entryName != null && entryName.trim().length() > 0) {      entryName = entryName.trim();       if (!entryName.endsWith(".class")) {       mass.add(entryName);        // com/acme/Model$16.class      } else if (entryName.matches(".*[^(/|\\\\)]+\\$[^(/|\\\\)]+$")) {       possibleInnerClasses.add(entryName);       } else {       baseClasses.add(entryName);       mass.add(entryName);      }     }    }   }    // keep Badly$Named but not inner classes   for (String inner : possibleInnerClasses) {     // com/acme/Connection$Conn$1.class -> com/acme/Connection    String innerWithoutTail = inner.replaceAll("\\$[^(/|\\\\)]+\\.class$", "");    if (!baseClasses.contains(innerWithoutTail + ".class")) {     mass.add(inner);    }   }   return mass;  }   public JarFile getJfile() {   return jfile;  }   public void setJfile(JarFile jfile) {   this.jfile = jfile;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Closer.java.merge : .java.merge-File]
						[T -> Closer.java : .java-Content "package com.modcrafting.luyten;  public final class Closer {     public static void tryClose(final AutoCloseable c) {         if (c == null) {             return;         }         try {             c.close();         }         catch (Throwable ignored) {         }     }      public static void tryClose(final AutoCloseable... items) {         if (items == null) {             return;         }         for (AutoCloseable c : items) {             tryClose(c);         }     } } " compose:StringConcatenation merge: LineBased]
					[NT -> Model.java.merge : .java.merge-File]
						[T -> Model.java : .java-Content "package com.modcrafting.luyten;  import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import java.awt.Insets; import java.awt.Toolkit; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.io.StringWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Enumeration; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Set; import java.util.TreeMap; import java.util.TreeSet; import java.util.jar.JarEntry; import java.util.jar.JarFile; import javax.swing.BorderFactory; import javax.swing.BoxLayout; import javax.swing.ImageIcon; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.JScrollPane; import javax.swing.JSplitPane; import javax.swing.JTabbedPane; import javax.swing.JTree; import javax.swing.SwingUtilities; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.DefaultTreeModel; import javax.swing.tree.TreeNode; import javax.swing.tree.TreePath; import javax.swing.tree.TreeSelectionModel; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rsyntaxtextarea.Theme; import org.fife.ui.rtextarea.RTextScrollPane; import com.strobel.assembler.InputTypeLoader; import com.strobel.assembler.metadata.ITypeLoader; import com.strobel.assembler.metadata.JarTypeLoader; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.core.VerifyArgument; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput;  /**  * Jar-level model  */ public class Model extends JSplitPane {  private static final long serialVersionUID = 6896857630400910200L;   private static final long MAX_JAR_FILE_SIZE_BYTES = 1_000_000_000;  private static final long MAX_UNPACKED_FILE_SIZE_BYTES = 1_000_000;   private final LuytenTypeLoader typeLoader = new LuytenTypeLoader();  private MetadataSystem metadataSystem = new MetadataSystem(typeLoader);   private JTree tree;  private JTabbedPane house;  private File file;  private DecompilerSettings settings;  private DecompilationOptions decompilationOptions;  private Theme theme;  private MainWindow mainWindow;  private JProgressBar bar;  private JLabel label;  private HashSet<OpenFile> hmap = new HashSet<OpenFile>();  private Set<String> treeExpansionState;  private boolean open = false;  private State state;  private ConfigSaver configSaver;  private LuytenPreferences luytenPrefs;   public Model(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.bar = mainWindow.getBar();   this.label = mainWindow.getLabel();    configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    try {    String themeXml = luytenPrefs.getThemeXml();    theme = Theme.load(getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + themeXml));   } catch (Exception e1) {    try {     e1.printStackTrace();     String themeXml = LuytenPreferences.DEFAULT_THEME_XML;     luytenPrefs.setThemeXml(themeXml);     theme = Theme.load(getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + themeXml));    } catch (Exception e2) {     e2.printStackTrace();    }   }    tree = new JTree();   tree.setModel(new DefaultTreeModel(null));   tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);   tree.setCellRenderer(new CellRenderer());   TreeListener tl = new TreeListener();   tree.addMouseListener(tl);    JPanel panel2 = new JPanel();   panel2.setLayout(new BoxLayout(panel2, 1));   panel2.setBorder(BorderFactory.createTitledBorder("Structure"));   panel2.add(new JScrollPane(tree));    house = new JTabbedPane();   house.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);   house.addChangeListener(new TabChangeListener());    JPanel panel = new JPanel();   panel.setLayout(new BoxLayout(panel, 1));   panel.setBorder(BorderFactory.createTitledBorder("Code"));   panel.add(house);   this.setOrientation(JSplitPane.HORIZONTAL_SPLIT);   this.setDividerLocation(250 % mainWindow.getWidth());   this.setLeftComponent(panel2);   this.setRightComponent(panel);    decompilationOptions = new DecompilationOptions();   decompilationOptions.setSettings(settings);   decompilationOptions.setFullDecompilation(true);  }   public void showLegal(String legalStr) {   OpenFile open = new OpenFile("Legal", "*/Legal", legalStr, theme);   hmap.add(open);   addOrSwitchToTab(open);  }   private void addOrSwitchToTab(OpenFile open) {   String title = open.name;   RTextScrollPane rTextScrollPane = open.scrollPane;   if (house.indexOfTab(title) < 0) {    house.addTab(title, rTextScrollPane);    house.setSelectedIndex(house.indexOfTab(title));    int index = house.indexOfTab(title);    Tab ct = new Tab(title);    ct.getButton().addMouseListener(new CloseTab(title));    house.setTabComponentAt(index, ct);   } else {    house.setSelectedIndex(house.indexOfTab(title));   }  }   private void closeOpenTab(int index) {   RTextScrollPane co = (RTextScrollPane) house.getComponentAt(index);   RSyntaxTextArea pane = (RSyntaxTextArea) co.getViewport().getView();   OpenFile open = null;   for (OpenFile file : hmap)    if (pane.equals(file.textArea))     open = file;   if (open != null && hmap.contains(open))    hmap.remove(open);   house.remove(co);  }   private String getName(String path) {   if (path == null)    return "";   int i = path.lastIndexOf("/");   if (i == -1)    i = path.lastIndexOf("\\");   if (i != -1)    return path.substring(i + 1);   return path;  }   private class TreeListener extends MouseAdapter {   @Override   public void mousePressed(MouseEvent event) {    boolean isClickCountMatches = (event.getClickCount() == 1 && luytenPrefs.isSingleClickOpenEnabled())      || (event.getClickCount() == 2 && !luytenPrefs.isSingleClickOpenEnabled());    if (!isClickCountMatches)     return;     if (!SwingUtilities.isLeftMouseButton(event))     return;     final TreePath trp = tree.getPathForLocation(event.getX(), event.getY());    if (trp == null)     return;     Object lastPathComponent = trp.getLastPathComponent();    boolean isLeaf = (lastPathComponent instanceof TreeNode && ((TreeNode) lastPathComponent).isLeaf());    if (!isLeaf)     return;     new Thread() {     public void run() {      openEntryByTreePath(trp);     }    }.start();   }  }   private void openEntryByTreePath(TreePath trp) {   String name = "";   String path = "";   try {    bar.setVisible(true);    if (trp.getPathCount() > 1) {     for (int i = 1; i < trp.getPathCount(); i++) {      DefaultMutableTreeNode node = (DefaultMutableTreeNode) trp.getPathComponent(i);      TreeNodeUserObject userObject = (TreeNodeUserObject) node.getUserObject();      if (i == trp.getPathCount() - 1) {       name = userObject.getOriginalName();      } else {       path = path + userObject.getOriginalName() + "/";      }     }     path = path + name;      if (file.getName().endsWith(".jar") || file.getName().endsWith(".zip")) {      if (state == null) {       JarFile jfile = new JarFile(file);       ITypeLoader jarLoader = new JarTypeLoader(jfile);        typeLoader.getTypeLoaders().add(jarLoader);       state = new State(file.getCanonicalPath(), file, jfile, jarLoader);      }       JarEntry entry = state.jarFile.getJarEntry(path);      if (entry == null) {       throw new FileEntryNotFoundException();      }      if (entry.getSize() > MAX_UNPACKED_FILE_SIZE_BYTES) {       throw new TooLargeFileException(entry.getSize());      }      String entryName = entry.getName();      if (entryName.endsWith(".class")) {       label.setText("Extracting: " + name);       String internalName = StringUtilities.removeRight(entryName, ".class");       TypeReference type = metadataSystem.lookupType(internalName);       extractClassToTextPane(type, name, path);      } else {       label.setText("Opening: " + name);       try (InputStream in = state.jarFile.getInputStream(entry);) {        extractSimpleFileEntryToTextPane(in, name, path);       }      }     }    } else {     name = file.getName();     path = file.getPath().replaceAll("\\\\", "/");     if (file.length() > MAX_UNPACKED_FILE_SIZE_BYTES) {      throw new TooLargeFileException(file.length());     }     if (name.endsWith(".class")) {      label.setText("Extracting: " + name);      TypeReference type = metadataSystem.lookupType(path);      extractClassToTextPane(type, name, path);     } else {      label.setText("Opening: " + name);      try (InputStream in = new FileInputStream(file);) {       extractSimpleFileEntryToTextPane(in, name, path);      }     }    }    label.setText("Complete");   } catch (FileEntryNotFoundException e) {    label.setText("File not found: " + name);   } catch (FileIsBinaryException e) {    label.setText("Binary resource: " + name);   } catch (TooLargeFileException e) {    label.setText("File is too large: " + name + " - size: " + e.getReadableFileSize());   } catch (Exception e) {    label.setText("Cannot open: " + name);    e.printStackTrace();    JOptionPane.showMessageDialog(null, e.toString(), "Error!", JOptionPane.ERROR_MESSAGE);   } finally {    bar.setVisible(false);   }  }   private void extractClassToTextPane(TypeReference type, String tabTitle, String path) throws Exception {   if (tabTitle == null || tabTitle.trim().length() < 1 || path == null) {    throw new FileEntryNotFoundException();   }   OpenFile sameTitledOpen = null;   for (OpenFile nextOpen : hmap) {    if (tabTitle.equals(nextOpen.name)) {     sameTitledOpen = nextOpen;     break;    }   }   if (sameTitledOpen != null && path.equals(sameTitledOpen.getPath()) &&     type.equals(sameTitledOpen.getType()) && sameTitledOpen.isContentValid()) {    addOrSwitchToTab(sameTitledOpen);    return;   }    // build tab content: do decompilation   String decompiledSource = extractClassToString(type);    // open tab, store type information   if (sameTitledOpen != null) {    sameTitledOpen.setContent(decompiledSource);    sameTitledOpen.setPath(path);    sameTitledOpen.setType(type);    sameTitledOpen.setContentValid(true);    addOrSwitchToTab(sameTitledOpen);   } else {    OpenFile open = new OpenFile(type, tabTitle, path, decompiledSource, theme);    open.setContentValid(true);    hmap.add(open);    addOrSwitchToTab(open);   }  }   private String extractClassToString(TypeReference type) throws Exception {   // synchronized: do not accept changes from menu while running   synchronized (settings) {    TypeDefinition resolvedType = null;    if (type == null || ((resolvedType = type.resolve()) == null)) {     throw new Exception("Unable to resolve type.");    }    StringWriter stringwriter = new StringWriter();    settings.getLanguage().decompileType(resolvedType,      new PlainTextOutput(stringwriter), decompilationOptions);    return stringwriter.toString();   }  }   private void extractSimpleFileEntryToTextPane(InputStream inputStream, String tabTitle, String path)    throws Exception {   if (inputStream == null || tabTitle == null || tabTitle.trim().length() < 1 || path == null) {    throw new FileEntryNotFoundException();   }   OpenFile sameTitledOpen = null;   for (OpenFile nextOpen : hmap) {    if (tabTitle.equals(nextOpen.name)) {     sameTitledOpen = nextOpen;     break;    }   }   if (sameTitledOpen != null && path.equals(sameTitledOpen.getPath())) {    addOrSwitchToTab(sameTitledOpen);    return;   }    // build tab content   StringBuilder sb = new StringBuilder();   long nonprintableCharactersCount = 0;   try (InputStreamReader inputStreamReader = new InputStreamReader(inputStream);     BufferedReader reader = new BufferedReader(inputStreamReader);) {    String line;    while ((line = reader.readLine()) != null) {     sb.append(line).append("\n");      for (byte nextByte : line.getBytes()) {      if (nextByte <= 0) {       nonprintableCharactersCount++;      }     }     }   }    // guess binary or text   String extension = "." + tabTitle.replaceAll("^[^\\.]*$", "").replaceAll("[^\\.]*\\.", "");   boolean isTextFile = (OpenFile.WELL_KNOWN_TEXT_FILE_EXTENSIONS.contains(extension) ||     nonprintableCharactersCount < sb.length() / 5);   if (!isTextFile) {    throw new FileIsBinaryException();   }    // open tab   if (sameTitledOpen != null) {    sameTitledOpen.setContent(sb.toString());    sameTitledOpen.setPath(path);    addOrSwitchToTab(sameTitledOpen);   } else {    OpenFile open = new OpenFile(tabTitle, path, sb.toString(), theme);    hmap.add(open);    addOrSwitchToTab(open);   }  }   private class TabChangeListener implements ChangeListener {   @Override   public void stateChanged(ChangeEvent e) {    int selectedIndex = house.getSelectedIndex();    if (selectedIndex < 0) {     return;    }    for (OpenFile open : hmap) {     if (house.indexOfTab(open.name) == selectedIndex) {       if (open.getType() != null && !open.isContentValid()) {       updateOpenClass(open);       break;      }      }    }   }  }   public void updateOpenClasses() {   // invalidate all open classes (update will hapen at tab change)   for (OpenFile open : hmap) {    open.setContentValid(false);   }   // ensure not showing old codes   for (OpenFile open : hmap) {    if (open.getType() != null) {     open.setContent("");    }   }   // update the current open tab - if it is a class   for (OpenFile open : hmap) {    if (open.getType() != null && isTabInForeground(open)) {     updateOpenClass(open);     break;    }   }  }   private void updateOpenClass(final OpenFile open) {   if (open.getType() == null) {    return;   }   new Thread(new Runnable() {    @Override    public void run() {     try {      bar.setVisible(true);      label.setText("Extracting: " + open.name);      String decompiledSource = extractClassToString(open.getType());      open.setContent(decompiledSource);      open.setContentValid(true);      label.setText("Complete");     } catch (Exception e) {      label.setText("Error, cannot update: " + open.name);     } finally {      bar.setVisible(false);     }    }   }).start();  }   private boolean isTabInForeground(OpenFile open) {   String title = open.name;   int selectedIndex = house.getSelectedIndex();   return (selectedIndex >= 0 && selectedIndex == house.indexOfTab(title));  }   private final class State implements AutoCloseable {   private final String key;   private final File file;   final JarFile jarFile;   final ITypeLoader typeLoader;    private State(String key, File file, JarFile jarFile, ITypeLoader typeLoader) {    this.key = VerifyArgument.notNull(key, "key");    this.file = VerifyArgument.notNull(file, "file");    this.jarFile = jarFile;    this.typeLoader = typeLoader;   }    @Override   public void close() {    if (typeLoader != null) {     Model.this.typeLoader.getTypeLoaders().remove(typeLoader);    }    Closer.tryClose(jarFile);   }    @SuppressWarnings("unused")   public File getFile() {    return file;   }    @SuppressWarnings("unused")   public String getKey() {    return key;   }  }   private class Tab extends JPanel {   private static final long serialVersionUID = -514663009333644974L;   private JLabel closeButton = new JLabel(new ImageIcon(Toolkit.getDefaultToolkit().getImage(     this.getClass().getResource("/resources/icon_close.png"))));   private JLabel tabTitle = new JLabel();   private String title = "";    public Tab(String t) {    super(new GridBagLayout());    this.setOpaque(false);     this.title = t;    this.tabTitle = new JLabel(title);     this.createTab();   }    public JLabel getButton() {    return this.closeButton;   }    public void createTab() {    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weightx = 1;    this.add(tabTitle, gbc);    gbc.gridx++;    gbc.insets = new Insets(0, 5, 0, 0);    gbc.anchor = GridBagConstraints.EAST;    this.add(closeButton, gbc);   }  }   private class CloseTab extends MouseAdapter {   String title;    public CloseTab(String title) {    this.title = title;   }    @Override   public void mouseClicked(MouseEvent e) {    int index = house.indexOfTab(title);    closeOpenTab(index);   }  }   public DefaultMutableTreeNode loadNodesByNames(DefaultMutableTreeNode node, List<String> originalNames) {   List<TreeNodeUserObject> args = new ArrayList<>();   for (String originalName : originalNames) {    args.add(new TreeNodeUserObject(originalName));   }   return loadNodesByUserObj(node, args);  }   public DefaultMutableTreeNode loadNodesByUserObj(DefaultMutableTreeNode node, List<TreeNodeUserObject> args) {   if (args.size() > 0) {    TreeNodeUserObject name = args.remove(0);    DefaultMutableTreeNode nod = getChild(node, name);    if (nod == null)     nod = new DefaultMutableTreeNode(name);    node.add(loadNodesByUserObj(nod, args));   }   return node;  }   @SuppressWarnings("unchecked")  public DefaultMutableTreeNode getChild(DefaultMutableTreeNode node, TreeNodeUserObject name) {   Enumeration<DefaultMutableTreeNode> entry = node.children();   while (entry.hasMoreElements()) {    DefaultMutableTreeNode nods = entry.nextElement();    if (((TreeNodeUserObject) nods.getUserObject()).getOriginalName().equals(name.getOriginalName())) {     return nods;    }   }   return null;  }   public void loadFile(File file) {   if (open)    closeFile();   this.file = file;   loadTree();  }   public void updateTree() {   TreeUtil treeUtil = new TreeUtil(tree);   treeExpansionState = treeUtil.getExpansionState();   loadTree();  }   public void loadTree() {   new Thread(new Runnable() {    @Override    public void run() {     try {      if (file == null) {       return;      }      tree.setModel(new DefaultTreeModel(null));       if (file.length() > MAX_JAR_FILE_SIZE_BYTES) {       throw new TooLargeFileException(file.length());      }      if (file.getName().endsWith(".zip") || file.getName().endsWith(".jar")) {       JarFile jfile;       jfile = new JarFile(file);       label.setText("Loading: " + jfile.getName());       bar.setVisible(true);        JarEntryFilter jarEntryFilter = new JarEntryFilter(jfile);       List<String> mass = null;       if (luytenPrefs.isFilterOutInnerClassEntries()) {        mass = jarEntryFilter.getEntriesWithoutInnerClasses();       } else {        mass = jarEntryFilter.getAllEntriesFromJar();       }       buildTreeFromMass(mass);        if (state == null) {        ITypeLoader jarLoader = new JarTypeLoader(jfile);        typeLoader.getTypeLoaders().add(jarLoader);        state = new State(file.getCanonicalPath(), file, jfile, jarLoader);       }       open = true;       label.setText("Complete");      } else {       TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));       final DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);       tree.setModel(new DefaultTreeModel(top));       settings.setTypeLoader(new InputTypeLoader());       open = true;       label.setText("Complete");        // open it automatically       new Thread() {        public void run() {         TreePath trp = new TreePath(top.getPath());         openEntryByTreePath(trp);        };       }.start();      }       if (treeExpansionState != null) {       try {        TreeUtil treeUtil = new TreeUtil(tree);        treeUtil.restoreExpanstionState(treeExpansionState);       } catch (Exception exc) {        exc.printStackTrace();       }      }     } catch (TooLargeFileException e) {      label.setText("File is too large: " + file.getName() + " - size: " + e.getReadableFileSize());      closeFile();     } catch (Exception e1) {      e1.printStackTrace();      label.setText("Cannot open: " + file.getName());      closeFile();     } finally {      mainWindow.onFileLoadEnded(file, open);      bar.setVisible(false);     }    }    }).start();  }   private void buildTreeFromMass(List<String> mass) {   if (luytenPrefs.isPackageExplorerStyle()) {    buildFlatTreeFromMass(mass);   } else {    buildDirectoryTreeFromMass(mass);   }  }   private void buildDirectoryTreeFromMass(List<String> mass) {   TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));   DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);   List<String> sort = new ArrayList<String>();   Collections.sort(mass, String.CASE_INSENSITIVE_ORDER);   for (String m : mass)    if (m.contains("META-INF") && !sort.contains(m))     sort.add(m);   Set<String> set = new HashSet<String>();   for (String m : mass) {    if (m.contains("/")) {     set.add(m.substring(0, m.lastIndexOf("/") + 1));    }   }   List<String> packs = Arrays.asList(set.toArray(new String[] {}));   Collections.sort(packs, String.CASE_INSENSITIVE_ORDER);   Collections.sort(packs, new Comparator<String>() {    public int compare(String o1, String o2) {     return o2.split("/").length - o1.split("/").length;    }   });   for (String pack : packs)    for (String m : mass)     if (!m.contains("META-INF") && m.contains(pack)       && !m.replace(pack, "").contains("/"))      sort.add(m);   for (String m : mass)    if (!m.contains("META-INF") && !m.contains("/") && !sort.contains(m))     sort.add(m);   for (String pack : sort) {    LinkedList<String> list = new LinkedList<String>(Arrays.asList(pack.split("/")));    loadNodesByNames(top, list);   }   tree.setModel(new DefaultTreeModel(top));  }   private void buildFlatTreeFromMass(List<String> mass) {   TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));   DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);    TreeMap<String, TreeSet<String>> packages = new TreeMap<>();   HashSet<String> classContainingPackageRoots = new HashSet<>();    Comparator<String> sortByFileExtensionsComparator = new Comparator<String>() {    // (assertion: mass does not contain null elements)    @Override    public int compare(String o1, String o2) {     int comp = o1.replaceAll("[^\\.]*\\.", "").compareTo(o2.replaceAll("[^\\.]*\\.", ""));     if (comp != 0)      return comp;     return o1.compareTo(o2);    }   };    for (String entry : mass) {    String packagePath = "";    String packageRoot = "";    if (entry.contains("/")) {     packagePath = entry.replaceAll("/[^/]*$", "");     packageRoot = entry.replaceAll("/.*$", "");    }    String packageEntry = entry.replace(packagePath + "/", "");    if (!packages.containsKey(packagePath)) {     packages.put(packagePath, new TreeSet<String>(sortByFileExtensionsComparator));    }    packages.get(packagePath).add(packageEntry);    if (!entry.startsWith("META-INF") && packageRoot.trim().length() > 0 &&      entry.matches(".*\\.(class|java|prop|properties)$")) {     classContainingPackageRoots.add(packageRoot);    }   }    // META-INF comes first -> not flat   for (String packagePath : packages.keySet()) {    if (packagePath.startsWith("META-INF")) {     List<String> packagePathElements = Arrays.asList(packagePath.split("/"));     for (String entry : packages.get(packagePath)) {      ArrayList<String> list = new ArrayList<>(packagePathElements);      list.add(entry);      loadNodesByNames(top, list);     }    }   }    // real packages: path starts with a classContainingPackageRoot -> flat   for (String packagePath : packages.keySet()) {    String packageRoot = packagePath.replaceAll("/.*$", "");    if (classContainingPackageRoots.contains(packageRoot)) {     for (String entry : packages.get(packagePath)) {      ArrayList<TreeNodeUserObject> list = new ArrayList<>();      list.add(new TreeNodeUserObject(packagePath, packagePath.replaceAll("/", ".")));      list.add(new TreeNodeUserObject(entry));      loadNodesByUserObj(top, list);     }    }   }    // the rest, not real packages but directories -> not flat   for (String packagePath : packages.keySet()) {    String packageRoot = packagePath.replaceAll("/.*$", "");    if (!classContainingPackageRoots.contains(packageRoot) &&      !packagePath.startsWith("META-INF") && packagePath.length() > 0) {     List<String> packagePathElements = Arrays.asList(packagePath.split("/"));     for (String entry : packages.get(packagePath)) {      ArrayList<String> list = new ArrayList<>(packagePathElements);      list.add(entry);      loadNodesByNames(top, list);     }    }   }    // the default package -> not flat   String packagePath = "";   if (packages.containsKey(packagePath)) {    for (String entry : packages.get(packagePath)) {     ArrayList<String> list = new ArrayList<>();     list.add(entry);     loadNodesByNames(top, list);    }   }   tree.setModel(new DefaultTreeModel(top));  }   public void closeFile() {   for (OpenFile co : hmap) {    int pos = house.indexOfTab(co.name);    if (pos >= 0)     house.remove(pos);   }    final State oldState = state;   Model.this.state = null;   if (oldState != null) {    Closer.tryClose(oldState);   }    hmap.clear();   tree.setModel(new DefaultTreeModel(null));   metadataSystem = new MetadataSystem(typeLoader);   file = null;   treeExpansionState = null;   open = false;   mainWindow.onFileLoadEnded(file, open);  }   public void changeTheme(String xml) {   InputStream in = getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + xml);   try {    if (in != null) {     theme = Theme.load(in);     for (OpenFile f : hmap) {      theme.apply(f.textArea);     }    }   } catch (Exception e1) {    e1.printStackTrace();    JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);   }  }   public File getOpenedFile() {   File openedFile = null;   if (file != null && open) {    openedFile = file;   }   if (openedFile == null) {    label.setText("No open file");   }   return openedFile;  }   public String getCurrentTabTitle() {   String tabTitle = null;   try {    int pos = house.getSelectedIndex();    if (pos >= 0) {     tabTitle = house.getTitleAt(pos);    }   } catch (Exception e1) {    e1.printStackTrace();   }   if (tabTitle == null) {    label.setText("No open tab");   }   return tabTitle;  }   public RSyntaxTextArea getCurrentTextArea() {   RSyntaxTextArea currentTextArea = null;   try {    int pos = house.getSelectedIndex();    if (pos >= 0) {     RTextScrollPane co = (RTextScrollPane) house.getComponentAt(pos);     currentTextArea = (RSyntaxTextArea) co.getViewport().getView();    }   } catch (Exception e1) {    e1.printStackTrace();   }   if (currentTextArea == null) {    label.setText("No open tab");   }   return currentTextArea;  }   public void startWarmUpThread() {   new Thread() {    public void run() {     try {      Thread.sleep(500);      String internalName = FindBox.class.getName();      TypeReference type = metadataSystem.lookupType(internalName);      TypeDefinition resolvedType = null;      if ((type == null) || ((resolvedType = type.resolve()) == null)) {       return;      }      StringWriter stringwriter = new StringWriter();      settings.getLanguage().decompileType(resolvedType,        new PlainTextOutput(stringwriter), decompilationOptions);      String decompiledSource = stringwriter.toString();      OpenFile open = new OpenFile(internalName, "*/" + internalName, decompiledSource, theme);      JTabbedPane pane = new JTabbedPane();      pane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);      pane.addTab("title", open.scrollPane);      pane.setSelectedIndex(pane.indexOfTab("title"));     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  } } " compose:StringConcatenation merge: LineBased]
					[NT -> ConfigSaver.java.merge : .java.merge-File]
						[T -> ConfigSaver.java : .java-Content "package com.modcrafting.luyten;  import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.prefs.Preferences; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.languages.Language; import com.strobel.decompiler.languages.Languages; import com.strobel.decompiler.languages.java.JavaFormattingOptions;  public class ConfigSaver {   private static final String FLATTEN_SWITCH_BLOCKS_ID = "flattenSwitchBlocks";  private static final String FORCE_EXPLICIT_IMPORTS_ID = "forceExplicitImports";  private static final String SHOW_SYNTHETIC_MEMBERS_ID = "showSyntheticMembers";  private static final String EXCLUDE_NESTED_TYPES_ID = "excludeNestedTypes";  private static final String FORCE_EXPLICIT_TYPE_ARGUMENTS_ID = "forceExplicitTypeArguments";  private static final String RETAIN_REDUNDANT_CASTS_ID = "retainRedundantCasts";  private static final String INCLUDE_ERROR_DIAGNOSTICS_ID = "includeErrorDiagnostics";  private static final String LANGUAGE_NAME_ID = "languageName";   private static final String MAIN_WINDOW_ID_PREFIX = "main";  private static final String FIND_WINDOW_ID_PREFIX = "find";  private static final String WINDOW_IS_FULL_SCREEN_ID = "WindowIsFullScreen";  private static final String WINDOW_WIDTH_ID = "WindowWidth";  private static final String WINDOW_HEIGHT_ID = "WindowHeight";  private static final String WINDOW_X_ID = "WindowX";  private static final String WINDOW_Y_ID = "WindowY";   private DecompilerSettings decompilerSettings;  private WindowPosition mainWindowPosition;  private WindowPosition findWindowPosition;  private LuytenPreferences luytenPreferences;   private static ConfigSaver theLoadedInstance;   /**   * Do not instantiate, get the loaded instance   */  private ConfigSaver() {}   public static ConfigSaver getLoadedInstance() {   if (theLoadedInstance == null) {    synchronized (ConfigSaver.class) {     if (theLoadedInstance == null) {      theLoadedInstance = new ConfigSaver();      theLoadedInstance.loadConfig();     }    }   }   return theLoadedInstance;  }   /**   * Do not load, get the loaded instance   */  private void loadConfig() {   decompilerSettings = new DecompilerSettings();   if (decompilerSettings.getFormattingOptions() == null) {    decompilerSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   luytenPreferences = new LuytenPreferences();   mainWindowPosition = new WindowPosition();   findWindowPosition = new WindowPosition();   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     decompilerSettings.setFlattenSwitchBlocks(prefs.getBoolean(FLATTEN_SWITCH_BLOCKS_ID,      decompilerSettings.getFlattenSwitchBlocks()));    decompilerSettings.setForceExplicitImports(prefs.getBoolean(FORCE_EXPLICIT_IMPORTS_ID,      decompilerSettings.getForceExplicitImports()));    decompilerSettings.setShowSyntheticMembers(prefs.getBoolean(SHOW_SYNTHETIC_MEMBERS_ID,      decompilerSettings.getShowSyntheticMembers()));    decompilerSettings.setExcludeNestedTypes(prefs.getBoolean(EXCLUDE_NESTED_TYPES_ID,      decompilerSettings.getExcludeNestedTypes()));    decompilerSettings.setForceExplicitTypeArguments(prefs.getBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID,      decompilerSettings.getForceExplicitTypeArguments()));    decompilerSettings.setRetainRedundantCasts(prefs.getBoolean(RETAIN_REDUNDANT_CASTS_ID,      decompilerSettings.getRetainRedundantCasts()));    decompilerSettings.setIncludeErrorDiagnostics(prefs.getBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID,      decompilerSettings.getIncludeErrorDiagnostics()));    decompilerSettings.setLanguage(findLanguageByName(prefs.get(LANGUAGE_NAME_ID,      decompilerSettings.getLanguage().getName())));     mainWindowPosition = loadWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX);    findWindowPosition = loadWindowPosition(prefs, FIND_WINDOW_ID_PREFIX);    luytenPreferences = loadLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }   private WindowPosition loadWindowPosition(Preferences prefs, String windowIdPrefix) {   WindowPosition windowPosition = new WindowPosition();   windowPosition.setFullScreen(prefs.getBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, false));   windowPosition.setWindowWidth(prefs.getInt(windowIdPrefix + WINDOW_WIDTH_ID, 0));   windowPosition.setWindowHeight(prefs.getInt(windowIdPrefix + WINDOW_HEIGHT_ID, 0));   windowPosition.setWindowX(prefs.getInt(windowIdPrefix + WINDOW_X_ID, 0));   windowPosition.setWindowY(prefs.getInt(windowIdPrefix + WINDOW_Y_ID, 0));   return windowPosition;  }   // load preferences by their java variable names  private LuytenPreferences loadLuytenPreferences(Preferences prefs) throws Exception {   LuytenPreferences newLuytenPrefs = new LuytenPreferences();   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object defaultVal = field.get(newLuytenPrefs);     if (field.getType() == String.class) {     String defaultStr = (String) (defaultVal == null ? "" : defaultVal);     field.set(newLuytenPrefs, prefs.get(prefId, defaultStr));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     Boolean defaultBool = (Boolean) (defaultVal == null ? new Boolean(false) : defaultVal);     field.setBoolean(newLuytenPrefs, prefs.getBoolean(prefId, defaultBool));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     Integer defaultInt = (Integer) (defaultVal == null ? new Integer(0) : defaultVal);     field.setInt(newLuytenPrefs, prefs.getInt(prefId, defaultInt));    }   }   return newLuytenPrefs;  }   public void saveConfig() {   // Registry path on Windows Xp:   // HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\modcrafting\luyten   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     prefs.putBoolean(FLATTEN_SWITCH_BLOCKS_ID, decompilerSettings.getFlattenSwitchBlocks());    prefs.putBoolean(FORCE_EXPLICIT_IMPORTS_ID, decompilerSettings.getForceExplicitImports());    prefs.putBoolean(SHOW_SYNTHETIC_MEMBERS_ID, decompilerSettings.getShowSyntheticMembers());    prefs.putBoolean(EXCLUDE_NESTED_TYPES_ID, decompilerSettings.getExcludeNestedTypes());    prefs.putBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID, decompilerSettings.getForceExplicitTypeArguments());    prefs.putBoolean(RETAIN_REDUNDANT_CASTS_ID, decompilerSettings.getRetainRedundantCasts());    prefs.putBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID, decompilerSettings.getIncludeErrorDiagnostics());    prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     saveWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX, mainWindowPosition);    saveWindowPosition(prefs, FIND_WINDOW_ID_PREFIX, findWindowPosition);    saveLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }   private void saveWindowPosition(Preferences prefs, String windowIdPrefix, WindowPosition windowPosition) {   prefs.putBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, windowPosition.isFullScreen());   prefs.putInt(windowIdPrefix + WINDOW_WIDTH_ID, windowPosition.getWindowWidth());   prefs.putInt(windowIdPrefix + WINDOW_HEIGHT_ID, windowPosition.getWindowHeight());   prefs.putInt(windowIdPrefix + WINDOW_X_ID, windowPosition.getWindowX());   prefs.putInt(windowIdPrefix + WINDOW_Y_ID, windowPosition.getWindowY());  }   // save preferences by their java variable names  private void saveLuytenPreferences(Preferences prefs) throws Exception {   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object value = field.get(luytenPreferences);     if (field.getType() == String.class) {     prefs.put(prefId, (String) (value == null ? "" : value));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     prefs.putBoolean(prefId, (Boolean) (value == null ? new Boolean(false) : value));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     prefs.putInt(prefId, (Integer) (value == null ? new Integer(0) : value));    }   }  }   private Language findLanguageByName(String languageName) {   if (languageName != null) {     if (languageName.equals(Languages.java().getName())) {     return Languages.java();    } else if (languageName.equals(Languages.bytecode().getName())) {     return Languages.bytecode();    } else if (languageName.equals(Languages.bytecodeAst().getName())) {     return Languages.bytecodeAst();    }     for (Language language : Languages.debug()) {     if (languageName.equals(language.getName())) {      return language;     }    }   }   return Languages.java();  }   public DecompilerSettings getDecompilerSettings() {   return decompilerSettings;  }   public WindowPosition getMainWindowPosition() {   return mainWindowPosition;  }   public WindowPosition getFindWindowPosition() {   return findWindowPosition;  }    public LuytenPreferences getLuytenPreferences() {   return luytenPreferences;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Luyten.java.merge : .java.merge-File]
						[T -> Luyten.java : .java-Content "package com.modcrafting.luyten;  import java.io.File; import javax.swing.SwingUtilities; import javax.swing.UIManager;  /**  * Starter, the main class  */ public class Luyten {   public static void main(String[] args) {   try {    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());   } catch (Exception e) {    e.printStackTrace();   }    // for TotalCommander External Viewer setting:   // javaw -jar "c:\Program Files\Luyten\luyten.jar"   // (TC will not complain about temporary file when opening .class from .zip or .jar)   final File fileFromCommandLine = getFileFromCommandLine(args);    SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     MainWindow mainWindow = new MainWindow(fileFromCommandLine);     mainWindow.setVisible(true);    }   });  }   public static File getFileFromCommandLine(String[] args) {   File fileFromCommandLine = null;   try {    if (args.length > 0) {     String realFileName = new File(args[0]).getCanonicalPath();     fileFromCommandLine = new File(realFileName);    }   } catch (Exception e) {    e.printStackTrace();   }   return fileFromCommandLine;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> TreeUtil.java.merge : .java.merge-File]
						[T -> TreeUtil.java : .java-Content "package com.modcrafting.luyten;  import java.util.HashSet; import java.util.Set; import javax.swing.JTree; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.TreePath;  public class TreeUtil {   private JTree tree;   public TreeUtil() {}   public TreeUtil(JTree tree) {   this.tree = tree;  }   public Set<String> getExpansionState() {   Set<String> openedSet = new HashSet<>();   if (tree != null) {    int rowCount = tree.getRowCount();    for (int i = 0; i < rowCount; i++) {     TreePath path = tree.getPathForRow(i);     if (tree.isExpanded(path)) {      String rowPathStr = getRowPathStr(path);      // for switching Package Explorer on/off      openedSet.addAll(getAllParentPathsStr(rowPathStr));     }    }   }   return openedSet;  }   private Set<String> getAllParentPathsStr(String rowPathStr) {   Set<String> parents = new HashSet<>();   parents.add(rowPathStr);   if (rowPathStr.contains("/")) {    String[] pathElements = rowPathStr.split("/");    String path = "";    for (String pathElement : pathElements) {     path = path + pathElement + "/";     parents.add(path);    }   }   return parents;  }   public void restoreExpanstionState(Set<String> expansionState) {   if (tree != null && expansionState != null) {    // tree.getRowCount() changes at tree.expandRow()    for (int i = 0; i < tree.getRowCount(); i++) {     TreePath path = tree.getPathForRow(i);     if (expansionState.contains(getRowPathStr(path))) {      tree.expandRow(i);     }    }   }  }   private String getRowPathStr(TreePath trp) {   String pathStr = "";   if (trp.getPathCount() > 1) {    for (int i = 1; i < trp.getPathCount(); i++) {     DefaultMutableTreeNode node = (DefaultMutableTreeNode) trp.getPathComponent(i);     TreeNodeUserObject userObject = (TreeNodeUserObject) node.getUserObject();     pathStr = pathStr + userObject.getOriginalName() + "/";    }   }   return pathStr;  }   public JTree getTree() {   return tree;  }   public void setTree(JTree tree) {   this.tree = tree;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FindBox.java.merge : .java.merge-File]
						[T -> FindBox.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Dimension; import java.awt.Toolkit; import java.awt.event.ActionEvent; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.BorderFactory; import javax.swing.GroupLayout; import javax.swing.GroupLayout.Alignment; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComponent; import javax.swing.JDialog; import javax.swing.JLabel; import javax.swing.JTextField; import javax.swing.KeyStroke; import javax.swing.SwingConstants; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rtextarea.SearchContext; import org.fife.ui.rtextarea.SearchEngine;  public class FindBox extends JDialog {  private static final long serialVersionUID = -4125409760166690462L;   private JCheckBox mcase;  private JCheckBox regex;  private JCheckBox wholew;  private JCheckBox reverse;  private JButton findButton;  private JTextField textField;  private MainWindow mainWindow;   public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();  }   public void hideFindBox() {   this.setVisible(false);  }   public FindBox(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();    JLabel label = new JLabel("Find What:");   textField = new JTextField();    RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();   if (pane != null) {    textField.setText(pane.getSelectedText());   }   mcase = new JCheckBox("Match Case");   regex = new JCheckBox("Regex");   wholew = new JCheckBox("Whole Words");   reverse = new JCheckBox("Search Backwards");    findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    mcase.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   regex.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   wholew.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   reverse.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     Math.min((int) (screenSize.height * 0.20), 200));   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    layout.setHorizontalGroup(layout.createSequentialGroup()     .addComponent(label)     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(textField)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(mcase)           .addComponent(wholew))         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(regex)           .addComponent(reverse))))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(findButton))     );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(Alignment.BASELINE)       .addComponent(label)       .addComponent(textField)       .addComponent(findButton))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(mcase)           .addComponent(regex))         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(wholew)           .addComponent(reverse))))     );    this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();    this.setName("Find");   this.setTitle("Find");   this.setVisible(true);  }   private class FindButton extends AbstractAction {   private static final long serialVersionUID = 75954129199541874L;    @Override   public void actionPerformed(ActionEvent event) {    if (textField.getText().length() == 0)     return;     RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();    if (pane == null)     return;     SearchContext context = new SearchContext();    context.setSearchFor(textField.getText());    context.setMatchCase(mcase.isSelected());    context.setRegularExpression(regex.isSelected());    context.setSearchForward(!reverse.isSelected());    context.setWholeWord(wholew.isSelected());     if (!SearchEngine.find(pane, context)) {     pane.setSelectionStart(0);     pane.setSelectionEnd(0);    }   }   }   private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }   private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(), windowPosition.getWindowY());   }  }   private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();     windowPosition.readPositionFromDialog(FindBox.this);    }   });  } } " compose:StringConcatenation merge: LineBased]
					[NT -> MainMenuBar.java.merge : .java.merge-File]
						[T -> MainMenuBar.java : .java-Content "package com.modcrafting.luyten;  import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.util.Collections; import java.util.HashMap; import java.util.Map; import javax.swing.AbstractAction; import javax.swing.AbstractButton; import javax.swing.ButtonGroup; import javax.swing.ButtonModel; import javax.swing.JCheckBox; import javax.swing.JMenu; import javax.swing.JMenuBar; import javax.swing.JMenuItem; import javax.swing.JOptionPane; import javax.swing.JRadioButtonMenuItem; import javax.swing.KeyStroke; import javax.swing.text.DefaultEditorKit; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.languages.Language; import com.strobel.decompiler.languages.Languages;  /**  * Main menu (only MainWindow should be called from here)  */ public class MainMenuBar extends JMenuBar {  private static final long serialVersionUID = 1L;   private final MainWindow mainWindow;  private final Map<String, Language> languageLookup = new HashMap<String, Language>();   private JCheckBox flattenSwitchBlocks;  private JCheckBox forceExplicitImports;  private JCheckBox forceExplicitTypes;  private JCheckBox showSyntheticMembers;  private JCheckBox excludeNestedTypes;  private JCheckBox retainRedundantCasts;  private JCheckBox showDebugInfo;  private JRadioButtonMenuItem java;  private JRadioButtonMenuItem bytecode;  private JRadioButtonMenuItem bytecodeAST;  private ButtonGroup languagesGroup;  private ButtonGroup themesGroup;  private JCheckBox packageExplorerStyle;  private JCheckBox filterOutInnerClassEntries;  private JCheckBox singleClickOpenEnabled;  private JCheckBox exitByEscEnabled;  private DecompilerSettings settings;  private LuytenPreferences luytenPrefs;   public MainMenuBar(MainWindow mainWnd) {   this.mainWindow = mainWnd;   ConfigSaver configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    final JMenu fileMenu = new JMenu("File");   fileMenu.add(new JMenuItem("..."));   this.add(fileMenu);   final JMenu editMenu = new JMenu("Edit");   editMenu.add(new JMenuItem("..."));   this.add(editMenu);   final JMenu themesMenu = new JMenu("Themes");   themesMenu.add(new JMenuItem("..."));   this.add(themesMenu);   final JMenu operationMenu = new JMenu("Operation");   operationMenu.add(new JMenuItem("..."));   this.add(operationMenu);   final JMenu settingsMenu = new JMenu("Settings");   settingsMenu.add(new JMenuItem("..."));   this.add(settingsMenu);   final JMenu helpMenu = new JMenu("Help");   helpMenu.add(new JMenuItem("..."));   this.add(helpMenu);    // start quicker   new Thread() {    public void run() {     try {      // build menu later      buildFileMenu(fileMenu);      refreshMenuPopup(fileMenu);       buildEditMenu(editMenu);      refreshMenuPopup(editMenu);       buildThemesMenu(themesMenu);      refreshMenuPopup(themesMenu);       buildOperationMenu(operationMenu);      refreshMenuPopup(operationMenu);       buildSettingsMenu(settingsMenu);      refreshMenuPopup(settingsMenu);       buildHelpMenu(helpMenu);      refreshMenuPopup(helpMenu);     } catch (Exception e) {      e.printStackTrace();     }    }     // refresh currently opened menu     // (if user selected a menu before it was ready)    private void refreshMenuPopup(JMenu menu) {     try {      if (menu.isPopupMenuVisible()) {       menu.getPopupMenu().setVisible(false);       menu.getPopupMenu().setVisible(true);      }     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }   private void buildFileMenu(final JMenu fileMenu) {   fileMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Open File...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onOpenFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Close");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onCloseFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Save As...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAsMenu();    }   });   fileMenu.add(menuItem);    menuItem = new JMenuItem("Save All...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAllMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Recent Files");   menuItem.setEnabled(false);   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Exit");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onExitMenu();    }   });   fileMenu.add(menuItem);  }   private void buildEditMenu(JMenu editMenu) {   editMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Cut");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    menuItem = new JMenuItem("Copy");   menuItem.addActionListener(new DefaultEditorKit.CopyAction());   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));   editMenu.add(menuItem);    menuItem = new JMenuItem("Paste");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    editMenu.addSeparator();    menuItem = new JMenuItem("Select All");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSelectAllMenu();    }   });   editMenu.add(menuItem);   editMenu.addSeparator();    menuItem = new JMenuItem("Find...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onFindMenu();    }   });   editMenu.add(menuItem);  }   private void buildThemesMenu(JMenu themesMenu) {   themesMenu.removeAll();   themesGroup = new ButtonGroup();   JRadioButtonMenuItem a = new JRadioButtonMenuItem(new ThemeAction("Default", "default.xml"));   a.setSelected("default.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Dark", "dark.xml"));   a.setSelected("dark.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Eclipse", "eclipse.xml"));   a.setSelected("eclipse.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Visual Studio", "vs.xml"));   a.setSelected("vs.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);  }   private void buildOperationMenu(JMenu operationMenu) {   operationMenu.removeAll();   packageExplorerStyle = new JCheckBox("Package Explorer Style");   packageExplorerStyle.setSelected(luytenPrefs.isPackageExplorerStyle());   packageExplorerStyle.setContentAreaFilled(false);   packageExplorerStyle.setFocusable(false);   packageExplorerStyle.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setPackageExplorerStyle(packageExplorerStyle.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(packageExplorerStyle);      filterOutInnerClassEntries = new JCheckBox("Filter Out Inner Class Entries");   filterOutInnerClassEntries.setSelected(luytenPrefs.isFilterOutInnerClassEntries());   filterOutInnerClassEntries.setContentAreaFilled(false);   filterOutInnerClassEntries.setFocusable(false);   filterOutInnerClassEntries.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setFilterOutInnerClassEntries(filterOutInnerClassEntries.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(filterOutInnerClassEntries);    singleClickOpenEnabled = new JCheckBox("Single Click Open");   singleClickOpenEnabled.setSelected(luytenPrefs.isSingleClickOpenEnabled());   singleClickOpenEnabled.setContentAreaFilled(false);   singleClickOpenEnabled.setFocusable(false);   singleClickOpenEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setSingleClickOpenEnabled(singleClickOpenEnabled.isSelected());    }   });   operationMenu.add(singleClickOpenEnabled);    exitByEscEnabled = new JCheckBox("Exit By Esc");   exitByEscEnabled.setSelected(luytenPrefs.isExitByEscEnabled());   exitByEscEnabled.setContentAreaFilled(false);   exitByEscEnabled.setFocusable(false);   exitByEscEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setExitByEscEnabled(exitByEscEnabled.isSelected());    }   });   operationMenu.add(exitByEscEnabled);  }   private void buildSettingsMenu(JMenu settingsMenu) {   settingsMenu.removeAll();   ActionListener settingsChanged = new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     new Thread() {      @Override      public void run() {       populateSettingsFromSettingsMenu();       mainWindow.onSettingsChanged();      }     }.start();    }   };   flattenSwitchBlocks = new JCheckBox("Flatten Switch Blocks");   flattenSwitchBlocks.setSelected(settings.getFlattenSwitchBlocks());   flattenSwitchBlocks.setContentAreaFilled(false);   flattenSwitchBlocks.setFocusable(false);   flattenSwitchBlocks.addActionListener(settingsChanged);   settingsMenu.add(flattenSwitchBlocks);    forceExplicitImports = new JCheckBox("Force Explicit Imports");   forceExplicitImports.setSelected(settings.getForceExplicitImports());   forceExplicitImports.setContentAreaFilled(false);   forceExplicitImports.setFocusable(false);   forceExplicitImports.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitImports);    forceExplicitTypes = new JCheckBox("Force Explicit Types");   forceExplicitTypes.setSelected(settings.getForceExplicitTypeArguments());   forceExplicitTypes.setContentAreaFilled(false);   forceExplicitTypes.setFocusable(false);   forceExplicitTypes.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitTypes);    showSyntheticMembers = new JCheckBox("Show Synthetic Members");   showSyntheticMembers.setSelected(settings.getShowSyntheticMembers());   showSyntheticMembers.setContentAreaFilled(false);   showSyntheticMembers.setFocusable(false);   showSyntheticMembers.addActionListener(settingsChanged);   settingsMenu.add(showSyntheticMembers);    excludeNestedTypes = new JCheckBox("Exclude Nested Types");   excludeNestedTypes.setSelected(settings.getExcludeNestedTypes());   excludeNestedTypes.setContentAreaFilled(false);   excludeNestedTypes.setFocusable(false);   excludeNestedTypes.addActionListener(settingsChanged);   settingsMenu.add(excludeNestedTypes);    retainRedundantCasts = new JCheckBox("Retain Redundant Casts");   retainRedundantCasts.setSelected(settings.getRetainRedundantCasts());   retainRedundantCasts.setContentAreaFilled(false);   retainRedundantCasts.setFocusable(false);   retainRedundantCasts.addActionListener(settingsChanged);   settingsMenu.add(retainRedundantCasts);    JMenu debugSettingsMenu = new JMenu("Debug Settings");   showDebugInfo = new JCheckBox("Include Error Diagnostics");   showDebugInfo.setSelected(settings.getIncludeErrorDiagnostics());   showDebugInfo.setContentAreaFilled(false);   showDebugInfo.setFocusable(false);   showDebugInfo.addActionListener(settingsChanged);    debugSettingsMenu.add(showDebugInfo);   settingsMenu.add(debugSettingsMenu);   settingsMenu.addSeparator();    languageLookup.put(Languages.java().getName(), Languages.java());   languageLookup.put(Languages.bytecode().getName(), Languages.bytecode());   languageLookup.put(Languages.bytecodeAst().getName(), Languages.bytecodeAst());    languagesGroup = new ButtonGroup();   java = new JRadioButtonMenuItem(Languages.java().getName());   java.getModel().setActionCommand(Languages.java().getName());   java.setSelected(Languages.java().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(java);   settingsMenu.add(java);   bytecode = new JRadioButtonMenuItem(Languages.bytecode().getName());   bytecode.getModel().setActionCommand(Languages.bytecode().getName());   bytecode.setSelected(Languages.bytecode().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecode);   settingsMenu.add(bytecode);   bytecodeAST = new JRadioButtonMenuItem(Languages.bytecodeAst().getName());   bytecodeAST.getModel().setActionCommand(Languages.bytecodeAst().getName());   bytecodeAST.setSelected(Languages.bytecodeAst().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecodeAST);   settingsMenu.add(bytecodeAST);    JMenu debugLanguagesMenu = new JMenu("Debug Languages");   for (final Language language : Languages.debug()) {    final JRadioButtonMenuItem m = new JRadioButtonMenuItem(language.getName());    m.getModel().setActionCommand(language.getName());    m.setSelected(language.getName().equals(settings.getLanguage().getName()));    languagesGroup.add(m);    debugLanguagesMenu.add(m);    languageLookup.put(language.getName(), language);   }   for (AbstractButton button : Collections.list(languagesGroup.getElements())) {    button.addActionListener(settingsChanged);   }   settingsMenu.add(debugLanguagesMenu);  }   private void buildHelpMenu(JMenu helpMenu) {   helpMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Legal");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onLegalMenu();    }   });   helpMenu.add(menuItem);   menuItem = new JMenuItem("About");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent event) {     JOptionPane.showMessageDialog(null,       "Luyten Gui \n" +         "by Deathmarine\n\n" +         "Powered By\nProcyon\n" +         "(c) 2013 Mike Strobel\n\n" +         "RSyntaxTextArea\n" +         "(c) 2012 Robert Futrell\n" +         "All rights reserved.");    }   });   helpMenu.add(menuItem);  }   private void populateSettingsFromSettingsMenu() {   // synchronized: do not disturb decompiler at work (synchronize every time before run decompiler)   synchronized (settings) {    settings.setFlattenSwitchBlocks(flattenSwitchBlocks.isSelected());    settings.setForceExplicitImports(forceExplicitImports.isSelected());    settings.setShowSyntheticMembers(showSyntheticMembers.isSelected());    settings.setExcludeNestedTypes(excludeNestedTypes.isSelected());    settings.setForceExplicitTypeArguments(forceExplicitTypes.isSelected());    settings.setRetainRedundantCasts(retainRedundantCasts.isSelected());    settings.setIncludeErrorDiagnostics(showDebugInfo.isSelected());    //    // Note: You shouldn't ever need to set this.  It's only for languages that support catch    //       blocks without an exception variable.  Java doesn't allow this.  I think Scala does.    //    // settings.setAlwaysGenerateExceptionVariableForCatchBlocks(true);    //     final ButtonModel selectedLanguage = languagesGroup.getSelection();    if (selectedLanguage != null) {     final Language language = languageLookup.get(selectedLanguage.getActionCommand());      if (language != null)      settings.setLanguage(language);    }     if (java.isSelected()) {     settings.setLanguage(Languages.java());    } else if (bytecode.isSelected()) {     settings.setLanguage(Languages.bytecode());    } else if (bytecodeAST.isSelected()) {     settings.setLanguage(Languages.bytecodeAst());    }   }  }   private class ThemeAction extends AbstractAction {   private static final long serialVersionUID = -6618680171943723199L;   private String xml;    public ThemeAction(String name, String xml) {    putValue(NAME, name);    this.xml = xml;   }    @Override   public void actionPerformed(ActionEvent e) {    luytenPrefs.setThemeXml(xml);    mainWindow.onThemesChanged();   }  } } " compose:StringConcatenation merge: LineBased]
					[NT -> TooLargeFileException.java.merge : .java.merge-File]
						[T -> TooLargeFileException.java : .java-Content "package com.modcrafting.luyten;  import java.text.DecimalFormat;  public class TooLargeFileException extends Exception {  private static final long serialVersionUID = 1L;  private long size;   public TooLargeFileException(long size) {   this.size = size;  }   public String getReadableFileSize() {   if (size <= 0)    return "0";   final String[] units = new String[] {"B", "KB", "MB", "GB", "TB"};   int digitGroups = (int) (Math.log10(size) / Math.log10(1024));   return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FileSaver.java.merge : .java.merge-File]
						[T -> FileSaver.java : .java-Content "package com.modcrafting.luyten;  import java.io.BufferedOutputStream; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.InputStream; import java.io.OutputStreamWriter; import java.io.StringWriter; import java.io.Writer; import java.util.Enumeration; import java.util.List; import java.util.jar.JarEntry; import java.util.jar.JarFile; import java.util.zip.ZipException; import java.util.zip.ZipOutputStream; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JProgressBar; import com.strobel.assembler.metadata.ITypeLoader; import com.strobel.assembler.metadata.JarTypeLoader; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput; import com.strobel.decompiler.languages.java.JavaFormattingOptions;  /**  * Performs Save and Save All  */ public class FileSaver {   private JProgressBar bar;  private JLabel label;   public FileSaver(JProgressBar bar, JLabel label) {   this.bar = bar;   this.label = label;  }   public void saveText(final String text, final File file) {   new Thread(new Runnable() {    @Override    public void run() {     try (FileWriter fw = new FileWriter(file);       BufferedWriter bw = new BufferedWriter(fw);) {      label.setText("Extracting: " + file.getName());      bar.setVisible(true);      bw.write(text);      bw.flush();      label.setText("Complete");     } catch (Exception e1) {      label.setText("Cannot save file: " + file.getName());      e1.printStackTrace();      JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);     } finally {      bar.setVisible(false);     }    }   }).start();  }   public void saveAllDecompiled(final File inFile, final File outFile) {   new Thread(new Runnable() {    @Override    public void run() {     try {      bar.setVisible(true);      label.setText("Extracting: " + outFile.getName());      String inFileName = inFile.getName().toLowerCase();       if (inFileName.endsWith(".jar") || inFileName.endsWith(".zip")) {       doSaveJarDecompiled(inFile, outFile);      } else if (inFileName.endsWith(".class")) {       doSaveClassDecompiled(inFile, outFile);      } else {       doSaveUnknownFile(inFile, outFile);      }       label.setText("Complete");     } catch (Exception e1) {      e1.printStackTrace();      label.setText("Cannot save file: " + outFile.getName());      JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);     } finally {      bar.setVisible(false);     }    }   }).start();  }   private void doSaveJarDecompiled(File inFile, File outFile) throws Exception {   try (JarFile jfile = new JarFile(inFile);     FileOutputStream dest = new FileOutputStream(outFile);     BufferedOutputStream buffDest = new BufferedOutputStream(dest);     ZipOutputStream out = new ZipOutputStream(buffDest);) {     byte data[] = new byte[1024];    DecompilerSettings settings = cloneSettings();    LuytenTypeLoader typeLoader = new LuytenTypeLoader();    MetadataSystem metadataSystem = new MetadataSystem(typeLoader);    ITypeLoader jarLoader = new JarTypeLoader(jfile);    typeLoader.getTypeLoaders().add(jarLoader);     DecompilationOptions decompilationOptions = new DecompilationOptions();    decompilationOptions.setSettings(settings);    decompilationOptions.setFullDecompilation(true);     List<String> mass = null;    JarEntryFilter jarEntryFilter = new JarEntryFilter(jfile);    LuytenPreferences luytenPrefs = ConfigSaver.getLoadedInstance().getLuytenPreferences();    if (luytenPrefs.isFilterOutInnerClassEntries()) {     mass = jarEntryFilter.getEntriesWithoutInnerClasses();    } else {     mass = jarEntryFilter.getAllEntriesFromJar();    }     Enumeration<JarEntry> ent = jfile.entries();    while (ent.hasMoreElements()) {     JarEntry entry = ent.nextElement();     if (!mass.contains(entry.getName()))      continue;     label.setText("Extracting: " + entry.getName());     bar.setVisible(true);     if (entry.getName().endsWith(".class")) {      JarEntry etn = new JarEntry(entry.getName().replace(".class", ".java"));      label.setText("Extracting: " + etn.getName());      out.putNextEntry(etn);      try {       String internalName = StringUtilities.removeRight(entry.getName(), ".class");       TypeReference type = metadataSystem.lookupType(internalName);       TypeDefinition resolvedType = null;       if ((type == null) || ((resolvedType = type.resolve()) == null)) {        throw new Exception("Unable to resolve type.");       }       Writer writer = new OutputStreamWriter(out);       settings.getLanguage().decompileType(resolvedType,         new PlainTextOutput(writer), decompilationOptions);       writer.flush();      } finally {       out.closeEntry();      }     } else {      try {       JarEntry etn = new JarEntry(entry.getName());       out.putNextEntry(etn);       try {        InputStream in = jfile.getInputStream(entry);        if (in != null) {         try {          int count;          while ((count = in.read(data, 0, 1024)) != -1) {           out.write(data, 0, count);          }         } finally {          in.close();         }        }       } finally {        out.closeEntry();       }      } catch (ZipException ze) {       // some jar-s contain duplicate pom.xml entries: ignore it       if (!ze.getMessage().contains("duplicate")) {        throw ze;       }      }     }    }    }  }   private void doSaveClassDecompiled(File inFile, File outFile) throws Exception {   DecompilerSettings settings = cloneSettings();   LuytenTypeLoader typeLoader = new LuytenTypeLoader();   MetadataSystem metadataSystem = new MetadataSystem(typeLoader);   TypeReference type = metadataSystem.lookupType(inFile.getCanonicalPath());    DecompilationOptions decompilationOptions = new DecompilationOptions();   decompilationOptions.setSettings(settings);   decompilationOptions.setFullDecompilation(true);    TypeDefinition resolvedType = null;   if (type == null || ((resolvedType = type.resolve()) == null)) {    throw new Exception("Unable to resolve type.");   }   StringWriter stringwriter = new StringWriter();   settings.getLanguage().decompileType(resolvedType,     new PlainTextOutput(stringwriter), decompilationOptions);   String decompiledSource = stringwriter.toString();    try (FileWriter fw = new FileWriter(outFile);     BufferedWriter bw = new BufferedWriter(fw);) {    bw.write(decompiledSource);    bw.flush();   }  }   private void doSaveUnknownFile(File inFile, File outFile) throws Exception {   try (FileInputStream in = new FileInputStream(inFile);     FileOutputStream out = new FileOutputStream(outFile);) {     byte data[] = new byte[1024];    int count;    while ((count = in.read(data, 0, 1024)) != -1) {     out.write(data, 0, count);    }   }  }   private DecompilerSettings cloneSettings() {   DecompilerSettings settings = ConfigSaver.getLoadedInstance().getDecompilerSettings();   DecompilerSettings newSettings = new DecompilerSettings();   if (newSettings.getFormattingOptions() == null) {    newSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   // synchronized: against main menu changes   synchronized (settings) {    newSettings.setExcludeNestedTypes(settings.getExcludeNestedTypes());    newSettings.setFlattenSwitchBlocks(settings.getFlattenSwitchBlocks());    newSettings.setForceExplicitImports(settings.getForceExplicitImports());    newSettings.setForceExplicitTypeArguments(settings.getForceExplicitTypeArguments());    newSettings.setOutputFileHeaderText(settings.getOutputFileHeaderText());    newSettings.setLanguage(settings.getLanguage());    newSettings.setShowSyntheticMembers(settings.getShowSyntheticMembers());    newSettings.setAlwaysGenerateExceptionVariableForCatchBlocks(settings      .getAlwaysGenerateExceptionVariableForCatchBlocks());    newSettings.setOutputDirectory(settings.getOutputDirectory());    newSettings.setRetainRedundantCasts(settings.getRetainRedundantCasts());    newSettings.setIncludeErrorDiagnostics(settings.getIncludeErrorDiagnostics());    newSettings.setIncludeLineNumbersInBytecode(settings.getIncludeLineNumbersInBytecode());    newSettings.setRetainPointlessSwitches(settings.getRetainPointlessSwitches());    newSettings.setUnicodeOutputEnabled(settings.isUnicodeOutputEnabled());    newSettings.setMergeVariables(settings.getMergeVariables());    newSettings.setShowDebugLineNumbers(settings.getShowDebugLineNumbers());   }   return newSettings;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> CellRenderer.java.merge : .java.merge-File]
						[T -> CellRenderer.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Component; import java.awt.Toolkit;  import javax.swing.Icon; import javax.swing.ImageIcon; import javax.swing.JTree; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.DefaultTreeCellRenderer;  public class CellRenderer extends DefaultTreeCellRenderer{  private static final long serialVersionUID = -5691181006363313993L;  Icon pack;  Icon java_image;  Icon file_image;    public CellRenderer(){   this.pack = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/package_obj.png")));   this.java_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/java.png")));   this.file_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/file.png")));  }   @Override  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);         DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;   if(node.getChildCount() > 0){    setIcon(this.pack);   }else if(getFileName(node).endsWith(".class") || getFileName(node).endsWith(".java")){    setIcon(this.java_image);   }else{    setIcon(this.file_image);   }      return this;  }    public String getFileName(DefaultMutableTreeNode node){         return ((TreeNodeUserObject) node.getUserObject()).getOriginalName();  }  } " compose:StringConcatenation merge: LineBased]
					[NT -> TreeNodeUserObject.java.merge : .java.merge-File]
						[T -> TreeNodeUserObject.java : .java-Content "package com.modcrafting.luyten;  public class TreeNodeUserObject {   private String originalName;  private String displayName;   public TreeNodeUserObject(String name) {   this(name, name);  }   public TreeNodeUserObject(String originalName, String displayName) {   this.originalName = originalName;   this.displayName = displayName;  }   public String getOriginalName() {   return originalName;  }   public void setOriginalName(String originalName) {   this.originalName = originalName;  }   public String getDisplayName() {   return displayName;  }   public void setDisplayName(String displayName) {   this.displayName = displayName;  }   @Override  public String toString() {   return displayName;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LuytenPreferences.java.merge : .java.merge-File]
						[T -> LuytenPreferences.java : .java-Content "package com.modcrafting.luyten;  /**  * Do not instantiate this class, get the instance from  * ConfigSaver. All not-static fields will be saved  * automatically named by the field's java variable name.  * (Watch for collisions with existing IDs defined in  * ConfigSaver.) Only String, boolean and int fields are  * supported. Write default values into the field  * declarations.  */ public class LuytenPreferences {   public static final String THEME_XML_PATH = "/themes/";  public static final String DEFAULT_THEME_XML = "eclipse.xml";   private String themeXml = DEFAULT_THEME_XML;  private String fileOpenCurrentDirectory = "";  private String fileSaveCurrentDirectory = "";   private boolean isPackageExplorerStyle = true;  private boolean isFilterOutInnerClassEntries = true;  private boolean isSingleClickOpenEnabled = true;  private boolean isExitByEscEnabled = false;   public String getThemeXml() {   return themeXml;  }   public void setThemeXml(String themeXml) {   this.themeXml = themeXml;  }   public String getFileOpenCurrentDirectory() {   return fileOpenCurrentDirectory;  }   public void setFileOpenCurrentDirectory(String fileOpenCurrentDirectory) {   this.fileOpenCurrentDirectory = fileOpenCurrentDirectory;  }   public String getFileSaveCurrentDirectory() {   return fileSaveCurrentDirectory;  }   public void setFileSaveCurrentDirectory(String fileSaveCurrentDirectory) {   this.fileSaveCurrentDirectory = fileSaveCurrentDirectory;  }   public boolean isPackageExplorerStyle() {   return isPackageExplorerStyle;  }   public void setPackageExplorerStyle(boolean isPackageExplorerStyle) {   this.isPackageExplorerStyle = isPackageExplorerStyle;  }   public boolean isFilterOutInnerClassEntries() {   return isFilterOutInnerClassEntries;  }   public void setFilterOutInnerClassEntries(boolean isFilterOutInnerClassEntries) {   this.isFilterOutInnerClassEntries = isFilterOutInnerClassEntries;  }   public boolean isSingleClickOpenEnabled() {   return isSingleClickOpenEnabled;  }   public void setSingleClickOpenEnabled(boolean isSingleClickOpenEnabled) {   this.isSingleClickOpenEnabled = isSingleClickOpenEnabled;  }   public boolean isExitByEscEnabled() {   return isExitByEscEnabled;  }   public void setExitByEscEnabled(boolean isExitByEscEnabled) {   this.isExitByEscEnabled = isExitByEscEnabled;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> OpenFile.java.merge : .java.merge-File]
						[T -> OpenFile.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Panel; import java.util.Arrays; import java.util.HashSet; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rsyntaxtextarea.SyntaxConstants; import org.fife.ui.rsyntaxtextarea.Theme; import org.fife.ui.rtextarea.RTextScrollPane; import com.strobel.assembler.metadata.TypeReference;  public class OpenFile implements SyntaxConstants {   public static final HashSet<String> WELL_KNOWN_TEXT_FILE_EXTENSIONS = new HashSet<>(Arrays.asList(    ".java", ".xml", ".rss", ".project", ".classpath", ".h", ".sql", ".js", ".php", ".php5",    ".phtml", ".html", ".htm", ".xhtm", ".xhtml", ".lua", ".bat", ".pl", ".sh", ".css",    ".json", ".txt", ".rb", ".make", ".mak", ".py", ".properties", ".prop"));   RTextScrollPane scrollPane;  Panel image_pane;  RSyntaxTextArea textArea;  String name;  private String path;  private TypeReference type = null;  private boolean isContentValid = false;   public OpenFile(TypeReference type, String name, String path, String content, Theme theme) {   this(name, path, content, theme);   this.type = type;  }    public OpenFile(String name, String path, String contents, Theme theme) {   this.name = name;   this.path = path;   textArea = new RSyntaxTextArea(25, 70);   textArea.setCaretPosition(0);   textArea.requestFocusInWindow();   textArea.setMarkOccurrences(true);   textArea.setClearWhitespaceLinesEnabled(false);   textArea.setEditable(false);   textArea.setAntiAliasingEnabled(true);   textArea.setCodeFoldingEnabled(true);   if (name.toLowerCase().endsWith(".class")     || name.toLowerCase().endsWith(".java"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVA);   else if (name.toLowerCase().endsWith(".xml")     || name.toLowerCase().endsWith(".rss")     || name.toLowerCase().endsWith(".project")     || name.toLowerCase().endsWith(".classpath"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_XML);   else if (name.toLowerCase().endsWith(".h"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_C);   else if (name.toLowerCase().endsWith(".sql"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_SQL);   else if (name.toLowerCase().endsWith(".js"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVASCRIPT);   else if (name.toLowerCase().endsWith(".php")     || name.toLowerCase().endsWith(".php5")     || name.toLowerCase().endsWith(".phtml"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PHP);   else if (name.toLowerCase().endsWith(".html")     || name.toLowerCase().endsWith(".htm")     || name.toLowerCase().endsWith(".xhtm")     || name.toLowerCase().endsWith(".xhtml"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_HTML);   else if (name.toLowerCase().endsWith(".js"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVASCRIPT);   else if (name.toLowerCase().endsWith(".lua"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_LUA);   else if (name.toLowerCase().endsWith(".bat"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_WINDOWS_BATCH);   else if (name.toLowerCase().endsWith(".pl"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PERL);   else if (name.toLowerCase().endsWith(".sh"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_UNIX_SHELL);   else if (name.toLowerCase().endsWith(".css"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_CSS);   else if (name.toLowerCase().endsWith(".json"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JSON);   else if (name.toLowerCase().endsWith(".txt"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_NONE);   else if (name.toLowerCase().endsWith(".rb"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_RUBY);   else if (name.toLowerCase().endsWith(".make")     || name.toLowerCase().endsWith(".mak"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_MAKEFILE);   else if (name.toLowerCase().endsWith(".py"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PYTHON);   else    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PROPERTIES_FILE);   scrollPane = new RTextScrollPane(textArea, true);   scrollPane.setIconRowHeaderEnabled(true);   textArea.setText(contents);   theme.apply(textArea);  }   public void setContent(String content) {   textArea.setText(content);  }   public String getPath() {   return path;  }   public void setPath(String path) {   this.path = path;  }   public TypeReference getType() {   return type;  }   public void setType(TypeReference type) {   this.type = type;  }   public boolean isContentValid() {   return isContentValid;  }   public void setContentValid(boolean isContentValid) {   this.isContentValid = isContentValid;  }    @Override  public int hashCode() {   final int prime = 31;   int result = 1;   result = prime * result + ((name == null) ? 0 : name.hashCode());   return result;  }   @Override  public boolean equals(Object obj) {   if (this == obj)    return true;   if (obj == null)    return false;   if (getClass() != obj.getClass())    return false;   OpenFile other = (OpenFile) obj;   if (name == null) {    if (other.name != null)     return false;   } else if (!name.equals(other.name))    return false;   return true;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> WindowPosition.java.merge : .java.merge-File]
						[T -> WindowPosition.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Component; import java.awt.Dimension; import java.awt.Toolkit; import javax.swing.JDialog; import javax.swing.JFrame;  public class WindowPosition {   private boolean isFullScreen;  private int windowWidth;  private int windowHeight;  private int windowX;  private int windowY;   public void readPositionFromWindow(JFrame window) {   isFullScreen = (window.getExtendedState() == JFrame.MAXIMIZED_BOTH);   if (!isFullScreen) {    this.readPositionFromComponent(window);   }  }   public void readPositionFromDialog(JDialog dialog) {   this.readPositionFromComponent(dialog);  }   private void readPositionFromComponent(Component component) {   isFullScreen = false;   windowWidth = component.getWidth();   windowHeight = component.getHeight();   windowX = component.getX();   windowY = component.getY();  }   public boolean isSavedWindowPositionValid() {   if (isFullScreen) {    return true;   }   if (windowWidth < 100 || windowHeight < 100) {    return false;   }   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (windowWidth > screenSize.width + 50 || windowHeight > screenSize.height + 50) {    return false;   }   if (windowY < -20 || windowY > screenSize.height - 50 ||     windowX < 50 - windowWidth || windowX > screenSize.width - 50) {    return false;   }   return true;  }   public boolean isFullScreen() {   return isFullScreen;  }   public void setFullScreen(boolean isFullScreen) {   this.isFullScreen = isFullScreen;  }   public int getWindowWidth() {   return windowWidth;  }   public void setWindowWidth(int windowWidth) {   this.windowWidth = windowWidth;  }   public int getWindowHeight() {   return windowHeight;  }   public void setWindowHeight(int windowHeight) {   this.windowHeight = windowHeight;  }   public int getWindowX() {   return windowX;  }   public void setWindowX(int windowX) {   this.windowX = windowX;  }   public int getWindowY() {   return windowY;  }   public void setWindowY(int windowY) {   this.windowY = windowY;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> MainWindow.java.merge : .java.merge-File]
						[T -> MainWindow.java : .java-Content "package com.modcrafting.luyten;  import java.awt.BorderLayout; import java.awt.Dimension; import java.awt.Toolkit; import java.awt.dnd.DropTarget; import java.awt.event.ActionEvent; import java.awt.event.ComponentAdapter; import java.awt.event.ComponentEvent; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.BoxLayout; import javax.swing.JComponent; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.KeyStroke; import javax.swing.border.BevelBorder; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;  /**  * Dispatcher  */ public class MainWindow extends JFrame {  private static final long serialVersionUID = 1L;  private static final String TITLE = "Luyten";   private Model model;  private JProgressBar bar;  private JLabel label;  private FindBox findBox;  private ConfigSaver configSaver;  private WindowPosition windowPosition;  private LuytenPreferences luytenPrefs;  private FileDialog fileDialog;  private FileSaver fileSaver;   public MainWindow(File fileFromCommandLine) {   configSaver = ConfigSaver.getLoadedInstance();   windowPosition = configSaver.getMainWindowPosition();   luytenPrefs = configSaver.getLuytenPreferences();    MainMenuBar mainMenuBar = new MainMenuBar(this);   this.setJMenuBar(mainMenuBar);    this.adjustWindowPositionBySavedState();   this.setHideFindBoxOnMainWindowFocus();   this.setQuitOnWindowClosing();   this.setTitle(TITLE);    JPanel pane = new JPanel();   pane.setBorder(new BevelBorder(BevelBorder.LOWERED));   pane.setPreferredSize(new Dimension(this.getWidth(), 24));   pane.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));    JPanel panel1 = new JPanel();   label = new JLabel(" ");   label.setHorizontalAlignment(JLabel.LEFT);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setBorder(new BevelBorder(BevelBorder.LOWERED));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(label);   pane.add(panel1);    panel1 = new JPanel();   bar = new JProgressBar();   bar.setIndeterminate(true);   bar.setOpaque(false);   bar.setVisible(false);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(bar);   pane.add(panel1);    model = new Model(this);   this.getContentPane().add(model);   this.add(pane, BorderLayout.SOUTH);    if (fileFromCommandLine != null) {    model.loadFile(fileFromCommandLine);   }    try {    DropTarget dt = new DropTarget();    dt.addDropTargetListener(new DropListener(this));    this.setDropTarget(dt);   } catch (Exception e) {    e.printStackTrace();   }    fileDialog = new FileDialog(this);   fileSaver = new FileSaver(bar, label);    this.setExitOnEscWhenEnabled(model);    if (fileFromCommandLine == null || fileFromCommandLine.getName().toLowerCase().endsWith(".jar") ||     fileFromCommandLine.getName().toLowerCase().endsWith(".zip")) {    model.startWarmUpThread();   }  }   public void onOpenFileMenu() {   File selectedFile = fileDialog.doOpenDialog();   if (selectedFile != null) {    this.getModel().loadFile(selectedFile);   }  }   public void onCloseFileMenu() {   this.getModel().closeFile();  }   public void onSaveAsMenu() {   RSyntaxTextArea pane = this.getModel().getCurrentTextArea();   if (pane == null)    return;   String tabTitle = this.getModel().getCurrentTabTitle();   if (tabTitle == null)    return;    String recommendedFileName = tabTitle.replace(".class", ".java");   File selectedFile = fileDialog.doSaveDialog(recommendedFileName);   if (selectedFile != null) {    fileSaver.saveText(pane.getText(), selectedFile);   }  }   public void onSaveAllMenu() {   File openedFile = this.getModel().getOpenedFile();   if (openedFile == null)    return;    String fileName = openedFile.getName();   if (fileName.endsWith(".class")) {    fileName = fileName.replace(".class", ".java");   } else if (fileName.toLowerCase().endsWith(".jar")) {    fileName = "decompiled-" + fileName.replaceAll("\\.[jJ][aA][rR]", ".zip");   } else {    fileName = "saved-" + fileName;   }    File selectedFileToSave = fileDialog.doSaveAllDialog(fileName);   if (selectedFileToSave != null) {    fileSaver.saveAllDecompiled(openedFile, selectedFileToSave);   }  }   public void onExitMenu() {   quit();  }   public void onSelectAllMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     pane.requestFocusInWindow();     pane.setSelectionStart(0);     pane.setSelectionEnd(pane.getText().length());    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onFindMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     if (findBox == null)      findBox = new FindBox(this);     findBox.showFindBox();    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onLegalMenu() {   new Thread() {    public void run() {     try {      bar.setVisible(true);      String legalStr = getLegalStr();      MainWindow.this.getModel().showLegal(legalStr);     } finally {      bar.setVisible(false);     }    }   }.start();  }   private String getLegalStr() {   StringBuilder sb = new StringBuilder();   try {    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/Procyon.License.txt")));    String line;    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");    sb.append("\n\n\n\n\n");    reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/RSyntaxTextArea.License.txt")));    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");   } catch (IOException e) {    e.printStackTrace();   }   return sb.toString();  }   public void onThemesChanged() {   this.getModel().changeTheme(luytenPrefs.getThemeXml());  }   public void onSettingsChanged() {   this.getModel().updateOpenClasses();  }   public void onTreeSettingsChanged() {   this.getModel().updateTree();  }   public void onFileDropped(File file) {   if (file != null) {    this.getModel().loadFile(file);   }  }   public void onFileLoadEnded(File file, boolean isSuccess) {   try {    if (file != null && isSuccess) {     this.setTitle(TITLE + " - " + file.getName());    } else {     this.setTitle(TITLE);    }   } catch (Exception e) {    e.printStackTrace();   }  }   private void adjustWindowPositionBySavedState() {   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (!windowPosition.isSavedWindowPositionValid()) {    final Dimension center = new Dimension((int) (screenSize.width * 0.75), (int) (screenSize.height * 0.75));    final int x = (int) (center.width * 0.2);    final int y = (int) (center.height * 0.2);    this.setBounds(x, y, center.width, center.height);    } else if (windowPosition.isFullScreen()) {    int heightMinusTray = screenSize.height;    if (screenSize.height > 30)     heightMinusTray -= 30;    this.setBounds(0, 0, screenSize.width, heightMinusTray);    this.setExtendedState(JFrame.MAXIMIZED_BOTH);     this.addComponentListener(new ComponentAdapter() {     @Override     public void componentResized(ComponentEvent e) {      if (MainWindow.this.getExtendedState() != JFrame.MAXIMIZED_BOTH) {       windowPosition.setFullScreen(false);       if (windowPosition.isSavedWindowPositionValid()) {        MainWindow.this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),          windowPosition.getWindowWidth(), windowPosition.getWindowHeight());       }       MainWindow.this.removeComponentListener(this);      }     }    });    } else {    this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),      windowPosition.getWindowWidth(), windowPosition.getWindowHeight());   }  }   private void setHideFindBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findBox != null && findBox.isVisible()) {      findBox.setVisible(false);     }    }   });  }   private void setQuitOnWindowClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowClosing(WindowEvent e) {     quit();    }   });  }   private void quit() {   try {    windowPosition.readPositionFromWindow(this);    configSaver.saveConfig();   } catch (Exception exc) {    exc.printStackTrace();   } finally {    try {     this.dispose();    } finally {     System.exit(0);    }   }  }   private void setExitOnEscWhenEnabled(JComponent mainComponent) {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     if (luytenPrefs.isExitByEscEnabled()) {      quit();     }    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   mainComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(escapeKeyStroke, "ESCAPE");   mainComponent.getActionMap().put("ESCAPE", escapeAction);  }   public Model getModel() {   return model;  }   public JProgressBar getBar() {   return bar;  }   public JLabel getLabel() {   return label;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LuytenTypeLoader.java.merge : .java.merge-File]
						[T -> LuytenTypeLoader.java : .java-Content "package com.modcrafting.luyten;  import com.strobel.assembler.InputTypeLoader; import com.strobel.assembler.metadata.Buffer; import com.strobel.assembler.metadata.ITypeLoader;  import java.util.ArrayList; import java.util.List;  public final class LuytenTypeLoader implements ITypeLoader {     private final List<ITypeLoader> _typeLoaders;      public LuytenTypeLoader() {         _typeLoaders = new ArrayList<ITypeLoader>();         _typeLoaders.add(new InputTypeLoader());     }      public final List<ITypeLoader> getTypeLoaders() {         return _typeLoaders;     }      @Override     public boolean tryLoadType(final String internalName, final Buffer buffer) {         for (final ITypeLoader typeLoader : _typeLoaders) {             if (typeLoader.tryLoadType(internalName, buffer)) {                 return true;             }              buffer.reset();         }          return false;     } } " compose:StringConcatenation merge: LineBased]
[NT -> right : Feature]
	[NT -> src : Folder]
		[NT -> com : Folder]
			[NT -> modcrafting : Folder]
				[NT -> luyten : Folder]
					[NT -> FileDialog.java.merge : .java.merge-File]
						[T -> FileDialog.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Component; import java.io.File; import javax.swing.JFileChooser; import javax.swing.filechooser.FileFilter;  /**  * FileChoosers for Open and Save  */ public class FileDialog {  private ConfigSaver configSaver;  private LuytenPreferences luytenPrefs;  private Component parent;  private JFileChooser fcOpen;  private JFileChooser fcSave;  private JFileChooser fcSaveAll;   public FileDialog(Component parent) {   this.parent = parent;   configSaver = ConfigSaver.getLoadedInstance();   luytenPrefs = configSaver.getLuytenPreferences();    new Thread() {    public void run() {     try {      initOpenDialog();      Thread.sleep(500);      initSaveAllDialog();      Thread.sleep(500);      initSaveDialog();     } catch (Exception e) {      e.printStackTrace();     }    };   }.start();  }   public File doOpenDialog() {   File selectedFile = null;   initOpenDialog();    retrieveOpenDialogDir(fcOpen);   int returnVal = fcOpen.showOpenDialog(parent);   saveOpenDialogDir(fcOpen);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcOpen.getSelectedFile();   }   return selectedFile;  }   public File doSaveDialog(String recommendedFileName) {   File selectedFile = null;   initSaveDialog();    retrieveSaveDialogDir(fcSave);   fcSave.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSave.showSaveDialog(parent);   saveSaveDialogDir(fcSave);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSave.getSelectedFile();   }   return selectedFile;  }   public File doSaveAllDialog(String recommendedFileName) {   File selectedFile = null;   initSaveAllDialog();    retrieveSaveDialogDir(fcSaveAll);   fcSaveAll.setSelectedFile(new File(recommendedFileName));   int returnVal = fcSaveAll.showSaveDialog(parent);   saveSaveDialogDir(fcSaveAll);    if (returnVal == JFileChooser.APPROVE_OPTION) {    selectedFile = fcSaveAll.getSelectedFile();   }   return selectedFile;  }   public synchronized void initOpenDialog() {   if (fcOpen == null) {    fcOpen = createFileChooser("*.jar", "*.zip", "*.class");    retrieveOpenDialogDir(fcOpen);   }  }   public synchronized void initSaveDialog() {   if (fcSave == null) {    fcSave = createFileChooser("*.txt", "*.java");    retrieveSaveDialogDir(fcSave);   }  }   public synchronized void initSaveAllDialog() {   if (fcSaveAll == null) {    fcSaveAll = createFileChooser("*.jar", "*.zip");    retrieveSaveDialogDir(fcSaveAll);   }  }   private JFileChooser createFileChooser(String... fileFilters) {   JFileChooser fc = new JFileChooser();   for (String fileFilter : fileFilters) {    fc.addChoosableFileFilter(new FileChooserFileFilter(fileFilter));   }   fc.setFileSelectionMode(JFileChooser.FILES_ONLY);   fc.setMultiSelectionEnabled(false);   return fc;  }   public class FileChooserFileFilter extends FileFilter {   String objType;    public FileChooserFileFilter(String string) {    objType = string;   }    @Override   public boolean accept(File f) {    if (f.isDirectory())     return false;    return f.getName().toLowerCase().endsWith(objType.substring(1));   }    @Override   public String getDescription() {    return objType;   }  }   private void retrieveOpenDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileOpenCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void saveOpenDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileOpenCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void retrieveSaveDialogDir(JFileChooser fc) {   try {    String currentDirStr = luytenPrefs.getFileSaveCurrentDirectory();    if (currentDirStr != null && currentDirStr.trim().length() > 0) {     File currentDir = new File(currentDirStr);     if (currentDir.exists() && currentDir.isDirectory()) {      fc.setCurrentDirectory(currentDir);     }    }   } catch (Exception exc) {    exc.printStackTrace();   }  }   private void saveSaveDialogDir(JFileChooser fc) {   try {    File currentDir = fc.getCurrentDirectory();    if (currentDir != null && currentDir.exists() && currentDir.isDirectory()) {     luytenPrefs.setFileSaveCurrentDirectory(currentDir.getAbsolutePath());    }   } catch (Exception exc) {    exc.printStackTrace();   }  } } " compose:StringConcatenation merge: LineBased]
					[NT -> DropListener.java.merge : .java.merge-File]
						[T -> DropListener.java : .java-Content "package com.modcrafting.luyten;  import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.dnd.DnDConstants; import java.awt.dnd.DropTargetDragEvent; import java.awt.dnd.DropTargetDropEvent; import java.awt.dnd.DropTargetEvent; import java.awt.dnd.DropTargetListener; import java.io.BufferedReader; import java.io.File; import java.io.Reader; import java.net.URI; import java.util.ArrayList; import java.util.List;  /**  * Drag-Drop (only MainWindow should be called from here)  */ public class DropListener implements DropTargetListener {  private MainWindow mainWindow;   public DropListener(MainWindow mainWindow) {   this.mainWindow = mainWindow;  }   @SuppressWarnings("unchecked")  @Override  public void drop(DropTargetDropEvent event) {   event.acceptDrop(DnDConstants.ACTION_COPY);   Transferable transferable = event.getTransferable();   if (transferable.isDataFlavorSupported(DataFlavor.javaFileListFlavor)) {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    for (DataFlavor flavor : flavors) {     try {      if (flavor.isFlavorJavaFileListType()) {       List<File> files = (List<File>) transferable         .getTransferData(flavor);       if (files.size() > 1) {        event.rejectDrop();        return;       }       if (files.size() == 1) {        mainWindow.onFileDropped(files.get(0));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }    event.dropComplete(true);   } else {    DataFlavor[] flavors = transferable.getTransferDataFlavors();    boolean handled = false;    for (int zz = 0; zz < flavors.length; zz++) {     if (flavors[zz].isRepresentationClassReader()) {      try {       Reader reader = flavors[zz].getReaderForText(transferable);       BufferedReader br = new BufferedReader(reader);       List<File> list = new ArrayList<File>();       String line = null;       while ((line = br.readLine()) != null) {        try {         if (new String("" + (char) 0).equals(line))          continue;         File file = new File(new URI(line));         list.add(file);        } catch (Exception ex) {         ex.printStackTrace();        }       }       if (list.size() > 1) {        event.rejectDrop();        return;       }       if (list.size() == 1) {        mainWindow.onFileDropped(list.get(0));       }       event.getDropTargetContext().dropComplete(true);       handled = true;      } catch (Exception e) {       e.printStackTrace();      }      break;     }    }    if (!handled) {     event.rejectDrop();    }   }   }   @Override  public void dragEnter(DropTargetDragEvent arg0) {}   @Override  public void dragExit(DropTargetEvent arg0) {}   @Override  public void dragOver(DropTargetDragEvent arg0) {}   @Override  public void dropActionChanged(DropTargetDragEvent arg0) {} } " compose:StringConcatenation merge: LineBased]
					[NT -> FileEntryNotFoundException.java.merge : .java.merge-File]
						[T -> FileEntryNotFoundException.java : .java-Content "package com.modcrafting.luyten;  public class FileEntryNotFoundException extends Exception {  private static final long serialVersionUID = 1L;  } " compose:StringConcatenation merge: LineBased]
					[NT -> FileIsBinaryException.java.merge : .java.merge-File]
						[T -> FileIsBinaryException.java : .java-Content "package com.modcrafting.luyten;  public class FileIsBinaryException extends Exception {  private static final long serialVersionUID = 1L;  } " compose:StringConcatenation merge: LineBased]
					[NT -> JarEntryFilter.java.merge : .java.merge-File]
						[T -> JarEntryFilter.java : .java-Content "package com.modcrafting.luyten;  import java.util.ArrayList; import java.util.Enumeration; import java.util.HashSet; import java.util.List; import java.util.Set; import java.util.jar.JarEntry; import java.util.jar.JarFile;  public class JarEntryFilter {   private JarFile jfile;   public JarEntryFilter() {}   public JarEntryFilter(JarFile jfile) {   this.jfile = jfile;  }   public List<String> getAllEntriesFromJar() {   List<String> mass = new ArrayList<>();   Enumeration<JarEntry> entries = jfile.entries();   while (entries.hasMoreElements()) {    JarEntry e = entries.nextElement();    if (!e.isDirectory()) {     mass.add(e.getName());    }   }   return mass;  }   public List<String> getEntriesWithoutInnerClasses() {   List<String> mass = new ArrayList<>();   Enumeration<JarEntry> entries = jfile.entries();   Set<String> possibleInnerClasses = new HashSet<String>();   Set<String> baseClasses = new HashSet<String>();    while (entries.hasMoreElements()) {    JarEntry e = entries.nextElement();    if (!e.isDirectory()) {     String entryName = e.getName();      if (entryName != null && entryName.trim().length() > 0) {      entryName = entryName.trim();       if (!entryName.endsWith(".class")) {       mass.add(entryName);        // com/acme/Model$16.class      } else if (entryName.matches(".*[^(/|\\\\)]+\\$[^(/|\\\\)]+$")) {       possibleInnerClasses.add(entryName);       } else {       baseClasses.add(entryName);       mass.add(entryName);      }     }    }   }    // keep Badly$Named but not inner classes   for (String inner : possibleInnerClasses) {     // com/acme/Connection$Conn$1.class -> com/acme/Connection    String innerWithoutTail = inner.replaceAll("\\$[^(/|\\\\)]+\\.class$", "");    if (!baseClasses.contains(innerWithoutTail + ".class")) {     mass.add(inner);    }   }   return mass;  }   public JarFile getJfile() {   return jfile;  }   public void setJfile(JarFile jfile) {   this.jfile = jfile;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Closer.java.merge : .java.merge-File]
						[T -> Closer.java : .java-Content "package com.modcrafting.luyten;  public final class Closer {     public static void tryClose(final AutoCloseable c) {         if (c == null) {             return;         }         try {             c.close();         }         catch (Throwable ignored) {         }     }      public static void tryClose(final AutoCloseable... items) {         if (items == null) {             return;         }         for (AutoCloseable c : items) {             tryClose(c);         }     } } " compose:StringConcatenation merge: LineBased]
					[NT -> Model.java.merge : .java.merge-File]
						[T -> Model.java : .java-Content "package com.modcrafting.luyten;  import java.awt.GridBagConstraints; import java.awt.GridBagLayout; import java.awt.Insets; import java.awt.Toolkit; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.io.BufferedReader; import java.io.File; import java.io.FileInputStream; import java.io.InputStream; import java.io.InputStreamReader; import java.io.StringWriter; import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.Comparator; import java.util.Enumeration; import java.util.HashSet; import java.util.LinkedList; import java.util.List; import java.util.Set; import java.util.TreeMap; import java.util.TreeSet; import java.util.jar.JarEntry; import java.util.jar.JarFile; import javax.swing.BorderFactory; import javax.swing.BoxLayout; import javax.swing.ImageIcon; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.JScrollPane; import javax.swing.JSplitPane; import javax.swing.JTabbedPane; import javax.swing.JTree; import javax.swing.SwingUtilities; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.DefaultTreeModel; import javax.swing.tree.TreeNode; import javax.swing.tree.TreePath; import javax.swing.tree.TreeSelectionModel; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rsyntaxtextarea.Theme; import org.fife.ui.rtextarea.RTextScrollPane; import com.strobel.assembler.InputTypeLoader; import com.strobel.assembler.metadata.ITypeLoader; import com.strobel.assembler.metadata.JarTypeLoader; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.core.VerifyArgument; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput;  /**  * Jar-level model  */ public class Model extends JSplitPane {  private static final long serialVersionUID = 6896857630400910200L;   private static final long MAX_JAR_FILE_SIZE_BYTES = 1_000_000_000;  private static final long MAX_UNPACKED_FILE_SIZE_BYTES = 1_000_000;   private final LuytenTypeLoader typeLoader = new LuytenTypeLoader();  private MetadataSystem metadataSystem = new MetadataSystem(typeLoader);   private JTree tree;  private JTabbedPane house;  private File file;  private DecompilerSettings settings;  private DecompilationOptions decompilationOptions;  private Theme theme;  private MainWindow mainWindow;  private JProgressBar bar;  private JLabel label;  private HashSet<OpenFile> hmap = new HashSet<OpenFile>();  private Set<String> treeExpansionState;  private boolean open = false;  private State state;  private ConfigSaver configSaver;  private LuytenPreferences luytenPrefs;   public Model(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.bar = mainWindow.getBar();   this.label = mainWindow.getLabel();    configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    try {    String themeXml = luytenPrefs.getThemeXml();    theme = Theme.load(getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + themeXml));   } catch (Exception e1) {    try {     e1.printStackTrace();     String themeXml = LuytenPreferences.DEFAULT_THEME_XML;     luytenPrefs.setThemeXml(themeXml);     theme = Theme.load(getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + themeXml));    } catch (Exception e2) {     e2.printStackTrace();    }   }    tree = new JTree();   tree.setModel(new DefaultTreeModel(null));   tree.getSelectionModel().setSelectionMode(TreeSelectionModel.SINGLE_TREE_SELECTION);   tree.setCellRenderer(new CellRenderer());   TreeListener tl = new TreeListener();   tree.addMouseListener(tl);    JPanel panel2 = new JPanel();   panel2.setLayout(new BoxLayout(panel2, 1));   panel2.setBorder(BorderFactory.createTitledBorder("Structure"));   panel2.add(new JScrollPane(tree));    house = new JTabbedPane();   house.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);   house.addChangeListener(new TabChangeListener());    JPanel panel = new JPanel();   panel.setLayout(new BoxLayout(panel, 1));   panel.setBorder(BorderFactory.createTitledBorder("Code"));   panel.add(house);   this.setOrientation(JSplitPane.HORIZONTAL_SPLIT);   this.setDividerLocation(250 % mainWindow.getWidth());   this.setLeftComponent(panel2);   this.setRightComponent(panel);    decompilationOptions = new DecompilationOptions();   decompilationOptions.setSettings(settings);   decompilationOptions.setFullDecompilation(true);  }   public void showLegal(String legalStr) {   OpenFile open = new OpenFile("Legal", "*/Legal", theme, mainWindow);   open.setContent(legalStr);   hmap.add(open);   addOrSwitchToTab(open);  }   private void addOrSwitchToTab(final OpenFile open) {   SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     try {      String title = open.name;      RTextScrollPane rTextScrollPane = open.scrollPane;      if (house.indexOfTab(title) < 0) {       house.addTab(title, rTextScrollPane);       house.setSelectedIndex(house.indexOfTab(title));       int index = house.indexOfTab(title);       Tab ct = new Tab(title);       ct.getButton().addMouseListener(new CloseTab(title));       house.setTabComponentAt(index, ct);      } else {       house.setSelectedIndex(house.indexOfTab(title));      }      open.onAddedToScreen();     } catch (Exception e) {      e.printStackTrace();     }    }   });  }   private void closeOpenTab(int index) {   RTextScrollPane co = (RTextScrollPane) house.getComponentAt(index);   RSyntaxTextArea pane = (RSyntaxTextArea) co.getViewport().getView();   OpenFile open = null;   for (OpenFile file : hmap)    if (pane.equals(file.textArea))     open = file;   if (open != null && hmap.contains(open))    hmap.remove(open);   house.remove(co);   if (open != null)    open.close();  }   private String getName(String path) {   if (path == null)    return "";   int i = path.lastIndexOf("/");   if (i == -1)    i = path.lastIndexOf("\\");   if (i != -1)    return path.substring(i + 1);   return path;  }   private class TreeListener extends MouseAdapter {   @Override   public void mousePressed(MouseEvent event) {    boolean isClickCountMatches = (event.getClickCount() == 1 && luytenPrefs.isSingleClickOpenEnabled())      || (event.getClickCount() == 2 && !luytenPrefs.isSingleClickOpenEnabled());    if (!isClickCountMatches)     return;     if (!SwingUtilities.isLeftMouseButton(event))     return;     final TreePath trp = tree.getPathForLocation(event.getX(), event.getY());    if (trp == null)     return;     Object lastPathComponent = trp.getLastPathComponent();    boolean isLeaf = (lastPathComponent instanceof TreeNode && ((TreeNode) lastPathComponent).isLeaf());    if (!isLeaf)     return;     new Thread() {     public void run() {      openEntryByTreePath(trp);     }    }.start();   }  }   private void openEntryByTreePath(TreePath trp) {   String name = "";   String path = "";   try {    bar.setVisible(true);    if (trp.getPathCount() > 1) {     for (int i = 1; i < trp.getPathCount(); i++) {      DefaultMutableTreeNode node = (DefaultMutableTreeNode) trp.getPathComponent(i);      TreeNodeUserObject userObject = (TreeNodeUserObject) node.getUserObject();      if (i == trp.getPathCount() - 1) {       name = userObject.getOriginalName();      } else {       path = path + userObject.getOriginalName() + "/";      }     }     path = path + name;      if (file.getName().endsWith(".jar") || file.getName().endsWith(".zip")) {      if (state == null) {       JarFile jfile = new JarFile(file);       ITypeLoader jarLoader = new JarTypeLoader(jfile);        typeLoader.getTypeLoaders().add(jarLoader);       state = new State(file.getCanonicalPath(), file, jfile, jarLoader);      }       JarEntry entry = state.jarFile.getJarEntry(path);      if (entry == null) {       throw new FileEntryNotFoundException();      }      if (entry.getSize() > MAX_UNPACKED_FILE_SIZE_BYTES) {       throw new TooLargeFileException(entry.getSize());      }      String entryName = entry.getName();      if (entryName.endsWith(".class")) {       label.setText("Extracting: " + name);       String internalName = StringUtilities.removeRight(entryName, ".class");       TypeReference type = metadataSystem.lookupType(internalName);       extractClassToTextPane(type, name, path, null);      } else {       label.setText("Opening: " + name);       try (InputStream in = state.jarFile.getInputStream(entry);) {        extractSimpleFileEntryToTextPane(in, name, path);       }      }     }    } else {     name = file.getName();     path = file.getPath().replaceAll("\\\\", "/");     if (file.length() > MAX_UNPACKED_FILE_SIZE_BYTES) {      throw new TooLargeFileException(file.length());     }     if (name.endsWith(".class")) {      label.setText("Extracting: " + name);      TypeReference type = metadataSystem.lookupType(path);      extractClassToTextPane(type, name, path, null);     } else {      label.setText("Opening: " + name);      try (InputStream in = new FileInputStream(file);) {       extractSimpleFileEntryToTextPane(in, name, path);      }     }    }    label.setText("Complete");   } catch (FileEntryNotFoundException e) {    label.setText("File not found: " + name);   } catch (FileIsBinaryException e) {    label.setText("Binary resource: " + name);   } catch (TooLargeFileException e) {    label.setText("File is too large: " + name + " - size: " + e.getReadableFileSize());   } catch (Exception e) {    label.setText("Cannot open: " + name);    e.printStackTrace();    JOptionPane.showMessageDialog(null, e.toString(), "Error!", JOptionPane.ERROR_MESSAGE);   } finally {    bar.setVisible(false);   }  }   private void extractClassToTextPane(TypeReference type, String tabTitle, String path,    String navigatonLink) throws Exception {   if (tabTitle == null || tabTitle.trim().length() < 1 || path == null) {    throw new FileEntryNotFoundException();   }   OpenFile sameTitledOpen = null;   for (OpenFile nextOpen : hmap) {    if (tabTitle.equals(nextOpen.name)) {     sameTitledOpen = nextOpen;     break;    }   }   if (sameTitledOpen != null && path.equals(sameTitledOpen.path) &&     type.equals(sameTitledOpen.getType()) && sameTitledOpen.isContentValid()) {    sameTitledOpen.setInitialNavigationLink(navigatonLink);    addOrSwitchToTab(sameTitledOpen);    return;   }    // resolve TypeDefinition   TypeDefinition resolvedType = null;   if (type == null || ((resolvedType = type.resolve()) == null)) {    throw new Exception("Unable to resolve type.");   }    // open tab, store type information, start decompilation   if (sameTitledOpen != null) {    sameTitledOpen.path = path;    sameTitledOpen.invalidateContent();    sameTitledOpen.setDecompilerReferences(metadataSystem, settings, decompilationOptions);    sameTitledOpen.setType(resolvedType);    sameTitledOpen.setInitialNavigationLink(navigatonLink);    sameTitledOpen.resetScrollPosition();    sameTitledOpen.decompile();    addOrSwitchToTab(sameTitledOpen);   } else {    OpenFile open = new OpenFile(tabTitle, path, theme, mainWindow);    open.setDecompilerReferences(metadataSystem, settings, decompilationOptions);    open.setType(resolvedType);    open.setInitialNavigationLink(navigatonLink);    open.decompile();    hmap.add(open);    addOrSwitchToTab(open);   }  }   private void extractSimpleFileEntryToTextPane(InputStream inputStream, String tabTitle, String path)    throws Exception {   if (inputStream == null || tabTitle == null || tabTitle.trim().length() < 1 || path == null) {    throw new FileEntryNotFoundException();   }   OpenFile sameTitledOpen = null;   for (OpenFile nextOpen : hmap) {    if (tabTitle.equals(nextOpen.name)) {     sameTitledOpen = nextOpen;     break;    }   }   if (sameTitledOpen != null && path.equals(sameTitledOpen.path)) {    addOrSwitchToTab(sameTitledOpen);    return;   }    // build tab content   StringBuilder sb = new StringBuilder();   long nonprintableCharactersCount = 0;   try (InputStreamReader inputStreamReader = new InputStreamReader(inputStream);     BufferedReader reader = new BufferedReader(inputStreamReader);) {    String line;    while ((line = reader.readLine()) != null) {     sb.append(line).append("\n");      for (byte nextByte : line.getBytes()) {      if (nextByte <= 0) {       nonprintableCharactersCount++;      }     }     }   }    // guess binary or text   String extension = "." + tabTitle.replaceAll("^[^\\.]*$", "").replaceAll("[^\\.]*\\.", "");   boolean isTextFile = (OpenFile.WELL_KNOWN_TEXT_FILE_EXTENSIONS.contains(extension) ||     nonprintableCharactersCount < sb.length() / 5);   if (!isTextFile) {    throw new FileIsBinaryException();   }    // open tab   if (sameTitledOpen != null) {    sameTitledOpen.path = path;    sameTitledOpen.setDecompilerReferences(metadataSystem, settings, decompilationOptions);    sameTitledOpen.resetScrollPosition();    sameTitledOpen.setContent(sb.toString());    addOrSwitchToTab(sameTitledOpen);   } else {    OpenFile open = new OpenFile(tabTitle, path, theme, mainWindow);    open.setDecompilerReferences(metadataSystem, settings, decompilationOptions);    open.setContent(sb.toString());    hmap.add(open);    addOrSwitchToTab(open);   }  }   private class TabChangeListener implements ChangeListener {   @Override   public void stateChanged(ChangeEvent e) {    int selectedIndex = house.getSelectedIndex();    if (selectedIndex < 0) {     return;    }    for (OpenFile open : hmap) {     if (house.indexOfTab(open.name) == selectedIndex) {       if (open.getType() != null && !open.isContentValid()) {       updateOpenClass(open);       break;      }      }    }   }  }   public void updateOpenClasses() {   // invalidate all open classes (update will hapen at tab change)   for (OpenFile open : hmap) {    if (open.getType() != null) {     open.invalidateContent();    }   }   // update the current open tab - if it is a class   for (OpenFile open : hmap) {    if (open.getType() != null && isTabInForeground(open)) {     updateOpenClass(open);     break;    }   }  }   private void updateOpenClass(final OpenFile open) {   if (open.getType() == null) {    return;   }   new Thread(new Runnable() {    @Override    public void run() {     try {      bar.setVisible(true);      label.setText("Extracting: " + open.name);      open.invalidateContent();      open.decompile();      label.setText("Complete");     } catch (Exception e) {      label.setText("Error, cannot update: " + open.name);     } finally {      bar.setVisible(false);     }    }   }).start();  }   private boolean isTabInForeground(OpenFile open) {   String title = open.name;   int selectedIndex = house.getSelectedIndex();   return (selectedIndex >= 0 && selectedIndex == house.indexOfTab(title));  }   private final class State implements AutoCloseable {   private final String key;   private final File file;   final JarFile jarFile;   final ITypeLoader typeLoader;    private State(String key, File file, JarFile jarFile, ITypeLoader typeLoader) {    this.key = VerifyArgument.notNull(key, "key");    this.file = VerifyArgument.notNull(file, "file");    this.jarFile = jarFile;    this.typeLoader = typeLoader;   }    @Override   public void close() {    if (typeLoader != null) {     Model.this.typeLoader.getTypeLoaders().remove(typeLoader);    }    Closer.tryClose(jarFile);   }    @SuppressWarnings("unused")   public File getFile() {    return file;   }    @SuppressWarnings("unused")   public String getKey() {    return key;   }  }   private class Tab extends JPanel {   private static final long serialVersionUID = -514663009333644974L;   private JLabel closeButton = new JLabel(new ImageIcon(Toolkit.getDefaultToolkit().getImage(     this.getClass().getResource("/resources/icon_close.png"))));   private JLabel tabTitle = new JLabel();   private String title = "";    public Tab(String t) {    super(new GridBagLayout());    this.setOpaque(false);     this.title = t;    this.tabTitle = new JLabel(title);     this.createTab();   }    public JLabel getButton() {    return this.closeButton;   }    public void createTab() {    GridBagConstraints gbc = new GridBagConstraints();    gbc.gridx = 0;    gbc.gridy = 0;    gbc.weightx = 1;    this.add(tabTitle, gbc);    gbc.gridx++;    gbc.insets = new Insets(0, 5, 0, 0);    gbc.anchor = GridBagConstraints.EAST;    this.add(closeButton, gbc);   }  }   private class CloseTab extends MouseAdapter {   String title;    public CloseTab(String title) {    this.title = title;   }    @Override   public void mouseClicked(MouseEvent e) {    int index = house.indexOfTab(title);    closeOpenTab(index);   }  }   public DefaultMutableTreeNode loadNodesByNames(DefaultMutableTreeNode node, List<String> originalNames) {   List<TreeNodeUserObject> args = new ArrayList<>();   for (String originalName : originalNames) {    args.add(new TreeNodeUserObject(originalName));   }   return loadNodesByUserObj(node, args);  }   public DefaultMutableTreeNode loadNodesByUserObj(DefaultMutableTreeNode node, List<TreeNodeUserObject> args) {   if (args.size() > 0) {    TreeNodeUserObject name = args.remove(0);    DefaultMutableTreeNode nod = getChild(node, name);    if (nod == null)     nod = new DefaultMutableTreeNode(name);    node.add(loadNodesByUserObj(nod, args));   }   return node;  }   @SuppressWarnings("unchecked")  public DefaultMutableTreeNode getChild(DefaultMutableTreeNode node, TreeNodeUserObject name) {   Enumeration<DefaultMutableTreeNode> entry = node.children();   while (entry.hasMoreElements()) {    DefaultMutableTreeNode nods = entry.nextElement();    if (((TreeNodeUserObject) nods.getUserObject()).getOriginalName().equals(name.getOriginalName())) {     return nods;    }   }   return null;  }   public void loadFile(File file) {   if (open)    closeFile();   this.file = file;   loadTree();  }   public void updateTree() {   TreeUtil treeUtil = new TreeUtil(tree);   treeExpansionState = treeUtil.getExpansionState();   loadTree();  }   public void loadTree() {   new Thread(new Runnable() {    @Override    public void run() {     try {      if (file == null) {       return;      }      tree.setModel(new DefaultTreeModel(null));       if (file.length() > MAX_JAR_FILE_SIZE_BYTES) {       throw new TooLargeFileException(file.length());      }      if (file.getName().endsWith(".zip") || file.getName().endsWith(".jar")) {       JarFile jfile;       jfile = new JarFile(file);       label.setText("Loading: " + jfile.getName());       bar.setVisible(true);        JarEntryFilter jarEntryFilter = new JarEntryFilter(jfile);       List<String> mass = null;       if (luytenPrefs.isFilterOutInnerClassEntries()) {        mass = jarEntryFilter.getEntriesWithoutInnerClasses();       } else {        mass = jarEntryFilter.getAllEntriesFromJar();       }       buildTreeFromMass(mass);        if (state == null) {        ITypeLoader jarLoader = new JarTypeLoader(jfile);        typeLoader.getTypeLoaders().add(jarLoader);        state = new State(file.getCanonicalPath(), file, jfile, jarLoader);       }       open = true;       label.setText("Complete");      } else {       TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));       final DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);       tree.setModel(new DefaultTreeModel(top));       settings.setTypeLoader(new InputTypeLoader());       open = true;       label.setText("Complete");        // open it automatically       new Thread() {        public void run() {         TreePath trp = new TreePath(top.getPath());         openEntryByTreePath(trp);        };       }.start();      }       if (treeExpansionState != null) {       try {        TreeUtil treeUtil = new TreeUtil(tree);        treeUtil.restoreExpanstionState(treeExpansionState);       } catch (Exception exc) {        exc.printStackTrace();       }      }     } catch (TooLargeFileException e) {      label.setText("File is too large: " + file.getName() + " - size: " + e.getReadableFileSize());      closeFile();     } catch (Exception e1) {      e1.printStackTrace();      label.setText("Cannot open: " + file.getName());      closeFile();     } finally {      mainWindow.onFileLoadEnded(file, open);      bar.setVisible(false);     }    }    }).start();  }   private void buildTreeFromMass(List<String> mass) {   if (luytenPrefs.isPackageExplorerStyle()) {    buildFlatTreeFromMass(mass);   } else {    buildDirectoryTreeFromMass(mass);   }  }   private void buildDirectoryTreeFromMass(List<String> mass) {   TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));   DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);   List<String> sort = new ArrayList<String>();   Collections.sort(mass, String.CASE_INSENSITIVE_ORDER);   for (String m : mass)    if (m.contains("META-INF") && !sort.contains(m))     sort.add(m);   Set<String> set = new HashSet<String>();   for (String m : mass) {    if (m.contains("/")) {     set.add(m.substring(0, m.lastIndexOf("/") + 1));    }   }   List<String> packs = Arrays.asList(set.toArray(new String[] {}));   Collections.sort(packs, String.CASE_INSENSITIVE_ORDER);   Collections.sort(packs, new Comparator<String>() {    public int compare(String o1, String o2) {     return o2.split("/").length - o1.split("/").length;    }   });   for (String pack : packs)    for (String m : mass)     if (!m.contains("META-INF") && m.contains(pack)       && !m.replace(pack, "").contains("/"))      sort.add(m);   for (String m : mass)    if (!m.contains("META-INF") && !m.contains("/") && !sort.contains(m))     sort.add(m);   for (String pack : sort) {    LinkedList<String> list = new LinkedList<String>(Arrays.asList(pack.split("/")));    loadNodesByNames(top, list);   }   tree.setModel(new DefaultTreeModel(top));  }   private void buildFlatTreeFromMass(List<String> mass) {   TreeNodeUserObject topNodeUserObject = new TreeNodeUserObject(getName(file.getName()));   DefaultMutableTreeNode top = new DefaultMutableTreeNode(topNodeUserObject);    TreeMap<String, TreeSet<String>> packages = new TreeMap<>();   HashSet<String> classContainingPackageRoots = new HashSet<>();    Comparator<String> sortByFileExtensionsComparator = new Comparator<String>() {    // (assertion: mass does not contain null elements)    @Override    public int compare(String o1, String o2) {     int comp = o1.replaceAll("[^\\.]*\\.", "").compareTo(o2.replaceAll("[^\\.]*\\.", ""));     if (comp != 0)      return comp;     return o1.compareTo(o2);    }   };    for (String entry : mass) {    String packagePath = "";    String packageRoot = "";    if (entry.contains("/")) {     packagePath = entry.replaceAll("/[^/]*$", "");     packageRoot = entry.replaceAll("/.*$", "");    }    String packageEntry = entry.replace(packagePath + "/", "");    if (!packages.containsKey(packagePath)) {     packages.put(packagePath, new TreeSet<String>(sortByFileExtensionsComparator));    }    packages.get(packagePath).add(packageEntry);    if (!entry.startsWith("META-INF") && packageRoot.trim().length() > 0 &&      entry.matches(".*\\.(class|java|prop|properties)$")) {     classContainingPackageRoots.add(packageRoot);    }   }    // META-INF comes first -> not flat   for (String packagePath : packages.keySet()) {    if (packagePath.startsWith("META-INF")) {     List<String> packagePathElements = Arrays.asList(packagePath.split("/"));     for (String entry : packages.get(packagePath)) {      ArrayList<String> list = new ArrayList<>(packagePathElements);      list.add(entry);      loadNodesByNames(top, list);     }    }   }    // real packages: path starts with a classContainingPackageRoot -> flat   for (String packagePath : packages.keySet()) {    String packageRoot = packagePath.replaceAll("/.*$", "");    if (classContainingPackageRoots.contains(packageRoot)) {     for (String entry : packages.get(packagePath)) {      ArrayList<TreeNodeUserObject> list = new ArrayList<>();      list.add(new TreeNodeUserObject(packagePath, packagePath.replaceAll("/", ".")));      list.add(new TreeNodeUserObject(entry));      loadNodesByUserObj(top, list);     }    }   }    // the rest, not real packages but directories -> not flat   for (String packagePath : packages.keySet()) {    String packageRoot = packagePath.replaceAll("/.*$", "");    if (!classContainingPackageRoots.contains(packageRoot) &&      !packagePath.startsWith("META-INF") && packagePath.length() > 0) {     List<String> packagePathElements = Arrays.asList(packagePath.split("/"));     for (String entry : packages.get(packagePath)) {      ArrayList<String> list = new ArrayList<>(packagePathElements);      list.add(entry);      loadNodesByNames(top, list);     }    }   }    // the default package -> not flat   String packagePath = "";   if (packages.containsKey(packagePath)) {    for (String entry : packages.get(packagePath)) {     ArrayList<String> list = new ArrayList<>();     list.add(entry);     loadNodesByNames(top, list);    }   }   tree.setModel(new DefaultTreeModel(top));  }   public void closeFile() {   for (OpenFile co : hmap) {    int pos = house.indexOfTab(co.name);    if (pos >= 0)     house.remove(pos);    co.close();   }    final State oldState = state;   Model.this.state = null;   if (oldState != null) {    Closer.tryClose(oldState);   }    hmap.clear();   tree.setModel(new DefaultTreeModel(null));   metadataSystem = new MetadataSystem(typeLoader);   file = null;   treeExpansionState = null;   open = false;   mainWindow.onFileLoadEnded(file, open);  }   public void changeTheme(String xml) {   InputStream in = getClass().getResourceAsStream(LuytenPreferences.THEME_XML_PATH + xml);   try {    if (in != null) {     theme = Theme.load(in);     for (OpenFile f : hmap) {      theme.apply(f.textArea);     }    }   } catch (Exception e1) {    e1.printStackTrace();    JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);   }  }   public File getOpenedFile() {   File openedFile = null;   if (file != null && open) {    openedFile = file;   }   if (openedFile == null) {    label.setText("No open file");   }   return openedFile;  }   public String getCurrentTabTitle() {   String tabTitle = null;   try {    int pos = house.getSelectedIndex();    if (pos >= 0) {     tabTitle = house.getTitleAt(pos);    }   } catch (Exception e1) {    e1.printStackTrace();   }   if (tabTitle == null) {    label.setText("No open tab");   }   return tabTitle;  }   public RSyntaxTextArea getCurrentTextArea() {   RSyntaxTextArea currentTextArea = null;   try {    int pos = house.getSelectedIndex();    if (pos >= 0) {     RTextScrollPane co = (RTextScrollPane) house.getComponentAt(pos);     currentTextArea = (RSyntaxTextArea) co.getViewport().getView();    }   } catch (Exception e1) {    e1.printStackTrace();   }   if (currentTextArea == null) {    label.setText("No open tab");   }   return currentTextArea;  }   public void startWarmUpThread() {   new Thread() {    public void run() {     try {      Thread.sleep(500);      String internalName = FindBox.class.getName();      TypeReference type = metadataSystem.lookupType(internalName);      TypeDefinition resolvedType = null;      if ((type == null) || ((resolvedType = type.resolve()) == null)) {       return;      }      StringWriter stringwriter = new StringWriter();      settings.getLanguage().decompileType(resolvedType,        new PlainTextOutput(stringwriter), decompilationOptions);      String decompiledSource = stringwriter.toString();      OpenFile open = new OpenFile(internalName, "*/" + internalName, theme, mainWindow);      open.setContent(decompiledSource);      JTabbedPane pane = new JTabbedPane();      pane.setTabLayoutPolicy(JTabbedPane.SCROLL_TAB_LAYOUT);      pane.addTab("title", open.scrollPane);      pane.setSelectedIndex(pane.indexOfTab("title"));     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }   public void navigateTo(final String uniqueStr) {   new Thread(new Runnable() {    @Override    public void run() {     if (uniqueStr == null)      return;     String[] linkParts = uniqueStr.split("\\|");     if (linkParts.length <= 1)      return;     String destinationTypeStr = linkParts[1];     try {      bar.setVisible(true);      label.setText("Navigating: " + destinationTypeStr.replaceAll("/", "."));       TypeReference type = metadataSystem.lookupType(destinationTypeStr);      if (type == null)       throw new RuntimeException("Cannot lookup type: " + destinationTypeStr);      TypeDefinition typeDef = type.resolve();      if (typeDef == null)       throw new RuntimeException("Cannot resolve type: " + destinationTypeStr);       String tabTitle = typeDef.getName() + ".class";      extractClassToTextPane(typeDef, tabTitle, destinationTypeStr, uniqueStr);       label.setText("Complete");     } catch (Exception e) {      label.setText("Cannot navigate: " + destinationTypeStr.replaceAll("/", "."));      e.printStackTrace();     } finally {      bar.setVisible(false);     }    }   }).start();  } } " compose:StringConcatenation merge: LineBased]
					[NT -> ConfigSaver.java.merge : .java.merge-File]
						[T -> ConfigSaver.java : .java-Content "package com.modcrafting.luyten;  import java.lang.reflect.Field; import java.lang.reflect.Modifier; import java.util.prefs.Preferences; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.languages.Language; import com.strobel.decompiler.languages.Languages; import com.strobel.decompiler.languages.java.JavaFormattingOptions;  public class ConfigSaver {   private static final String FLATTEN_SWITCH_BLOCKS_ID = "flattenSwitchBlocks";  private static final String FORCE_EXPLICIT_IMPORTS_ID = "forceExplicitImports";  private static final String SHOW_SYNTHETIC_MEMBERS_ID = "showSyntheticMembers";  private static final String EXCLUDE_NESTED_TYPES_ID = "excludeNestedTypes";  private static final String FORCE_EXPLICIT_TYPE_ARGUMENTS_ID = "forceExplicitTypeArguments";  private static final String RETAIN_REDUNDANT_CASTS_ID = "retainRedundantCasts";  private static final String INCLUDE_ERROR_DIAGNOSTICS_ID = "includeErrorDiagnostics";  private static final String LANGUAGE_NAME_ID = "languageName";   private static final String MAIN_WINDOW_ID_PREFIX = "main";  private static final String FIND_WINDOW_ID_PREFIX = "find";  private static final String WINDOW_IS_FULL_SCREEN_ID = "WindowIsFullScreen";  private static final String WINDOW_WIDTH_ID = "WindowWidth";  private static final String WINDOW_HEIGHT_ID = "WindowHeight";  private static final String WINDOW_X_ID = "WindowX";  private static final String WINDOW_Y_ID = "WindowY";   private DecompilerSettings decompilerSettings;  private WindowPosition mainWindowPosition;  private WindowPosition findWindowPosition;  private LuytenPreferences luytenPreferences;   private static ConfigSaver theLoadedInstance;   /**   * Do not instantiate, get the loaded instance   */  private ConfigSaver() {}   public static ConfigSaver getLoadedInstance() {   if (theLoadedInstance == null) {    synchronized (ConfigSaver.class) {     if (theLoadedInstance == null) {      theLoadedInstance = new ConfigSaver();      theLoadedInstance.loadConfig();     }    }   }   return theLoadedInstance;  }   /**   * Do not load, get the loaded instance   */  private void loadConfig() {   decompilerSettings = new DecompilerSettings();   if (decompilerSettings.getFormattingOptions() == null) {    decompilerSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   luytenPreferences = new LuytenPreferences();   mainWindowPosition = new WindowPosition();   findWindowPosition = new WindowPosition();   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     decompilerSettings.setFlattenSwitchBlocks(prefs.getBoolean(FLATTEN_SWITCH_BLOCKS_ID,      decompilerSettings.getFlattenSwitchBlocks()));    decompilerSettings.setForceExplicitImports(prefs.getBoolean(FORCE_EXPLICIT_IMPORTS_ID,      decompilerSettings.getForceExplicitImports()));    decompilerSettings.setShowSyntheticMembers(prefs.getBoolean(SHOW_SYNTHETIC_MEMBERS_ID,      decompilerSettings.getShowSyntheticMembers()));    decompilerSettings.setExcludeNestedTypes(prefs.getBoolean(EXCLUDE_NESTED_TYPES_ID,      decompilerSettings.getExcludeNestedTypes()));    decompilerSettings.setForceExplicitTypeArguments(prefs.getBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID,      decompilerSettings.getForceExplicitTypeArguments()));    decompilerSettings.setRetainRedundantCasts(prefs.getBoolean(RETAIN_REDUNDANT_CASTS_ID,      decompilerSettings.getRetainRedundantCasts()));    decompilerSettings.setIncludeErrorDiagnostics(prefs.getBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID,      decompilerSettings.getIncludeErrorDiagnostics()));    decompilerSettings.setLanguage(findLanguageByName(prefs.get(LANGUAGE_NAME_ID,      decompilerSettings.getLanguage().getName())));     mainWindowPosition = loadWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX);    findWindowPosition = loadWindowPosition(prefs, FIND_WINDOW_ID_PREFIX);    luytenPreferences = loadLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }   private WindowPosition loadWindowPosition(Preferences prefs, String windowIdPrefix) {   WindowPosition windowPosition = new WindowPosition();   windowPosition.setFullScreen(prefs.getBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, false));   windowPosition.setWindowWidth(prefs.getInt(windowIdPrefix + WINDOW_WIDTH_ID, 0));   windowPosition.setWindowHeight(prefs.getInt(windowIdPrefix + WINDOW_HEIGHT_ID, 0));   windowPosition.setWindowX(prefs.getInt(windowIdPrefix + WINDOW_X_ID, 0));   windowPosition.setWindowY(prefs.getInt(windowIdPrefix + WINDOW_Y_ID, 0));   return windowPosition;  }   // load preferences by their java variable names  private LuytenPreferences loadLuytenPreferences(Preferences prefs) throws Exception {   LuytenPreferences newLuytenPrefs = new LuytenPreferences();   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object defaultVal = field.get(newLuytenPrefs);     if (field.getType() == String.class) {     String defaultStr = (String) (defaultVal == null ? "" : defaultVal);     field.set(newLuytenPrefs, prefs.get(prefId, defaultStr));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     Boolean defaultBool = (Boolean) (defaultVal == null ? new Boolean(false) : defaultVal);     field.setBoolean(newLuytenPrefs, prefs.getBoolean(prefId, defaultBool));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     Integer defaultInt = (Integer) (defaultVal == null ? new Integer(0) : defaultVal);     field.setInt(newLuytenPrefs, prefs.getInt(prefId, defaultInt));    }   }   return newLuytenPrefs;  }   public void saveConfig() {   // Registry path on Windows Xp:   // HKEY_CURRENT_USER\Software\JavaSoft\Prefs\com\modcrafting\luyten   try {    Preferences prefs = Preferences.userNodeForPackage(ConfigSaver.class);     prefs.putBoolean(FLATTEN_SWITCH_BLOCKS_ID, decompilerSettings.getFlattenSwitchBlocks());    prefs.putBoolean(FORCE_EXPLICIT_IMPORTS_ID, decompilerSettings.getForceExplicitImports());    prefs.putBoolean(SHOW_SYNTHETIC_MEMBERS_ID, decompilerSettings.getShowSyntheticMembers());    prefs.putBoolean(EXCLUDE_NESTED_TYPES_ID, decompilerSettings.getExcludeNestedTypes());    prefs.putBoolean(FORCE_EXPLICIT_TYPE_ARGUMENTS_ID, decompilerSettings.getForceExplicitTypeArguments());    prefs.putBoolean(RETAIN_REDUNDANT_CASTS_ID, decompilerSettings.getRetainRedundantCasts());    prefs.putBoolean(INCLUDE_ERROR_DIAGNOSTICS_ID, decompilerSettings.getIncludeErrorDiagnostics());    prefs.put(LANGUAGE_NAME_ID, decompilerSettings.getLanguage().getName());     saveWindowPosition(prefs, MAIN_WINDOW_ID_PREFIX, mainWindowPosition);    saveWindowPosition(prefs, FIND_WINDOW_ID_PREFIX, findWindowPosition);    saveLuytenPreferences(prefs);   } catch (Exception e) {    e.printStackTrace();   }  }   private void saveWindowPosition(Preferences prefs, String windowIdPrefix, WindowPosition windowPosition) {   prefs.putBoolean(windowIdPrefix + WINDOW_IS_FULL_SCREEN_ID, windowPosition.isFullScreen());   prefs.putInt(windowIdPrefix + WINDOW_WIDTH_ID, windowPosition.getWindowWidth());   prefs.putInt(windowIdPrefix + WINDOW_HEIGHT_ID, windowPosition.getWindowHeight());   prefs.putInt(windowIdPrefix + WINDOW_X_ID, windowPosition.getWindowX());   prefs.putInt(windowIdPrefix + WINDOW_Y_ID, windowPosition.getWindowY());  }   // save preferences by their java variable names  private void saveLuytenPreferences(Preferences prefs) throws Exception {   for (Field field : LuytenPreferences.class.getDeclaredFields()) {    if (Modifier.isStatic(field.getModifiers()))     continue;    field.setAccessible(true);    String prefId = field.getName();    Object value = field.get(luytenPreferences);     if (field.getType() == String.class) {     prefs.put(prefId, (String) (value == null ? "" : value));     } else if (field.getType() == Boolean.class || field.getType() == boolean.class) {     prefs.putBoolean(prefId, (Boolean) (value == null ? new Boolean(false) : value));     } else if (field.getType() == Integer.class || field.getType() == int.class) {     prefs.putInt(prefId, (Integer) (value == null ? new Integer(0) : value));    }   }  }   private Language findLanguageByName(String languageName) {   if (languageName != null) {     if (languageName.equals(Languages.java().getName())) {     return Languages.java();    } else if (languageName.equals(Languages.bytecode().getName())) {     return Languages.bytecode();    } else if (languageName.equals(Languages.bytecodeAst().getName())) {     return Languages.bytecodeAst();    }     for (Language language : Languages.debug()) {     if (languageName.equals(language.getName())) {      return language;     }    }   }   return Languages.java();  }   public DecompilerSettings getDecompilerSettings() {   return decompilerSettings;  }   public WindowPosition getMainWindowPosition() {   return mainWindowPosition;  }   public WindowPosition getFindWindowPosition() {   return findWindowPosition;  }    public LuytenPreferences getLuytenPreferences() {   return luytenPreferences;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Luyten.java.merge : .java.merge-File]
						[T -> Luyten.java : .java-Content "package com.modcrafting.luyten;  import java.io.File; import javax.swing.SwingUtilities; import javax.swing.UIManager;  /**  * Starter, the main class  */ public class Luyten {   public static void main(String[] args) {   try {    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());   } catch (Exception e) {    e.printStackTrace();   }    // for TotalCommander External Viewer setting:   // javaw -jar "c:\Program Files\Luyten\luyten.jar"   // (TC will not complain about temporary file when opening .class from .zip or .jar)   final File fileFromCommandLine = getFileFromCommandLine(args);    SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     MainWindow mainWindow = new MainWindow(fileFromCommandLine);     mainWindow.setVisible(true);    }   });  }   public static File getFileFromCommandLine(String[] args) {   File fileFromCommandLine = null;   try {    if (args.length > 0) {     String realFileName = new File(args[0]).getCanonicalPath();     fileFromCommandLine = new File(realFileName);    }   } catch (Exception e) {    e.printStackTrace();   }   return fileFromCommandLine;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LinkProvider.java.merge : .java.merge-File]
						[T -> LinkProvider.java : .java-Content "package com.modcrafting.luyten;  import java.util.Map; import java.util.Set;  public interface LinkProvider {   public void generateContent();  public String getTextContent();  public void processLinks();   public Map<String, Selection> getDefinitionToSelectionMap();  public Map<String, Set<Selection>> getReferenceToSelectionsMap();  public boolean isLinkNavigable(String uniqueStr);  public String getLinkDescription(String uniqueStr);  } " compose:StringConcatenation merge: LineBased]
					[NT -> TreeUtil.java.merge : .java.merge-File]
						[T -> TreeUtil.java : .java-Content "package com.modcrafting.luyten;  import java.util.HashSet; import java.util.Set; import javax.swing.JTree; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.TreePath;  public class TreeUtil {   private JTree tree;   public TreeUtil() {}   public TreeUtil(JTree tree) {   this.tree = tree;  }   public Set<String> getExpansionState() {   Set<String> openedSet = new HashSet<>();   if (tree != null) {    int rowCount = tree.getRowCount();    for (int i = 0; i < rowCount; i++) {     TreePath path = tree.getPathForRow(i);     if (tree.isExpanded(path)) {      String rowPathStr = getRowPathStr(path);      // for switching Package Explorer on/off      openedSet.addAll(getAllParentPathsStr(rowPathStr));     }    }   }   return openedSet;  }   private Set<String> getAllParentPathsStr(String rowPathStr) {   Set<String> parents = new HashSet<>();   parents.add(rowPathStr);   if (rowPathStr.contains("/")) {    String[] pathElements = rowPathStr.split("/");    String path = "";    for (String pathElement : pathElements) {     path = path + pathElement + "/";     parents.add(path);    }   }   return parents;  }   public void restoreExpanstionState(Set<String> expansionState) {   if (tree != null && expansionState != null) {    // tree.getRowCount() changes at tree.expandRow()    for (int i = 0; i < tree.getRowCount(); i++) {     TreePath path = tree.getPathForRow(i);     if (expansionState.contains(getRowPathStr(path))) {      tree.expandRow(i);     }    }   }  }   private String getRowPathStr(TreePath trp) {   String pathStr = "";   if (trp.getPathCount() > 1) {    for (int i = 1; i < trp.getPathCount(); i++) {     DefaultMutableTreeNode node = (DefaultMutableTreeNode) trp.getPathComponent(i);     TreeNodeUserObject userObject = (TreeNodeUserObject) node.getUserObject();     pathStr = pathStr + userObject.getOriginalName() + "/";    }   }   return pathStr;  }   public JTree getTree() {   return tree;  }   public void setTree(JTree tree) {   this.tree = tree;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FindBox.java.merge : .java.merge-File]
						[T -> FindBox.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Dimension; import java.awt.Toolkit; import java.awt.event.ActionEvent; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.BorderFactory; import javax.swing.GroupLayout; import javax.swing.GroupLayout.Alignment; import javax.swing.JButton; import javax.swing.JCheckBox; import javax.swing.JComponent; import javax.swing.JDialog; import javax.swing.JLabel; import javax.swing.JTextField; import javax.swing.KeyStroke; import javax.swing.SwingConstants; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rtextarea.SearchContext; import org.fife.ui.rtextarea.SearchEngine;  public class FindBox extends JDialog {  private static final long serialVersionUID = -4125409760166690462L;   private JCheckBox mcase;  private JCheckBox regex;  private JCheckBox wholew;  private JCheckBox reverse;  private JButton findButton;  private JTextField textField;  private MainWindow mainWindow;   public void showFindBox() {   this.setVisible(true);   this.textField.requestFocus();   this.textField.selectAll();  }   public void hideFindBox() {   this.setVisible(false);  }   public FindBox(MainWindow mainWindow) {   this.mainWindow = mainWindow;   this.setDefaultCloseOperation(HIDE_ON_CLOSE);   this.setHideOnEscapeButton();    JLabel label = new JLabel("Find What:");   textField = new JTextField();    RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();   if (pane != null) {    textField.setText(pane.getSelectedText());   }   mcase = new JCheckBox("Match Case");   regex = new JCheckBox("Regex");   wholew = new JCheckBox("Whole Words");   reverse = new JCheckBox("Search Backwards");    findButton = new JButton("Find");   findButton.addActionListener(new FindButton());   this.getRootPane().setDefaultButton(findButton);    mcase.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   regex.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   wholew.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));   reverse.setBorder(BorderFactory.createEmptyBorder(0, 0, 0, 0));    Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   final Dimension center = new Dimension((int) (screenSize.width * 0.35),     Math.min((int) (screenSize.height * 0.20), 200));   final int x = (int) (center.width * 0.2);   final int y = (int) (center.height * 0.2);   this.setBounds(x, y, center.width, center.height);   this.setResizable(false);    GroupLayout layout = new GroupLayout(getRootPane());   getRootPane().setLayout(layout);   layout.setAutoCreateGaps(true);   layout.setAutoCreateContainerGaps(true);    layout.setHorizontalGroup(layout.createSequentialGroup()     .addComponent(label)     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(textField)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(mcase)           .addComponent(wholew))         .addGroup(layout.createParallelGroup(Alignment.LEADING)           .addComponent(regex)           .addComponent(reverse))))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addComponent(findButton))     );    layout.linkSize(SwingConstants.HORIZONTAL, findButton);   layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(Alignment.BASELINE)       .addComponent(label)       .addComponent(textField)       .addComponent(findButton))     .addGroup(layout.createParallelGroup(Alignment.LEADING)       .addGroup(layout.createSequentialGroup()         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(mcase)           .addComponent(regex))         .addGroup(layout.createParallelGroup(Alignment.BASELINE)           .addComponent(wholew)           .addComponent(reverse))))     );    this.adjustWindowPositionBySavedState();   this.setSaveWindowPositionOnClosing();    this.setName("Find");   this.setTitle("Find");   this.setVisible(true);  }   private class FindButton extends AbstractAction {   private static final long serialVersionUID = 75954129199541874L;    @Override   public void actionPerformed(ActionEvent event) {    if (textField.getText().length() == 0)     return;     RSyntaxTextArea pane = mainWindow.getModel().getCurrentTextArea();    if (pane == null)     return;     SearchContext context = new SearchContext();    context.setSearchFor(textField.getText());    context.setMatchCase(mcase.isSelected());    context.setRegularExpression(regex.isSelected());    context.setSearchForward(!reverse.isSelected());    context.setWholeWord(wholew.isSelected());     if (!SearchEngine.find(pane, context)) {     pane.setSelectionStart(0);     pane.setSelectionEnd(0);    }   }   }   private void setHideOnEscapeButton() {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     FindBox.this.setVisible(false);    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   this.getRootPane().getInputMap(JComponent.WHEN_IN_FOCUSED_WINDOW).put(escapeKeyStroke, "ESCAPE");   this.getRootPane().getActionMap().put("ESCAPE", escapeAction);  }   private void adjustWindowPositionBySavedState() {   WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();    if (windowPosition.isSavedWindowPositionValid()) {    this.setLocation(windowPosition.getWindowX(), windowPosition.getWindowY());   }  }   private void setSaveWindowPositionOnClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowDeactivated(WindowEvent e) {     WindowPosition windowPosition = ConfigSaver.getLoadedInstance().getFindWindowPosition();     windowPosition.readPositionFromDialog(FindBox.this);    }   });  } } " compose:StringConcatenation merge: LineBased]
					[NT -> Selection.java.merge : .java.merge-File]
						[T -> Selection.java : .java-Content "package com.modcrafting.luyten;  public class Selection implements Comparable<Selection> {  public final Integer from;  public final Integer to;   public Selection(Integer from, Integer to) {   this.from = from;   this.to = to;  }   @Override  public int compareTo(Selection o) {   return from.compareTo(o.from);  }   @Override  public int hashCode() {   final int prime = 31;   int result = 1;   result = prime * result + ((from == null) ? 0 : from.hashCode());   return result;  }   @Override  public boolean equals(Object obj) {   if (this == obj)    return true;   if (obj == null)    return false;   if (getClass() != obj.getClass())    return false;   Selection other = (Selection) obj;   if (from == null) {    if (other.from != null)     return false;   } else if (!from.equals(other.from))    return false;   return true;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> MainMenuBar.java.merge : .java.merge-File]
						[T -> MainMenuBar.java : .java-Content "package com.modcrafting.luyten;  import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.KeyEvent; import java.util.Collections; import java.util.HashMap; import java.util.Map; import javax.swing.AbstractAction; import javax.swing.AbstractButton; import javax.swing.ButtonGroup; import javax.swing.ButtonModel; import javax.swing.JCheckBox; import javax.swing.JMenu; import javax.swing.JMenuBar; import javax.swing.JMenuItem; import javax.swing.JOptionPane; import javax.swing.JRadioButtonMenuItem; import javax.swing.KeyStroke; import javax.swing.text.DefaultEditorKit; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.languages.Language; import com.strobel.decompiler.languages.Languages;  /**  * Main menu (only MainWindow should be called from here)  */ public class MainMenuBar extends JMenuBar {  private static final long serialVersionUID = 1L;   private final MainWindow mainWindow;  private final Map<String, Language> languageLookup = new HashMap<String, Language>();   private JCheckBox flattenSwitchBlocks;  private JCheckBox forceExplicitImports;  private JCheckBox forceExplicitTypes;  private JCheckBox showSyntheticMembers;  private JCheckBox excludeNestedTypes;  private JCheckBox retainRedundantCasts;  private JCheckBox showDebugInfo;  private JRadioButtonMenuItem java;  private JRadioButtonMenuItem bytecode;  private JRadioButtonMenuItem bytecodeAST;  private ButtonGroup languagesGroup;  private ButtonGroup themesGroup;  private JCheckBox packageExplorerStyle;  private JCheckBox filterOutInnerClassEntries;  private JCheckBox singleClickOpenEnabled;  private JCheckBox exitByEscEnabled;  private DecompilerSettings settings;  private LuytenPreferences luytenPrefs;   public MainMenuBar(MainWindow mainWnd) {   this.mainWindow = mainWnd;   ConfigSaver configSaver = ConfigSaver.getLoadedInstance();   settings = configSaver.getDecompilerSettings();   luytenPrefs = configSaver.getLuytenPreferences();    final JMenu fileMenu = new JMenu("File");   fileMenu.add(new JMenuItem("..."));   this.add(fileMenu);   final JMenu editMenu = new JMenu("Edit");   editMenu.add(new JMenuItem("..."));   this.add(editMenu);   final JMenu themesMenu = new JMenu("Themes");   themesMenu.add(new JMenuItem("..."));   this.add(themesMenu);   final JMenu operationMenu = new JMenu("Operation");   operationMenu.add(new JMenuItem("..."));   this.add(operationMenu);   final JMenu settingsMenu = new JMenu("Settings");   settingsMenu.add(new JMenuItem("..."));   this.add(settingsMenu);   final JMenu helpMenu = new JMenu("Help");   helpMenu.add(new JMenuItem("..."));   this.add(helpMenu);    // start quicker   new Thread() {    public void run() {     try {      // build menu later      buildFileMenu(fileMenu);      refreshMenuPopup(fileMenu);       buildEditMenu(editMenu);      refreshMenuPopup(editMenu);       buildThemesMenu(themesMenu);      refreshMenuPopup(themesMenu);       buildOperationMenu(operationMenu);      refreshMenuPopup(operationMenu);       buildSettingsMenu(settingsMenu);      refreshMenuPopup(settingsMenu);       buildHelpMenu(helpMenu);      refreshMenuPopup(helpMenu);     } catch (Exception e) {      e.printStackTrace();     }    }     // refresh currently opened menu     // (if user selected a menu before it was ready)    private void refreshMenuPopup(JMenu menu) {     try {      if (menu.isPopupMenuVisible()) {       menu.getPopupMenu().setVisible(false);       menu.getPopupMenu().setVisible(true);      }     } catch (Exception e) {      e.printStackTrace();     }    }   }.start();  }   private void buildFileMenu(final JMenu fileMenu) {   fileMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Open File...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_O, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onOpenFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Close");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_W, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onCloseFileMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Save As...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAsMenu();    }   });   fileMenu.add(menuItem);    menuItem = new JMenuItem("Save All...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_E, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSaveAllMenu();    }   });   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Recent Files");   menuItem.setEnabled(false);   fileMenu.add(menuItem);   fileMenu.addSeparator();    menuItem = new JMenuItem("Exit");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F4, ActionEvent.ALT_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onExitMenu();    }   });   fileMenu.add(menuItem);  }   private void buildEditMenu(JMenu editMenu) {   editMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Cut");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_X, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    menuItem = new JMenuItem("Copy");   menuItem.addActionListener(new DefaultEditorKit.CopyAction());   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_C, ActionEvent.CTRL_MASK));   editMenu.add(menuItem);    menuItem = new JMenuItem("Paste");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_V, ActionEvent.CTRL_MASK));   menuItem.setEnabled(false);   editMenu.add(menuItem);    editMenu.addSeparator();    menuItem = new JMenuItem("Select All");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_A, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onSelectAllMenu();    }   });   editMenu.add(menuItem);   editMenu.addSeparator();    menuItem = new JMenuItem("Find...");   menuItem.setAccelerator(KeyStroke.getKeyStroke(KeyEvent.VK_F, ActionEvent.CTRL_MASK));   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onFindMenu();    }   });   editMenu.add(menuItem);  }   private void buildThemesMenu(JMenu themesMenu) {   themesMenu.removeAll();   themesGroup = new ButtonGroup();   JRadioButtonMenuItem a = new JRadioButtonMenuItem(new ThemeAction("Default", "default.xml"));   a.setSelected("default.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Dark", "dark.xml"));   a.setSelected("dark.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Eclipse", "eclipse.xml"));   a.setSelected("eclipse.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);   a = new JRadioButtonMenuItem(new ThemeAction("Visual Studio", "vs.xml"));   a.setSelected("vs.xml".equals(luytenPrefs.getThemeXml()));   themesGroup.add(a);   themesMenu.add(a);  }   private void buildOperationMenu(JMenu operationMenu) {   operationMenu.removeAll();   packageExplorerStyle = new JCheckBox("Package Explorer Style");   packageExplorerStyle.setSelected(luytenPrefs.isPackageExplorerStyle());   packageExplorerStyle.setContentAreaFilled(false);   packageExplorerStyle.setFocusable(false);   packageExplorerStyle.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setPackageExplorerStyle(packageExplorerStyle.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(packageExplorerStyle);      filterOutInnerClassEntries = new JCheckBox("Filter Out Inner Class Entries");   filterOutInnerClassEntries.setSelected(luytenPrefs.isFilterOutInnerClassEntries());   filterOutInnerClassEntries.setContentAreaFilled(false);   filterOutInnerClassEntries.setFocusable(false);   filterOutInnerClassEntries.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setFilterOutInnerClassEntries(filterOutInnerClassEntries.isSelected());     mainWindow.onTreeSettingsChanged();    }   });   operationMenu.add(filterOutInnerClassEntries);    singleClickOpenEnabled = new JCheckBox("Single Click Open");   singleClickOpenEnabled.setSelected(luytenPrefs.isSingleClickOpenEnabled());   singleClickOpenEnabled.setContentAreaFilled(false);   singleClickOpenEnabled.setFocusable(false);   singleClickOpenEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setSingleClickOpenEnabled(singleClickOpenEnabled.isSelected());    }   });   operationMenu.add(singleClickOpenEnabled);    exitByEscEnabled = new JCheckBox("Exit By Esc");   exitByEscEnabled.setSelected(luytenPrefs.isExitByEscEnabled());   exitByEscEnabled.setContentAreaFilled(false);   exitByEscEnabled.setFocusable(false);   exitByEscEnabled.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     luytenPrefs.setExitByEscEnabled(exitByEscEnabled.isSelected());    }   });   operationMenu.add(exitByEscEnabled);  }   private void buildSettingsMenu(JMenu settingsMenu) {   settingsMenu.removeAll();   ActionListener settingsChanged = new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     new Thread() {      @Override      public void run() {       populateSettingsFromSettingsMenu();       mainWindow.onSettingsChanged();      }     }.start();    }   };   flattenSwitchBlocks = new JCheckBox("Flatten Switch Blocks");   flattenSwitchBlocks.setSelected(settings.getFlattenSwitchBlocks());   flattenSwitchBlocks.setContentAreaFilled(false);   flattenSwitchBlocks.setFocusable(false);   flattenSwitchBlocks.addActionListener(settingsChanged);   settingsMenu.add(flattenSwitchBlocks);    forceExplicitImports = new JCheckBox("Force Explicit Imports");   forceExplicitImports.setSelected(settings.getForceExplicitImports());   forceExplicitImports.setContentAreaFilled(false);   forceExplicitImports.setFocusable(false);   forceExplicitImports.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitImports);    forceExplicitTypes = new JCheckBox("Force Explicit Types");   forceExplicitTypes.setSelected(settings.getForceExplicitTypeArguments());   forceExplicitTypes.setContentAreaFilled(false);   forceExplicitTypes.setFocusable(false);   forceExplicitTypes.addActionListener(settingsChanged);   settingsMenu.add(forceExplicitTypes);    showSyntheticMembers = new JCheckBox("Show Synthetic Members");   showSyntheticMembers.setSelected(settings.getShowSyntheticMembers());   showSyntheticMembers.setContentAreaFilled(false);   showSyntheticMembers.setFocusable(false);   showSyntheticMembers.addActionListener(settingsChanged);   settingsMenu.add(showSyntheticMembers);    excludeNestedTypes = new JCheckBox("Exclude Nested Types");   excludeNestedTypes.setSelected(settings.getExcludeNestedTypes());   excludeNestedTypes.setContentAreaFilled(false);   excludeNestedTypes.setFocusable(false);   excludeNestedTypes.addActionListener(settingsChanged);   settingsMenu.add(excludeNestedTypes);    retainRedundantCasts = new JCheckBox("Retain Redundant Casts");   retainRedundantCasts.setSelected(settings.getRetainRedundantCasts());   retainRedundantCasts.setContentAreaFilled(false);   retainRedundantCasts.setFocusable(false);   retainRedundantCasts.addActionListener(settingsChanged);   settingsMenu.add(retainRedundantCasts);    JMenu debugSettingsMenu = new JMenu("Debug Settings");   showDebugInfo = new JCheckBox("Include Error Diagnostics");   showDebugInfo.setSelected(settings.getIncludeErrorDiagnostics());   showDebugInfo.setContentAreaFilled(false);   showDebugInfo.setFocusable(false);   showDebugInfo.addActionListener(settingsChanged);    debugSettingsMenu.add(showDebugInfo);   settingsMenu.add(debugSettingsMenu);   settingsMenu.addSeparator();    languageLookup.put(Languages.java().getName(), Languages.java());   languageLookup.put(Languages.bytecode().getName(), Languages.bytecode());   languageLookup.put(Languages.bytecodeAst().getName(), Languages.bytecodeAst());    languagesGroup = new ButtonGroup();   java = new JRadioButtonMenuItem(Languages.java().getName());   java.getModel().setActionCommand(Languages.java().getName());   java.setSelected(Languages.java().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(java);   settingsMenu.add(java);   bytecode = new JRadioButtonMenuItem(Languages.bytecode().getName());   bytecode.getModel().setActionCommand(Languages.bytecode().getName());   bytecode.setSelected(Languages.bytecode().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecode);   settingsMenu.add(bytecode);   bytecodeAST = new JRadioButtonMenuItem(Languages.bytecodeAst().getName());   bytecodeAST.getModel().setActionCommand(Languages.bytecodeAst().getName());   bytecodeAST.setSelected(Languages.bytecodeAst().getName().equals(settings.getLanguage().getName()));   languagesGroup.add(bytecodeAST);   settingsMenu.add(bytecodeAST);    JMenu debugLanguagesMenu = new JMenu("Debug Languages");   for (final Language language : Languages.debug()) {    final JRadioButtonMenuItem m = new JRadioButtonMenuItem(language.getName());    m.getModel().setActionCommand(language.getName());    m.setSelected(language.getName().equals(settings.getLanguage().getName()));    languagesGroup.add(m);    debugLanguagesMenu.add(m);    languageLookup.put(language.getName(), language);   }   for (AbstractButton button : Collections.list(languagesGroup.getElements())) {    button.addActionListener(settingsChanged);   }   settingsMenu.add(debugLanguagesMenu);  }   private void buildHelpMenu(JMenu helpMenu) {   helpMenu.removeAll();   JMenuItem menuItem = new JMenuItem("Legal");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent e) {     mainWindow.onLegalMenu();    }   });   helpMenu.add(menuItem);   menuItem = new JMenuItem("About");   menuItem.addActionListener(new ActionListener() {    @Override    public void actionPerformed(ActionEvent event) {     JOptionPane.showMessageDialog(null,       "Luyten Gui \n" +         "by Deathmarine\n\n" +         "Powered By\nProcyon\n" +         "(c) 2013 Mike Strobel\n\n" +         "RSyntaxTextArea\n" +         "(c) 2012 Robert Futrell\n" +         "All rights reserved.");    }   });   helpMenu.add(menuItem);  }   private void populateSettingsFromSettingsMenu() {   // synchronized: do not disturb decompiler at work (synchronize every time before run decompiler)   synchronized (settings) {    settings.setFlattenSwitchBlocks(flattenSwitchBlocks.isSelected());    settings.setForceExplicitImports(forceExplicitImports.isSelected());    settings.setShowSyntheticMembers(showSyntheticMembers.isSelected());    settings.setExcludeNestedTypes(excludeNestedTypes.isSelected());    settings.setForceExplicitTypeArguments(forceExplicitTypes.isSelected());    settings.setRetainRedundantCasts(retainRedundantCasts.isSelected());    settings.setIncludeErrorDiagnostics(showDebugInfo.isSelected());    //    // Note: You shouldn't ever need to set this.  It's only for languages that support catch    //       blocks without an exception variable.  Java doesn't allow this.  I think Scala does.    //    // settings.setAlwaysGenerateExceptionVariableForCatchBlocks(true);    //     final ButtonModel selectedLanguage = languagesGroup.getSelection();    if (selectedLanguage != null) {     final Language language = languageLookup.get(selectedLanguage.getActionCommand());      if (language != null)      settings.setLanguage(language);    }     if (java.isSelected()) {     settings.setLanguage(Languages.java());    } else if (bytecode.isSelected()) {     settings.setLanguage(Languages.bytecode());    } else if (bytecodeAST.isSelected()) {     settings.setLanguage(Languages.bytecodeAst());    }   }  }   private class ThemeAction extends AbstractAction {   private static final long serialVersionUID = -6618680171943723199L;   private String xml;    public ThemeAction(String name, String xml) {    putValue(NAME, name);    this.xml = xml;   }    @Override   public void actionPerformed(ActionEvent e) {    luytenPrefs.setThemeXml(xml);    mainWindow.onThemesChanged();   }  } } " compose:StringConcatenation merge: LineBased]
					[NT -> TooLargeFileException.java.merge : .java.merge-File]
						[T -> TooLargeFileException.java : .java-Content "package com.modcrafting.luyten;  import java.text.DecimalFormat;  public class TooLargeFileException extends Exception {  private static final long serialVersionUID = 1L;  private long size;   public TooLargeFileException(long size) {   this.size = size;  }   public String getReadableFileSize() {   if (size <= 0)    return "0";   final String[] units = new String[] {"B", "KB", "MB", "GB", "TB"};   int digitGroups = (int) (Math.log10(size) / Math.log10(1024));   return new DecimalFormat("#,##0.#").format(size / Math.pow(1024, digitGroups)) + " " + units[digitGroups];  } } " compose:StringConcatenation merge: LineBased]
					[NT -> FileSaver.java.merge : .java.merge-File]
						[T -> FileSaver.java : .java-Content "package com.modcrafting.luyten;  import java.io.BufferedOutputStream; import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.FileWriter; import java.io.InputStream; import java.io.OutputStreamWriter; import java.io.StringWriter; import java.io.Writer; import java.util.Enumeration; import java.util.List; import java.util.jar.JarEntry; import java.util.jar.JarFile; import java.util.zip.ZipException; import java.util.zip.ZipOutputStream; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JProgressBar; import com.strobel.assembler.metadata.ITypeLoader; import com.strobel.assembler.metadata.JarTypeLoader; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput; import com.strobel.decompiler.languages.java.JavaFormattingOptions;  /**  * Performs Save and Save All  */ public class FileSaver {   private JProgressBar bar;  private JLabel label;   public FileSaver(JProgressBar bar, JLabel label) {   this.bar = bar;   this.label = label;  }   public void saveText(final String text, final File file) {   new Thread(new Runnable() {    @Override    public void run() {     try (FileWriter fw = new FileWriter(file);       BufferedWriter bw = new BufferedWriter(fw);) {      label.setText("Extracting: " + file.getName());      bar.setVisible(true);      bw.write(text);      bw.flush();      label.setText("Complete");     } catch (Exception e1) {      label.setText("Cannot save file: " + file.getName());      e1.printStackTrace();      JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);     } finally {      bar.setVisible(false);     }    }   }).start();  }   public void saveAllDecompiled(final File inFile, final File outFile) {   new Thread(new Runnable() {    @Override    public void run() {     try {      bar.setVisible(true);      label.setText("Extracting: " + outFile.getName());      String inFileName = inFile.getName().toLowerCase();       if (inFileName.endsWith(".jar") || inFileName.endsWith(".zip")) {       doSaveJarDecompiled(inFile, outFile);      } else if (inFileName.endsWith(".class")) {       doSaveClassDecompiled(inFile, outFile);      } else {       doSaveUnknownFile(inFile, outFile);      }       label.setText("Complete");     } catch (Exception e1) {      e1.printStackTrace();      label.setText("Cannot save file: " + outFile.getName());      JOptionPane.showMessageDialog(null, e1.toString(), "Error!", JOptionPane.ERROR_MESSAGE);     } finally {      bar.setVisible(false);     }    }   }).start();  }   private void doSaveJarDecompiled(File inFile, File outFile) throws Exception {   try (JarFile jfile = new JarFile(inFile);     FileOutputStream dest = new FileOutputStream(outFile);     BufferedOutputStream buffDest = new BufferedOutputStream(dest);     ZipOutputStream out = new ZipOutputStream(buffDest);) {     byte data[] = new byte[1024];    DecompilerSettings settings = cloneSettings();    LuytenTypeLoader typeLoader = new LuytenTypeLoader();    MetadataSystem metadataSystem = new MetadataSystem(typeLoader);    ITypeLoader jarLoader = new JarTypeLoader(jfile);    typeLoader.getTypeLoaders().add(jarLoader);     DecompilationOptions decompilationOptions = new DecompilationOptions();    decompilationOptions.setSettings(settings);    decompilationOptions.setFullDecompilation(true);     List<String> mass = null;    JarEntryFilter jarEntryFilter = new JarEntryFilter(jfile);    LuytenPreferences luytenPrefs = ConfigSaver.getLoadedInstance().getLuytenPreferences();    if (luytenPrefs.isFilterOutInnerClassEntries()) {     mass = jarEntryFilter.getEntriesWithoutInnerClasses();    } else {     mass = jarEntryFilter.getAllEntriesFromJar();    }     Enumeration<JarEntry> ent = jfile.entries();    while (ent.hasMoreElements()) {     JarEntry entry = ent.nextElement();     if (!mass.contains(entry.getName()))      continue;     label.setText("Extracting: " + entry.getName());     bar.setVisible(true);     if (entry.getName().endsWith(".class")) {      JarEntry etn = new JarEntry(entry.getName().replace(".class", ".java"));      label.setText("Extracting: " + etn.getName());      out.putNextEntry(etn);      try {       String internalName = StringUtilities.removeRight(entry.getName(), ".class");       TypeReference type = metadataSystem.lookupType(internalName);       TypeDefinition resolvedType = null;       if ((type == null) || ((resolvedType = type.resolve()) == null)) {        throw new Exception("Unable to resolve type.");       }       Writer writer = new OutputStreamWriter(out);       settings.getLanguage().decompileType(resolvedType,         new PlainTextOutput(writer), decompilationOptions);       writer.flush();      } finally {       out.closeEntry();      }     } else {      try {       JarEntry etn = new JarEntry(entry.getName());       out.putNextEntry(etn);       try {        InputStream in = jfile.getInputStream(entry);        if (in != null) {         try {          int count;          while ((count = in.read(data, 0, 1024)) != -1) {           out.write(data, 0, count);          }         } finally {          in.close();         }        }       } finally {        out.closeEntry();       }      } catch (ZipException ze) {       // some jar-s contain duplicate pom.xml entries: ignore it       if (!ze.getMessage().contains("duplicate")) {        throw ze;       }      }     }    }    }  }   private void doSaveClassDecompiled(File inFile, File outFile) throws Exception {   DecompilerSettings settings = cloneSettings();   LuytenTypeLoader typeLoader = new LuytenTypeLoader();   MetadataSystem metadataSystem = new MetadataSystem(typeLoader);   TypeReference type = metadataSystem.lookupType(inFile.getCanonicalPath());    DecompilationOptions decompilationOptions = new DecompilationOptions();   decompilationOptions.setSettings(settings);   decompilationOptions.setFullDecompilation(true);    TypeDefinition resolvedType = null;   if (type == null || ((resolvedType = type.resolve()) == null)) {    throw new Exception("Unable to resolve type.");   }   StringWriter stringwriter = new StringWriter();   settings.getLanguage().decompileType(resolvedType,     new PlainTextOutput(stringwriter), decompilationOptions);   String decompiledSource = stringwriter.toString();    try (FileWriter fw = new FileWriter(outFile);     BufferedWriter bw = new BufferedWriter(fw);) {    bw.write(decompiledSource);    bw.flush();   }  }   private void doSaveUnknownFile(File inFile, File outFile) throws Exception {   try (FileInputStream in = new FileInputStream(inFile);     FileOutputStream out = new FileOutputStream(outFile);) {     byte data[] = new byte[1024];    int count;    while ((count = in.read(data, 0, 1024)) != -1) {     out.write(data, 0, count);    }   }  }   private DecompilerSettings cloneSettings() {   DecompilerSettings settings = ConfigSaver.getLoadedInstance().getDecompilerSettings();   DecompilerSettings newSettings = new DecompilerSettings();   if (newSettings.getFormattingOptions() == null) {    newSettings.setFormattingOptions(JavaFormattingOptions.createDefault());   }   // synchronized: against main menu changes   synchronized (settings) {    newSettings.setExcludeNestedTypes(settings.getExcludeNestedTypes());    newSettings.setFlattenSwitchBlocks(settings.getFlattenSwitchBlocks());    newSettings.setForceExplicitImports(settings.getForceExplicitImports());    newSettings.setForceExplicitTypeArguments(settings.getForceExplicitTypeArguments());    newSettings.setOutputFileHeaderText(settings.getOutputFileHeaderText());    newSettings.setLanguage(settings.getLanguage());    newSettings.setShowSyntheticMembers(settings.getShowSyntheticMembers());    newSettings.setAlwaysGenerateExceptionVariableForCatchBlocks(settings      .getAlwaysGenerateExceptionVariableForCatchBlocks());    newSettings.setOutputDirectory(settings.getOutputDirectory());    newSettings.setRetainRedundantCasts(settings.getRetainRedundantCasts());    newSettings.setIncludeErrorDiagnostics(settings.getIncludeErrorDiagnostics());    newSettings.setIncludeLineNumbersInBytecode(settings.getIncludeLineNumbersInBytecode());    newSettings.setRetainPointlessSwitches(settings.getRetainPointlessSwitches());    newSettings.setUnicodeOutputEnabled(settings.isUnicodeOutputEnabled());    newSettings.setMergeVariables(settings.getMergeVariables());    newSettings.setShowDebugLineNumbers(settings.getShowDebugLineNumbers());   }   return newSettings;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> CellRenderer.java.merge : .java.merge-File]
						[T -> CellRenderer.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Component; import java.awt.Toolkit;  import javax.swing.Icon; import javax.swing.ImageIcon; import javax.swing.JTree; import javax.swing.tree.DefaultMutableTreeNode; import javax.swing.tree.DefaultTreeCellRenderer;  public class CellRenderer extends DefaultTreeCellRenderer{  private static final long serialVersionUID = -5691181006363313993L;  Icon pack;  Icon java_image;  Icon file_image;    public CellRenderer(){   this.pack = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/package_obj.png")));   this.java_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/java.png")));   this.file_image = new ImageIcon(Toolkit.getDefaultToolkit().getImage(this.getClass().getResource("/resources/file.png")));  }   @Override  public Component getTreeCellRendererComponent(JTree tree, Object value, boolean sel, boolean expanded, boolean leaf, int row, boolean hasFocus) {   super.getTreeCellRendererComponent(tree, value, sel, expanded, leaf, row, hasFocus);         DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;   if(node.getChildCount() > 0){    setIcon(this.pack);   }else if(getFileName(node).endsWith(".class") || getFileName(node).endsWith(".java")){    setIcon(this.java_image);   }else{    setIcon(this.file_image);   }      return this;  }    public String getFileName(DefaultMutableTreeNode node){         return ((TreeNodeUserObject) node.getUserObject()).getOriginalName();  }  } " compose:StringConcatenation merge: LineBased]
					[NT -> TreeNodeUserObject.java.merge : .java.merge-File]
						[T -> TreeNodeUserObject.java : .java-Content "package com.modcrafting.luyten;  public class TreeNodeUserObject {   private String originalName;  private String displayName;   public TreeNodeUserObject(String name) {   this(name, name);  }   public TreeNodeUserObject(String originalName, String displayName) {   this.originalName = originalName;   this.displayName = displayName;  }   public String getOriginalName() {   return originalName;  }   public void setOriginalName(String originalName) {   this.originalName = originalName;  }   public String getDisplayName() {   return displayName;  }   public void setDisplayName(String displayName) {   this.displayName = displayName;  }   @Override  public String toString() {   return displayName;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LuytenPreferences.java.merge : .java.merge-File]
						[T -> LuytenPreferences.java : .java-Content "package com.modcrafting.luyten;  /**  * Do not instantiate this class, get the instance from  * ConfigSaver. All not-static fields will be saved  * automatically named by the field's java variable name.  * (Watch for collisions with existing IDs defined in  * ConfigSaver.) Only String, boolean and int fields are  * supported. Write default values into the field  * declarations.  */ public class LuytenPreferences {   public static final String THEME_XML_PATH = "/themes/";  public static final String DEFAULT_THEME_XML = "eclipse.xml";   private String themeXml = DEFAULT_THEME_XML;  private String fileOpenCurrentDirectory = "";  private String fileSaveCurrentDirectory = "";   private boolean isPackageExplorerStyle = true;  private boolean isFilterOutInnerClassEntries = true;  private boolean isSingleClickOpenEnabled = true;  private boolean isExitByEscEnabled = false;   public String getThemeXml() {   return themeXml;  }   public void setThemeXml(String themeXml) {   this.themeXml = themeXml;  }   public String getFileOpenCurrentDirectory() {   return fileOpenCurrentDirectory;  }   public void setFileOpenCurrentDirectory(String fileOpenCurrentDirectory) {   this.fileOpenCurrentDirectory = fileOpenCurrentDirectory;  }   public String getFileSaveCurrentDirectory() {   return fileSaveCurrentDirectory;  }   public void setFileSaveCurrentDirectory(String fileSaveCurrentDirectory) {   this.fileSaveCurrentDirectory = fileSaveCurrentDirectory;  }   public boolean isPackageExplorerStyle() {   return isPackageExplorerStyle;  }   public void setPackageExplorerStyle(boolean isPackageExplorerStyle) {   this.isPackageExplorerStyle = isPackageExplorerStyle;  }   public boolean isFilterOutInnerClassEntries() {   return isFilterOutInnerClassEntries;  }   public void setFilterOutInnerClassEntries(boolean isFilterOutInnerClassEntries) {   this.isFilterOutInnerClassEntries = isFilterOutInnerClassEntries;  }   public boolean isSingleClickOpenEnabled() {   return isSingleClickOpenEnabled;  }   public void setSingleClickOpenEnabled(boolean isSingleClickOpenEnabled) {   this.isSingleClickOpenEnabled = isSingleClickOpenEnabled;  }   public boolean isExitByEscEnabled() {   return isExitByEscEnabled;  }   public void setExitByEscEnabled(boolean isExitByEscEnabled) {   this.isExitByEscEnabled = isExitByEscEnabled;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> OpenFile.java.merge : .java.merge-File]
						[T -> OpenFile.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Cursor; import java.awt.Panel; import java.awt.Rectangle; import java.awt.event.AdjustmentEvent; import java.awt.event.AdjustmentListener; import java.awt.event.InputEvent; import java.awt.event.MouseEvent; import java.awt.event.MouseMotionAdapter; import java.io.StringWriter; import java.util.Arrays; import java.util.HashSet; import java.util.Map; import java.util.Set; import java.util.TreeMap; import java.util.concurrent.ConcurrentHashMap; import javax.swing.JLabel; import javax.swing.JScrollBar; import javax.swing.ScrollPaneConstants; import javax.swing.SwingUtilities; import javax.swing.event.HyperlinkEvent; import org.fife.ui.rsyntaxtextarea.LinkGenerator; import org.fife.ui.rsyntaxtextarea.LinkGeneratorResult; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea; import org.fife.ui.rsyntaxtextarea.SyntaxConstants; import org.fife.ui.rsyntaxtextarea.Theme; import org.fife.ui.rtextarea.RTextScrollPane; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput; import com.strobel.decompiler.languages.Languages;  public class OpenFile implements SyntaxConstants {   public static final HashSet<String> WELL_KNOWN_TEXT_FILE_EXTENSIONS = new HashSet<>(Arrays.asList(    ".java", ".xml", ".rss", ".project", ".classpath", ".h", ".sql", ".js", ".php", ".php5",    ".phtml", ".html", ".htm", ".xhtm", ".xhtml", ".lua", ".bat", ".pl", ".sh", ".css",    ".json", ".txt", ".rb", ".make", ".mak", ".py", ".properties", ".prop"));   // navigation links  private TreeMap<Selection, String> selectionToUniqueStrTreeMap = new TreeMap<>();  private Map<String, Boolean> isNavigableCache = new ConcurrentHashMap<>();  private Map<String, String> readableLinksCache = new ConcurrentHashMap<>();   private volatile boolean isContentValid = false;  private volatile boolean isNavigationLinksValid = false;  private volatile boolean isWaitForLinksCursor = false;  private volatile Double lastScrollPercent = null;   private LinkProvider linkProvider;  private String initialNavigationLink;  private boolean isFirstTimeRun = true;   MainWindow mainWindow;  RTextScrollPane scrollPane;  Panel image_pane;  RSyntaxTextArea textArea;  String name;  String path;   // decompiler and type references (not needed for text files)  private MetadataSystem metadataSystem;  private DecompilerSettings settings;  private DecompilationOptions decompilationOptions;  private TypeDefinition type;   public OpenFile(String name, String path, Theme theme, MainWindow mainWindow) {   this.name = name;   this.path = path;   this.mainWindow = mainWindow;   textArea = new RSyntaxTextArea(25, 70);   textArea.setCaretPosition(0);   textArea.requestFocusInWindow();   textArea.setMarkOccurrences(true);   textArea.setClearWhitespaceLinesEnabled(false);   textArea.setEditable(false);   textArea.setAntiAliasingEnabled(true);   textArea.setCodeFoldingEnabled(true);   if (name.toLowerCase().endsWith(".class")     || name.toLowerCase().endsWith(".java"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVA);   else if (name.toLowerCase().endsWith(".xml")     || name.toLowerCase().endsWith(".rss")     || name.toLowerCase().endsWith(".project")     || name.toLowerCase().endsWith(".classpath"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_XML);   else if (name.toLowerCase().endsWith(".h"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_C);   else if (name.toLowerCase().endsWith(".sql"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_SQL);   else if (name.toLowerCase().endsWith(".js"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVASCRIPT);   else if (name.toLowerCase().endsWith(".php")     || name.toLowerCase().endsWith(".php5")     || name.toLowerCase().endsWith(".phtml"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PHP);   else if (name.toLowerCase().endsWith(".html")     || name.toLowerCase().endsWith(".htm")     || name.toLowerCase().endsWith(".xhtm")     || name.toLowerCase().endsWith(".xhtml"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_HTML);   else if (name.toLowerCase().endsWith(".js"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JAVASCRIPT);   else if (name.toLowerCase().endsWith(".lua"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_LUA);   else if (name.toLowerCase().endsWith(".bat"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_WINDOWS_BATCH);   else if (name.toLowerCase().endsWith(".pl"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PERL);   else if (name.toLowerCase().endsWith(".sh"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_UNIX_SHELL);   else if (name.toLowerCase().endsWith(".css"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_CSS);   else if (name.toLowerCase().endsWith(".json"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_JSON);   else if (name.toLowerCase().endsWith(".txt"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_NONE);   else if (name.toLowerCase().endsWith(".rb"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_RUBY);   else if (name.toLowerCase().endsWith(".make")     || name.toLowerCase().endsWith(".mak"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_MAKEFILE);   else if (name.toLowerCase().endsWith(".py"))    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PYTHON);   else    textArea.setSyntaxEditingStyle(SYNTAX_STYLE_PROPERTIES_FILE);   scrollPane = new RTextScrollPane(textArea, true);   scrollPane.setIconRowHeaderEnabled(true);   textArea.setText("");   theme.apply(textArea);    scrollPane.setVerticalScrollBarPolicy(ScrollPaneConstants.VERTICAL_SCROLLBAR_ALWAYS);   final JScrollBar verticalScrollbar = scrollPane.getVerticalScrollBar();   if (verticalScrollbar != null) {    verticalScrollbar.addAdjustmentListener(new AdjustmentListener() {     @Override     public void adjustmentValueChanged(AdjustmentEvent e) {      String content = textArea.getText();      if (content == null || content.length() == 0)       return;      int scrollValue = verticalScrollbar.getValue() - verticalScrollbar.getMinimum();      int scrollMax = verticalScrollbar.getMaximum() - verticalScrollbar.getMinimum();      if (scrollMax < 1 || scrollValue < 0 || scrollValue > scrollMax)       return;      lastScrollPercent = (((double) scrollValue) / ((double) scrollMax));     }    });   }    textArea.setHyperlinksEnabled(true);   textArea.setLinkScanningMask(InputEvent.CTRL_DOWN_MASK);    textArea.setLinkGenerator(new LinkGenerator() {    @Override    public LinkGeneratorResult isLinkAtOffset(RSyntaxTextArea textArea, final int offs) {     final String uniqueStr = getUniqueStrForOffset(offs);     final Integer selectionFrom = getSelectionFromForOffset(offs);     if (uniqueStr != null && selectionFrom != null) {      return new LinkGeneratorResult() {       @Override       public HyperlinkEvent execute() {        if (isNavigationLinksValid)         onNavigationClicked(uniqueStr);        return null;       }        @Override       public int getSourceOffset() {        if (isNavigationLinksValid)         return selectionFrom;        return offs;       }      };     }     return null;    }   });    textArea.addMouseMotionListener(new MouseMotionAdapter() {    private boolean isLinkLabelPrev = false;    private String prevLinkText = null;     @Override    public synchronized void mouseMoved(MouseEvent e) {     String linkText = null;     boolean isLinkLabel = false;     boolean isCtrlDown = (e.getModifiersEx() & InputEvent.CTRL_DOWN_MASK) != 0;     if (isCtrlDown) {      linkText = createLinkLabel(e);      isLinkLabel = linkText != null;     }     if (isCtrlDown && isWaitForLinksCursor) {      textArea.setCursor(new Cursor(Cursor.WAIT_CURSOR));     } else if (textArea.getCursor().getType() == Cursor.WAIT_CURSOR) {      textArea.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));     }      JLabel label = OpenFile.this.mainWindow.getLabel();      if (isLinkLabel && isLinkLabelPrev) {      if (!linkText.equals(prevLinkText)) {       setLinkLabel(label, linkText);      }     } else if (isLinkLabel && !isLinkLabelPrev) {      setLinkLabel(label, linkText);      } else if (!isLinkLabel && isLinkLabelPrev) {      setLinkLabel(label, null);     }     isLinkLabelPrev = isLinkLabel;     prevLinkText = linkText;    }     private void setLinkLabel(JLabel label, String text) {     String current = label.getText();     if (text == null && current != null)      if (current.startsWith("Navigating:") || current.startsWith("Cannot navigate:"))       return;     label.setText(text != null ? text : "Complete");    }     private String createLinkLabel(MouseEvent e) {     int offs = textArea.viewToModel(e.getPoint());     if (isNavigationLinksValid) {      return getLinkDescriptionForOffset(offs);     }     return null;    }   });  }   public void setContent(String content) {   textArea.setText(content);  }   public void decompile() {   this.invalidateContent();   // synchronized: do not accept changes from menu while running   synchronized (settings) {    if (Languages.java().getName().equals(settings.getLanguage().getName())) {     decompileWithNavigationLinks();    } else {     decompileWithoutLinks();    }   }  }   private void decompileWithoutLinks() {   this.invalidateContent();   isNavigationLinksValid = false;   textArea.setHyperlinksEnabled(false);    StringWriter stringwriter = new StringWriter();   settings.getLanguage().decompileType(type, new PlainTextOutput(stringwriter), decompilationOptions);   setContentPreserveLastScrollPosition(stringwriter.toString());   this.isContentValid = true;  }   private void decompileWithNavigationLinks() {   this.invalidateContent();   DecompilerLinkProvider newLinkProvider = new DecompilerLinkProvider();   newLinkProvider.setDecompilerReferences(metadataSystem, settings, decompilationOptions);   newLinkProvider.setType(type);   linkProvider = newLinkProvider;    linkProvider.generateContent();   setContentPreserveLastScrollPosition(linkProvider.getTextContent());   this.isContentValid = true;   enableLinks();  }   private void setContentPreserveLastScrollPosition(final String content) {   final Double scrollPercent = lastScrollPercent;   if (scrollPercent != null && initialNavigationLink == null) {    SwingUtilities.invokeLater(new Runnable() {     @Override     public void run() {      textArea.setText(content);      restoreScrollPosition(scrollPercent);     }    });   } else {    textArea.setText(content);   }  }   private void restoreScrollPosition(final double position) {   SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     JScrollBar verticalScrollbar = scrollPane.getVerticalScrollBar();     if (verticalScrollbar == null)      return;     int scrollMax = verticalScrollbar.getMaximum() - verticalScrollbar.getMinimum();     long newScrollValue = Math.round(position * scrollMax) + verticalScrollbar.getMinimum();     if (newScrollValue < verticalScrollbar.getMinimum())      newScrollValue = verticalScrollbar.getMinimum();     if (newScrollValue > verticalScrollbar.getMaximum())      newScrollValue = verticalScrollbar.getMaximum();     verticalScrollbar.setValue((int) newScrollValue);    }   });  }   private void enableLinks() {   if (initialNavigationLink != null) {    doEnableLinks();   } else {    new Thread(new Runnable() {     @Override     public void run() {      try {       isWaitForLinksCursor = true;       doEnableLinks();      } finally {       isWaitForLinksCursor = false;       resetCursor();      }     }    }).start();   }  }   private void resetCursor() {   SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     textArea.setCursor(new Cursor(Cursor.DEFAULT_CURSOR));    }   });  }   private void doEnableLinks() {   isNavigationLinksValid = false;   linkProvider.processLinks();   buildSelectionToUniqueStrTreeMap();   clearLinksCache();   isNavigationLinksValid = true;   textArea.setHyperlinksEnabled(true);   warmUpWithFirstLink();  }   private void warmUpWithFirstLink() {   if (selectionToUniqueStrTreeMap.keySet().size() > 0) {    Selection selection = selectionToUniqueStrTreeMap.keySet().iterator().next();    getLinkDescriptionForOffset(selection.from);   }  }   public void clearLinksCache() {   try {    isNavigableCache.clear();    readableLinksCache.clear();   } catch (Exception e) {    e.printStackTrace();   }  }   private void buildSelectionToUniqueStrTreeMap() {   TreeMap<Selection, String> treeMap = new TreeMap<>();   Map<String, Selection> definitionToSelectionMap = linkProvider.getDefinitionToSelectionMap();   Map<String, Set<Selection>> referenceToSelectionsMap = linkProvider.getReferenceToSelectionsMap();    for (String key : definitionToSelectionMap.keySet()) {    Selection selection = definitionToSelectionMap.get(key);    treeMap.put(selection, key);   }   for (String key : referenceToSelectionsMap.keySet()) {    for (Selection selection : referenceToSelectionsMap.get(key)) {     treeMap.put(selection, key);    }   }   selectionToUniqueStrTreeMap = treeMap;  }   private Selection getSelectionForOffset(int offset) {   if (isNavigationLinksValid) {    Selection offsetSelection = new Selection(offset, offset);    Selection floorSelection = selectionToUniqueStrTreeMap.floorKey(offsetSelection);    if (floorSelection != null && floorSelection.from <= offset && floorSelection.to > offset) {     return floorSelection;    }   }   return null;  }   private String getUniqueStrForOffset(int offset) {   Selection selection = getSelectionForOffset(offset);   if (selection != null) {    String uniqueStr = selectionToUniqueStrTreeMap.get(selection);    if (this.isLinkNavigable(uniqueStr) && this.getLinkDescription(uniqueStr) != null) {     return uniqueStr;    }   }   return null;  }   private Integer getSelectionFromForOffset(int offset) {   Selection selection = getSelectionForOffset(offset);   if (selection != null) {    return selection.from;   }   return null;  }   private String getLinkDescriptionForOffset(int offset) {   String uniqueStr = getUniqueStrForOffset(offset);   if (uniqueStr != null) {    String description = this.getLinkDescription(uniqueStr);    if (description != null) {     return description;    }   }   return null;  }   private boolean isLinkNavigable(String uniqueStr) {   try {    Boolean isNavigableCached = isNavigableCache.get(uniqueStr);    if (isNavigableCached != null)     return isNavigableCached;     boolean isNavigable = linkProvider.isLinkNavigable(uniqueStr);    isNavigableCache.put(uniqueStr, isNavigable);    return isNavigable;   } catch (Exception e) {    e.printStackTrace();   }   return false;  }   private String getLinkDescription(String uniqueStr) {   try {    String descriptionCached = readableLinksCache.get(uniqueStr);    if (descriptionCached != null)     return descriptionCached;     String description = linkProvider.getLinkDescription(uniqueStr);    if (description != null && description.trim().length() > 0) {     readableLinksCache.put(uniqueStr, description);     return description;    }   } catch (Exception e) {    e.printStackTrace();   }   return null;  }   private void onNavigationClicked(String clickedReferenceUniqueStr) {   if (isLocallyNavigable(clickedReferenceUniqueStr)) {    onLocalNavigationRequest(clickedReferenceUniqueStr);   } else if (linkProvider.isLinkNavigable(clickedReferenceUniqueStr)) {    onOutboundNavigationRequest(clickedReferenceUniqueStr);   } else {    JLabel label = this.mainWindow.getLabel();    if (label == null)     return;    String[] linkParts = clickedReferenceUniqueStr.split("\\|");    if (linkParts.length <= 1) {     label.setText("Cannot navigate: " + clickedReferenceUniqueStr);     return;    }    String destinationTypeStr = linkParts[1];    label.setText("Cannot navigate: " + destinationTypeStr.replaceAll("/", "."));   }  }   private boolean isLocallyNavigable(String uniqueStr) {   return linkProvider.getDefinitionToSelectionMap().keySet().contains(uniqueStr);  }   private void onLocalNavigationRequest(String uniqueStr) {   try {    Selection selection = linkProvider.getDefinitionToSelectionMap().get(uniqueStr);    doLocalNavigation(selection);   } catch (Exception e) {    e.printStackTrace();   }  }   private void doLocalNavigation(Selection selection) {   try {    textArea.requestFocusInWindow();    if (selection != null) {     textArea.setSelectionStart(selection.from);     textArea.setSelectionEnd(selection.to);     scrollToSelection(selection.from);    } else {     textArea.setSelectionStart(0);     textArea.setSelectionEnd(0);    }   } catch (Exception e) {    e.printStackTrace();   }  }   private void scrollToSelection(final int selectionBeginningOffset) {   SwingUtilities.invokeLater(new Runnable() {    @Override    public void run() {     try {      int fullHeight = textArea.getBounds().height;      int viewportHeight = textArea.getVisibleRect().height;      int viewportLineCount = viewportHeight / textArea.getLineHeight();      int selectionLineNum = textArea.getLineOfOffset(selectionBeginningOffset);      int upperMarginToScroll = Math.round(viewportLineCount * 0.29f);      int upperLineToSet = selectionLineNum - upperMarginToScroll;      int currentUpperLine = textArea.getVisibleRect().y / textArea.getLineHeight();       if (selectionLineNum <= currentUpperLine + 2 ||        selectionLineNum >= currentUpperLine + viewportLineCount - 4) {       Rectangle rectToScroll = new Rectangle();       rectToScroll.x = 0;       rectToScroll.width = 1;       rectToScroll.y = Math.max(upperLineToSet * textArea.getLineHeight(), 0);       rectToScroll.height = Math.min(viewportHeight, fullHeight - rectToScroll.y);       textArea.scrollRectToVisible(rectToScroll);      }     } catch (Exception e) {      e.printStackTrace();     }    }   });  }   private void onOutboundNavigationRequest(String uniqueStr) {   mainWindow.onNavigationRequest(uniqueStr);  }   public void setDecompilerReferences(MetadataSystem metadataSystem,    DecompilerSettings settings,    DecompilationOptions decompilationOptions) {   this.metadataSystem = metadataSystem;   this.settings = settings;   this.decompilationOptions = decompilationOptions;  }   public TypeDefinition getType() {   return type;  }   public void setType(TypeDefinition type) {   this.type = type;  }   public boolean isContentValid() {   return isContentValid;  }   public void invalidateContent() {   try {    this.setContent("");   } finally {    this.isContentValid = false;    this.isNavigationLinksValid = false;   }  }   public void resetScrollPosition() {   lastScrollPercent = null;  }   public void setInitialNavigationLink(String initialNavigationLink) {   this.initialNavigationLink = initialNavigationLink;  }   public void onAddedToScreen() {   try {    if (initialNavigationLink != null) {     onLocalNavigationRequest(initialNavigationLink);    } else if (isFirstTimeRun) {     // warm up scrolling     isFirstTimeRun = false;     doLocalNavigation(new Selection(0, 0));    }   } finally {    initialNavigationLink = null;   }  }   /**   * sun.swing.CachedPainter holds on OpenFile for a while   * even after JTabbedPane.remove(component)   */  public void close() {   linkProvider = null;   type = null;   invalidateContent();   clearLinksCache();  }   @Override  public int hashCode() {   final int prime = 31;   int result = 1;   result = prime * result + ((name == null) ? 0 : name.hashCode());   return result;  }   @Override  public boolean equals(Object obj) {   if (this == obj)    return true;   if (obj == null)    return false;   if (getClass() != obj.getClass())    return false;   OpenFile other = (OpenFile) obj;   if (name == null) {    if (other.name != null)     return false;   } else if (!name.equals(other.name))    return false;   return true;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> DecompilerLinkProvider.java.merge : .java.merge-File]
						[T -> DecompilerLinkProvider.java : .java-Content "package com.modcrafting.luyten;  import java.io.StringWriter; import java.util.HashMap; import java.util.HashSet; import java.util.List; import java.util.Map; import java.util.Set; import com.strobel.assembler.metadata.FieldDefinition; import com.strobel.assembler.metadata.FieldReference; import com.strobel.assembler.metadata.MetadataSystem; import com.strobel.assembler.metadata.MethodDefinition; import com.strobel.assembler.metadata.MethodReference; import com.strobel.assembler.metadata.TypeDefinition; import com.strobel.assembler.metadata.TypeReference; import com.strobel.core.StringUtilities; import com.strobel.decompiler.DecompilationOptions; import com.strobel.decompiler.DecompilerSettings; import com.strobel.decompiler.PlainTextOutput;  public class DecompilerLinkProvider implements LinkProvider {   private Map<String, Selection> definitionToSelectionMap = new HashMap<>();  private Map<String, Set<Selection>> referenceToSelectionsMap = new HashMap<>();  private boolean isSelectionMapsPopulated = false;   private MetadataSystem metadataSystem;  private DecompilerSettings settings;  private DecompilationOptions decompilationOptions;  private TypeDefinition type;   private String currentTypeQualifiedName;  private String textContent = "";   @Override  public void generateContent() {   definitionToSelectionMap = new HashMap<>();   referenceToSelectionsMap = new HashMap<>();   currentTypeQualifiedName = type.getPackageName() + "." + type.getName();   final StringWriter stringwriter = new StringWriter();   settings.getLanguage().decompileType(type, new PlainTextOutput(stringwriter) {    @Override    public void writeDefinition(String text, Object definition, boolean isLocal) {     super.writeDefinition(text, definition, isLocal);     try {      if (text != null && definition != null) {       String uniqueStr = createUniqueStrForReference(definition);       if (uniqueStr != null) {        // fix link's underline length: _java.util.HashSet_ -> _HashSet_        text = text.replaceAll("[^\\.]*\\.", "");        int from = stringwriter.getBuffer().length() - text.length();        int to = stringwriter.getBuffer().length();        definitionToSelectionMap.put(uniqueStr, new Selection(from, to));       }      }     } catch (Exception e) {      e.printStackTrace();     }    }     @Override    public void writeReference(String text, Object reference, boolean isLocal) {     super.writeReference(text, reference, isLocal);     try {      if (text != null && reference != null) {       String uniqueStr = createUniqueStrForReference(reference);       if (uniqueStr != null) {        text = text.replaceAll("[^\\.]*\\.", "");        int from = stringwriter.getBuffer().length() - text.length();        int to = stringwriter.getBuffer().length();        if (reference instanceof FieldReference) {         // fix enum definition links (note: could not fix enum reference links)         if (((FieldReference) reference).isDefinition()) {          definitionToSelectionMap.put(uniqueStr, new Selection(from, to));          return;         }        }        if (referenceToSelectionsMap.containsKey(uniqueStr)) {         Set<Selection> selectionsSet = referenceToSelectionsMap.get(uniqueStr);         if (selectionsSet != null) {          selectionsSet.add(new Selection(from, to));         }        } else {         Set<Selection> selectionsSet = new HashSet<>();         selectionsSet.add(new Selection(from, to));         referenceToSelectionsMap.put(uniqueStr, selectionsSet);        }       }      }     } catch (Exception e) {      e.printStackTrace();     }    }   }, decompilationOptions);   textContent = stringwriter.toString();   isSelectionMapsPopulated = true;  }   private String createUniqueStrForReference(Object reference) {   String uniqueStr = null;   if (reference instanceof TypeReference) {    TypeReference type = (TypeReference) reference;    String pathAndTypeStr = getPathAndTypeStr(type);    if (pathAndTypeStr != null) {     uniqueStr = "type|" + pathAndTypeStr;    }   } else if (reference instanceof MethodReference) {    MethodReference method = (MethodReference) reference;    String pathAndTypeStr = getPathAndTypeStr(method.getDeclaringType());    if (pathAndTypeStr != null) {     uniqueStr = "method|" + pathAndTypeStr + "|" +       method.getName() + "|" + method.getErasedSignature();    }   } else if (reference instanceof FieldReference) {    FieldReference field = (FieldReference) reference;    String pathAndTypeStr = getPathAndTypeStr(field.getDeclaringType());    if (pathAndTypeStr != null) {     uniqueStr = "field|" + pathAndTypeStr + "|" + field.getName();    }   }   return uniqueStr;  }   private String getPathAndTypeStr(TypeReference typeRef) {   String name = typeRef.getName();   String packageStr = typeRef.getPackageName();   TypeReference mostOuterTypeRef = getMostOuterTypeRef(typeRef);   String mostOuterTypeName = mostOuterTypeRef.getName();   if (name != null && packageStr != null && mostOuterTypeName != null &&     name.trim().length() > 0 && mostOuterTypeName.trim().length() > 0) {    String pathStr = packageStr.replaceAll("\\.", "/") + "/" + mostOuterTypeName;    String typeStr = packageStr + "." + name.replace(".", "$");    return pathStr + "|" + typeStr;   }   return null;  }   private TypeReference getMostOuterTypeRef(TypeReference typeRef) {   int maxDecraringDepth = typeRef.getFullName().split("(\\.|\\$)").length;   for (int i = 0; i < maxDecraringDepth; i++) {    TypeReference declaringTypeRef = typeRef.getDeclaringType();    if (declaringTypeRef == null) {     break;    } else {     typeRef = declaringTypeRef;    }   }   if (typeRef.getName().contains("$")) {    return getMostOuterTypeRefBySlowLookuping(typeRef);   }   return typeRef;  }   private TypeReference getMostOuterTypeRefBySlowLookuping(TypeReference typeRef) {   String name = typeRef.getName();   if (name == null)    return typeRef;   String packageName = typeRef.getPackageName();   if (packageName == null)    return typeRef;   String[] nameParts = name.split("\\$");   String newName = "";   String sep = "";   for (int i = 0; i < nameParts.length - 1; i++) {    newName = newName + sep + nameParts[i];    sep = "$";    String newInternalName = packageName.replaceAll("\\.", "/") + "/" + newName;    TypeReference newTypeRef = metadataSystem.lookupType(newInternalName);    if (newTypeRef != null) {     TypeDefinition newTypeDef = newTypeRef.resolve();     if (newTypeDef != null) {      return newTypeRef;     }    }   }   return typeRef;  }   @Override  public String getTextContent() {   return textContent;  }   @Override  public void processLinks() {}   @Override  public Map<String, Selection> getDefinitionToSelectionMap() {   return definitionToSelectionMap;  }   @Override  public Map<String, Set<Selection>> getReferenceToSelectionsMap() {   return referenceToSelectionsMap;  }   @Override  public boolean isLinkNavigable(String uniqueStr) {   if (isSelectionMapsPopulated && definitionToSelectionMap.containsKey(uniqueStr))    return true;   if (uniqueStr == null)    return false;   String[] linkParts = uniqueStr.split("\\|");   if (linkParts.length < 3)    return false;   String typeStr = linkParts[2];   if (typeStr.trim().length() <= 0)    return false;   TypeReference typeRef = metadataSystem.lookupType(typeStr.replaceAll("\\.", "/"));   if (typeRef == null)    return false;   TypeDefinition typeDef = typeRef.resolve();   if (typeDef == null)    return false;   if (typeDef.isSynthetic())    return false;    if (isSelectionMapsPopulated) {    // current type's navigable definitions checked already, now it's erroneous    if (currentTypeQualifiedName == null || currentTypeQualifiedName.trim().length() <= 0)     return false;    if (typeStr.equals(currentTypeQualifiedName) ||      typeStr.startsWith(currentTypeQualifiedName + ".") ||      typeStr.startsWith(currentTypeQualifiedName + "$"))     return false;   }    // check linked field/method exists   if (uniqueStr.startsWith("method")) {    if (findMethodInType(typeDef, uniqueStr) == null) {     return false;    }   } else if (uniqueStr.startsWith("field")) {    if (findFieldInType(typeDef, uniqueStr) == null) {     return false;    }   }   return true;  }   private MethodDefinition findMethodInType(TypeDefinition typeDef, String uniqueStr) {   String[] linkParts = uniqueStr.split("\\|");   if (linkParts.length != 5)    return null;   String methodName = linkParts[3];   String methodErasedSignature = linkParts[4];   if (methodName.trim().length() <= 0 || methodErasedSignature.trim().length() <= 0)    return null;   List<MethodDefinition> declaredMethods = typeDef.getDeclaredMethods();   if (declaredMethods == null)    return null;   boolean isFound = false;   for (MethodDefinition declaredMethod : declaredMethods) {    isFound = (declaredMethod != null && methodName.equals(declaredMethod.getName()));    isFound = (isFound && methodErasedSignature.equals(declaredMethod.getErasedSignature()));    if (isFound) {     if (declaredMethod.isSynthetic() && !settings.getShowSyntheticMembers()) {      return null;     } else {      return declaredMethod;     }    }   }   return null;  }   private FieldDefinition findFieldInType(TypeDefinition typeDef, String uniqueStr) {   String[] linkParts = uniqueStr.split("\\|");   if (linkParts.length != 4)    return null;   String fieldName = linkParts[3];   if (fieldName.trim().length() <= 0)    return null;   List<FieldDefinition> declaredFields = typeDef.getDeclaredFields();   if (declaredFields == null)    return null;   boolean isFound = false;   for (FieldDefinition declaredField : declaredFields) {    isFound = (declaredField != null && fieldName.equals(declaredField.getName()));    if (isFound) {     if (declaredField.isSynthetic()) {      return null;     } else {      return declaredField;     }    }   }   return null;  }   @Override  public String getLinkDescription(String uniqueStr) {   String readableLink = null;   try {    if (uniqueStr == null)     return null;    String[] linkParts = uniqueStr.split("\\|");    if (linkParts.length < 3)     return null;    String typeStr = linkParts[2];    TypeReference typeRef = metadataSystem.lookupType(typeStr.replaceAll("\\.", "/"));    if (typeRef == null)     return null;    TypeDefinition typeDef = typeRef.resolve();    if (typeDef == null)     return null;     String declaredSuffix = "";    String mostOuterTypeStr = linkParts[1].replaceAll("/", ".");    boolean isOwnFile = mostOuterTypeStr.equals(currentTypeQualifiedName);    if (!isOwnFile) {     declaredSuffix = " - Declared: " + mostOuterTypeStr;    }     if (uniqueStr.startsWith("type")) {     String desc = typeDef.getBriefDescription();     if (desc != null && desc.trim().length() > 0) {      readableLink = desc;     }    } else if (uniqueStr.startsWith("method")) {     MethodDefinition methodDef = findMethodInType(typeDef, uniqueStr);     if (methodDef == null)      return null;     String desc = methodDef.getBriefDescription();     if (desc != null && desc.trim().length() > 0) {       if (desc.contains("void <init>")) {       String constructorName = typeDef.getName();       TypeReference declaringTypeRef = typeRef.getDeclaringType();       if (declaringTypeRef != null) {        TypeDefinition declaringTypeDef = declaringTypeRef.resolve();        if (declaringTypeDef != null) {         String declaringTypeName = declaringTypeDef.getName();         if (declaringTypeName != null) {          constructorName = StringUtilities.removeLeft(constructorName, declaringTypeName);          constructorName = constructorName.replaceAll("^(\\.|\\$)", "");         }        }       }       desc = desc.replace("void <init>", constructorName);       readableLink = "Constructor: " + erasePackageInfoFromDesc(desc) + declaredSuffix;      } else {       readableLink = erasePackageInfoFromDesc(desc) + declaredSuffix;      }     }    } else if (uniqueStr.startsWith("field")) {     FieldDefinition fieldDef = findFieldInType(typeDef, uniqueStr);     if (fieldDef == null)      return null;     String desc = fieldDef.getBriefDescription();     if (desc != null && desc.trim().length() > 0) {      readableLink = erasePackageInfoFromDesc(desc) + declaredSuffix;     }     }    if (readableLink != null) {     readableLink = readableLink.replace("$", ".");    }   } catch (Exception e) {    readableLink = null;    e.printStackTrace();   }   return readableLink;  }   private String erasePackageInfoFromDesc(String desc) {   String limiters = "\\(\\)\\<\\>\\[\\]\\?\\s,";   desc = desc.replaceAll("(?<=[^" + limiters + "]*)([^" + limiters + "]*)\\.", "");   return desc;  }   public void setDecompilerReferences(MetadataSystem metadataSystem,    DecompilerSettings settings,    DecompilationOptions decompilationOptions) {   this.metadataSystem = metadataSystem;   this.settings = settings;   this.decompilationOptions = decompilationOptions;  }   public void setType(TypeDefinition type) {   this.type = type;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> WindowPosition.java.merge : .java.merge-File]
						[T -> WindowPosition.java : .java-Content "package com.modcrafting.luyten;  import java.awt.Component; import java.awt.Dimension; import java.awt.Toolkit; import javax.swing.JDialog; import javax.swing.JFrame;  public class WindowPosition {   private boolean isFullScreen;  private int windowWidth;  private int windowHeight;  private int windowX;  private int windowY;   public void readPositionFromWindow(JFrame window) {   isFullScreen = (window.getExtendedState() == JFrame.MAXIMIZED_BOTH);   if (!isFullScreen) {    this.readPositionFromComponent(window);   }  }   public void readPositionFromDialog(JDialog dialog) {   this.readPositionFromComponent(dialog);  }   private void readPositionFromComponent(Component component) {   isFullScreen = false;   windowWidth = component.getWidth();   windowHeight = component.getHeight();   windowX = component.getX();   windowY = component.getY();  }   public boolean isSavedWindowPositionValid() {   if (isFullScreen) {    return true;   }   if (windowWidth < 100 || windowHeight < 100) {    return false;   }   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (windowWidth > screenSize.width + 50 || windowHeight > screenSize.height + 50) {    return false;   }   if (windowY < -20 || windowY > screenSize.height - 50 ||     windowX < 50 - windowWidth || windowX > screenSize.width - 50) {    return false;   }   return true;  }   public boolean isFullScreen() {   return isFullScreen;  }   public void setFullScreen(boolean isFullScreen) {   this.isFullScreen = isFullScreen;  }   public int getWindowWidth() {   return windowWidth;  }   public void setWindowWidth(int windowWidth) {   this.windowWidth = windowWidth;  }   public int getWindowHeight() {   return windowHeight;  }   public void setWindowHeight(int windowHeight) {   this.windowHeight = windowHeight;  }   public int getWindowX() {   return windowX;  }   public void setWindowX(int windowX) {   this.windowX = windowX;  }   public int getWindowY() {   return windowY;  }   public void setWindowY(int windowY) {   this.windowY = windowY;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> MainWindow.java.merge : .java.merge-File]
						[T -> MainWindow.java : .java-Content "package com.modcrafting.luyten;  import java.awt.BorderLayout; import java.awt.Dimension; import java.awt.Toolkit; import java.awt.dnd.DropTarget; import java.awt.event.ActionEvent; import java.awt.event.ComponentAdapter; import java.awt.event.ComponentEvent; import java.awt.event.KeyEvent; import java.awt.event.WindowAdapter; import java.awt.event.WindowEvent; import java.io.BufferedReader; import java.io.File; import java.io.IOException; import java.io.InputStreamReader; import javax.swing.AbstractAction; import javax.swing.Action; import javax.swing.BoxLayout; import javax.swing.JComponent; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JProgressBar; import javax.swing.KeyStroke; import javax.swing.border.BevelBorder; import org.fife.ui.rsyntaxtextarea.RSyntaxTextArea;  /**  * Dispatcher  */ public class MainWindow extends JFrame {  private static final long serialVersionUID = 1L;  private static final String TITLE = "Luyten";   private Model model;  private JProgressBar bar;  private JLabel label;  private FindBox findBox;  private ConfigSaver configSaver;  private WindowPosition windowPosition;  private LuytenPreferences luytenPrefs;  private FileDialog fileDialog;  private FileSaver fileSaver;   public MainWindow(File fileFromCommandLine) {   configSaver = ConfigSaver.getLoadedInstance();   windowPosition = configSaver.getMainWindowPosition();   luytenPrefs = configSaver.getLuytenPreferences();    MainMenuBar mainMenuBar = new MainMenuBar(this);   this.setJMenuBar(mainMenuBar);    this.adjustWindowPositionBySavedState();   this.setHideFindBoxOnMainWindowFocus();   this.setQuitOnWindowClosing();   this.setTitle(TITLE);    JPanel pane = new JPanel();   pane.setBorder(new BevelBorder(BevelBorder.LOWERED));   pane.setPreferredSize(new Dimension(this.getWidth(), 24));   pane.setLayout(new BoxLayout(pane, BoxLayout.X_AXIS));    JPanel panel1 = new JPanel();   label = new JLabel(" ");   label.setHorizontalAlignment(JLabel.LEFT);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setBorder(new BevelBorder(BevelBorder.LOWERED));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(label);   pane.add(panel1);    panel1 = new JPanel();   bar = new JProgressBar();   bar.setIndeterminate(true);   bar.setOpaque(false);   bar.setVisible(false);   panel1.setLayout(new BoxLayout(panel1, BoxLayout.X_AXIS));   panel1.setPreferredSize(new Dimension(this.getWidth() / 2, 20));   panel1.add(bar);   pane.add(panel1);    model = new Model(this);   this.getContentPane().add(model);   this.add(pane, BorderLayout.SOUTH);    if (fileFromCommandLine != null) {    model.loadFile(fileFromCommandLine);   }    try {    DropTarget dt = new DropTarget();    dt.addDropTargetListener(new DropListener(this));    this.setDropTarget(dt);   } catch (Exception e) {    e.printStackTrace();   }    fileDialog = new FileDialog(this);   fileSaver = new FileSaver(bar, label);    this.setExitOnEscWhenEnabled(model);    if (fileFromCommandLine == null || fileFromCommandLine.getName().toLowerCase().endsWith(".jar") ||     fileFromCommandLine.getName().toLowerCase().endsWith(".zip")) {    model.startWarmUpThread();   }  }   public void onOpenFileMenu() {   File selectedFile = fileDialog.doOpenDialog();   if (selectedFile != null) {    this.getModel().loadFile(selectedFile);   }  }   public void onCloseFileMenu() {   this.getModel().closeFile();  }   public void onSaveAsMenu() {   RSyntaxTextArea pane = this.getModel().getCurrentTextArea();   if (pane == null)    return;   String tabTitle = this.getModel().getCurrentTabTitle();   if (tabTitle == null)    return;    String recommendedFileName = tabTitle.replace(".class", ".java");   File selectedFile = fileDialog.doSaveDialog(recommendedFileName);   if (selectedFile != null) {    fileSaver.saveText(pane.getText(), selectedFile);   }  }   public void onSaveAllMenu() {   File openedFile = this.getModel().getOpenedFile();   if (openedFile == null)    return;    String fileName = openedFile.getName();   if (fileName.endsWith(".class")) {    fileName = fileName.replace(".class", ".java");   } else if (fileName.toLowerCase().endsWith(".jar")) {    fileName = "decompiled-" + fileName.replaceAll("\\.[jJ][aA][rR]", ".zip");   } else {    fileName = "saved-" + fileName;   }    File selectedFileToSave = fileDialog.doSaveAllDialog(fileName);   if (selectedFileToSave != null) {    fileSaver.saveAllDecompiled(openedFile, selectedFileToSave);   }  }   public void onExitMenu() {   quit();  }   public void onSelectAllMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     pane.requestFocusInWindow();     pane.setSelectionStart(0);     pane.setSelectionEnd(pane.getText().length());    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onFindMenu() {   try {    RSyntaxTextArea pane = this.getModel().getCurrentTextArea();    if (pane != null) {     if (findBox == null)      findBox = new FindBox(this);     findBox.showFindBox();    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onLegalMenu() {   new Thread() {    public void run() {     try {      bar.setVisible(true);      String legalStr = getLegalStr();      MainWindow.this.getModel().showLegal(legalStr);     } finally {      bar.setVisible(false);     }    }   }.start();  }   private String getLegalStr() {   StringBuilder sb = new StringBuilder();   try {    BufferedReader reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/Procyon.License.txt")));    String line;    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");    sb.append("\n\n\n\n\n");    reader = new BufferedReader(new InputStreamReader(getClass()      .getResourceAsStream("/distfiles/RSyntaxTextArea.License.txt")));    while ((line = reader.readLine()) != null)     sb.append(line).append("\n");   } catch (IOException e) {    e.printStackTrace();   }   return sb.toString();  }   public void onThemesChanged() {   this.getModel().changeTheme(luytenPrefs.getThemeXml());  }   public void onSettingsChanged() {   this.getModel().updateOpenClasses();  }   public void onTreeSettingsChanged() {   this.getModel().updateTree();  }   public void onFileDropped(File file) {   if (file != null) {    this.getModel().loadFile(file);   }  }   public void onFileLoadEnded(File file, boolean isSuccess) {   try {    if (file != null && isSuccess) {     this.setTitle(TITLE + " - " + file.getName());    } else {     this.setTitle(TITLE);    }   } catch (Exception e) {    e.printStackTrace();   }  }   public void onNavigationRequest(String uniqueStr) {   this.getModel().navigateTo(uniqueStr);  }   private void adjustWindowPositionBySavedState() {   Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();   if (!windowPosition.isSavedWindowPositionValid()) {    final Dimension center = new Dimension((int) (screenSize.width * 0.75), (int) (screenSize.height * 0.75));    final int x = (int) (center.width * 0.2);    final int y = (int) (center.height * 0.2);    this.setBounds(x, y, center.width, center.height);    } else if (windowPosition.isFullScreen()) {    int heightMinusTray = screenSize.height;    if (screenSize.height > 30)     heightMinusTray -= 30;    this.setBounds(0, 0, screenSize.width, heightMinusTray);    this.setExtendedState(JFrame.MAXIMIZED_BOTH);     this.addComponentListener(new ComponentAdapter() {     @Override     public void componentResized(ComponentEvent e) {      if (MainWindow.this.getExtendedState() != JFrame.MAXIMIZED_BOTH) {       windowPosition.setFullScreen(false);       if (windowPosition.isSavedWindowPositionValid()) {        MainWindow.this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),          windowPosition.getWindowWidth(), windowPosition.getWindowHeight());       }       MainWindow.this.removeComponentListener(this);      }     }    });    } else {    this.setBounds(windowPosition.getWindowX(), windowPosition.getWindowY(),      windowPosition.getWindowWidth(), windowPosition.getWindowHeight());   }  }   private void setHideFindBoxOnMainWindowFocus() {   this.addWindowFocusListener(new WindowAdapter() {    @Override    public void windowGainedFocus(WindowEvent e) {     if (findBox != null && findBox.isVisible()) {      findBox.setVisible(false);     }    }   });  }   private void setQuitOnWindowClosing() {   this.addWindowListener(new WindowAdapter() {    @Override    public void windowClosing(WindowEvent e) {     quit();    }   });  }   private void quit() {   try {    windowPosition.readPositionFromWindow(this);    configSaver.saveConfig();   } catch (Exception exc) {    exc.printStackTrace();   } finally {    try {     this.dispose();    } finally {     System.exit(0);    }   }  }   private void setExitOnEscWhenEnabled(JComponent mainComponent) {   Action escapeAction = new AbstractAction() {    private static final long serialVersionUID = 1L;     @Override    public void actionPerformed(ActionEvent e) {     if (luytenPrefs.isExitByEscEnabled()) {      quit();     }    }   };    KeyStroke escapeKeyStroke = KeyStroke.getKeyStroke(KeyEvent.VK_ESCAPE, 0, false);   mainComponent.getInputMap(JComponent.WHEN_ANCESTOR_OF_FOCUSED_COMPONENT).put(escapeKeyStroke, "ESCAPE");   mainComponent.getActionMap().put("ESCAPE", escapeAction);  }   public Model getModel() {   return model;  }   public JProgressBar getBar() {   return bar;  }   public JLabel getLabel() {   return label;  } } " compose:StringConcatenation merge: LineBased]
					[NT -> LuytenTypeLoader.java.merge : .java.merge-File]
						[T -> LuytenTypeLoader.java : .java-Content "package com.modcrafting.luyten;  import com.strobel.assembler.InputTypeLoader; import com.strobel.assembler.metadata.Buffer; import com.strobel.assembler.metadata.ITypeLoader;  import java.util.ArrayList; import java.util.List;  public final class LuytenTypeLoader implements ITypeLoader {     private final List<ITypeLoader> _typeLoaders;      public LuytenTypeLoader() {         _typeLoaders = new ArrayList<ITypeLoader>();         _typeLoaders.add(new InputTypeLoader());     }      public final List<ITypeLoader> getTypeLoaders() {         return _typeLoaders;     }      @Override     public boolean tryLoadType(final String internalName, final Buffer buffer) {         for (final ITypeLoader typeLoader : _typeLoaders) {             if (typeLoader.tryLoadType(internalName, buffer)) {                 return true;             }              buffer.reset();         }          return false;     } } " compose:StringConcatenation merge: LineBased]
